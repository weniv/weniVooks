---
chapter: NumPy :세 번째 걸음
title: NumPy를 이용한 선형대수학
date: 2024-07-10
---
# 행렬 연산 심화

## 1.1 행렬 곱셈

행렬 곱셈은 두 행렬의 원소들을 특정 규칙에 따라 곱하고 더하는 연산입니다. 이 연산의 주요 특징으로, 결과 행렬의 크기는 `첫 번째 행렬의 행 수와 두 번째 행렬의 열 수`로 결정됩니다. 또한, 곱셈이 가능하려면 `첫 번째 행렬의 열 수와 두 번째 행렬의 행 수가 같아야` 합니다. 중요한 점은 행렬 곱셈이 `일반적으로 교환법칙이 성립하지 않아` AB와 BA의 결과가 다를 수 있다는 것입니다.

```python-exec
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

C = np.dot(A, B)
print("행렬 A:")
print(A)
print("\n행렬 B:")
print(B)
print("\n행렬 곱셈 결과 (A * B):")
print(C)

```

`tip`"행렬 곱셈은 마치 요리 레시피를 따라 여러 재료를 정해진 순서와 비율로 섞는 것과 같아요. 각 행과 열이 만나는 지점마다 특별한 '조리법'을 적용하는 거죠."

## 1.2 역행렬

역행렬은 원래 행렬과 곱했을 때 단위행렬이 되는 특별한 행렬입니다. 이 개념의 주요 특징으로, 역행렬은 `정방행렬(n x n)에서만 존재`할 수 있으며, 행렬의 `행렬식(determinant)이 0이 아닐 때만` 구할 수 있습니다. 역행렬의 중요한 성질은 원래 행렬과 곱하면 그 `행렬의 효과를 '취소'`할 수 있다는 점입니다

```python-exec
A = np.array([[1, 2], [3, 4]])
print("A의 역행렬:")
print(A)
```

`tip`"역행렬은 마법의 '실행 취소' 버튼 같아요. 행렬 A가 어떤 변환을 나타낸다면, 그 역행렬은 그 변환을 정확히 되돌리는 역할을 합니다."

## 1.3 의사역행렬

의사역행렬(Moore-Penrose 역행렬)은 일반적인 역행렬의 개념을 확장한 것으로, 정방행렬이 아니거나 역행렬이 존재하지 않는 행렬에도 적용할 수 있는 일반화된 역행렬입니다. 이 개념의 주요 특징으로, 의사역행렬은 `모든 행렬에 대해 정의`될 수 있어 정방행렬에 국한되지 않습니다. 특히 의사역행렬은 `최소제곱법 문제 해결에 유용`하게 사용되며, 완벽한 역행렬이 존재하지 않는 상황에서 `'최선의 근사'를 제공`합니다.

```python-exec
A = np.array([[1, 2, 3], [4, 5, 6]])
A_pinv = np.linalg.pinv(A)
print("행렬 A:")
print(A)
print("A의 의사역행렬:")
print( A_pinv)
```

`tip`"의사역행렬은 완벽한 '실행 취소'가 불가능할 때 사용하는 '최선의 근사' 버튼 같아요. 원래 변환을 완벽히 되돌릴 수는 없지만, 가능한 한 가장 가까운 결과를 제공합니다."

# 2. 벡터 연산 심화

## 2.1 고유값 (Eigenvalues)

고유값은 행렬 변환에서 중요한 특성을 나타내는 스칼라 값입니다. 이는 `행렬을 특정 스칼라 값으로 곱했을 때 방향이 변하지 않는 벡터(고유벡터)에 대응`하는 값입니다. 고유값의 주요 특징으로, 이는 `정방행렬에 대해서만 계산 가능`하며, 그 `개수는 행렬의 차원과 같습니다`

```python-exec
A = np.array([[1, 2], [2, 3]])
eigenvalues = np.linalg.eigvals(A)

print("행렬 A:")
print(A)
print("고유값:", eigenvalues)
```

`tip`"고유값을 찾는 것은 마치 행렬이라는 변환 기계의 '강도 조절 다이얼'을 찾는 것과 같아요. 이 다이얼은 변환의 세기를 나타내며, 양수면 확대, 음수면 축소와 방향 전환을 의미합니다. 예를 들어, -0.23606798이라는 고유값은 해당 방향으로 변환이 약 0.24배로 축소되고 방향이 반대가 됨을 나타내죠."

## 2.2 고유벡터 (Eigenvectors)

고유벡터는 행렬 변환에서 특별한 의미를 갖는 벡터입니다. 이는 `행렬에 의해 변환될 때 방향이 변하지 않고 오직 크기만 변하는 0이 아닌 벡터`입니다. 고유벡터의 주요 특징으로, `각 고유값에 대응하는 고유벡터가 존재`하며, 이 벡터들은 `행렬 변환 후에도 방향이 변하지 않습니다`. 또한, `서로 다른 고유값에 대응하는 고유벡터들은 선형독립`입니다.

```python-exec
A = np.array([[1, 2], [2, 3]])
eigenvalues, eigenvectors = np.linalg.eig(A)

print("행렬 A:")
print(A)
print("고유벡터:", eigenvectors)

```

`tip`"고유벡터를 찾는 것은 마치 행렬이라는 변환 기계의 '비밀 통로'를 찾는 것과 같아요. 이 통로를 통과하는 벡터들은 변환 후에도 방향이 변하지 않고, 오직 크기만 변합니다. 이는 마치 특별한 빛줄기가 거울에 반사될 때 방향은 그대로 유지한 채 밝기만 변하는 것과 비슷하죠."

## 3. 선형 방정식

선형 방정식은 선형 대수학에서 중요한 개념으로, `Ax = b` 형태의 방정식에서 x를 찾는 과정입니다. 여기서 A는 계수 행렬, b는 상수 벡터, x는 우리가 찾고자 하는 해입니다. 이 방정식의 주요 특징으로, 해가 `존재하지 않거나, 유일하거나, 무한히 많을 수 있습니다`. 선형 방정식은 `가우스 소거법, LU 분해 등 다양한 방법으로 해결 가능`하며, 이러한 방법들은 일반적으로 역행렬을 이용한 방법보다 수치적으로 더 안정적이고 효율적입니다.

```python-exec
# 선형 방정식 Ax = b 설정
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# 방정식 풀기
x = np.linalg.solve(A, b)

print("행렬 A:")
print(A)
print("벡터 b:", b)
print("해 x:", x)

# 해의 검증
print("검증 (Ax == b):", np.allclose(np.dot(A, x), b))

```

`tip`"선형 방정식을 푸는 것은 마치 복잡한 퍼즐을 푸는 것과 같아요. 우리가 가진 정보(A와 b)를 이용해 숨겨진 답(x)을 찾아내는 거죠. NumPy는 이 퍼즐을 빠르고 정확하게 풀어주는 똑똑한 도우미 역할을 합니다. 예를 들어, 이 예제에서 우리는 '3x + y = 9'와 'x + 2y = 8'이라는 두 개의 방정식을 동시에 푸는 셈이에요. 그리고 NumPy가 순식간에 x = 2, y = 3이라는 해답을 찾아줍니다."