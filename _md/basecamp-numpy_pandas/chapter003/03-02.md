---
chapter: NumPy :세 번째 걸음
title: NumPy를 이용한 선형대수학
date: 2024-07-10
---
# 행렬 연산 심화

## 1.1 행렬 곱셈

- 행렬 곱셈은 두 행렬의 원소들을 특정 규칙에 따라 곱하고 더하는 연산입니다.
- **주요 특징:**
    1. 결과 행렬의 크기는 (A의 행 수) x (B의 열 수)
    2. A의 열 수와 B의 행 수가 같아야 함
    3. 행렬 곱셈은 일반적으로 교환법칙이 성립하지 않음 (AB ≠ BA)

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

C = np.dot(A, B)
print("행렬 A:\\n", A)
print("행렬 B:\\n", B)
print("행렬 곱셈 결과 (A * B):\\n", C)
# 결과:
# 행렬 A:
#  [[1 2]
#  [3 4]]
# 행렬 B:
#  [[5 6]
#  [7 8]]
# 행렬 곱셈 결과 (A * B):
#  [[19 22]
#  [43 50]]
```

> *"행렬 곱셈은 마치 요리 레시피를 따라 여러 재료를 정해진 순서와 비율로 섞는 것과 같아요. 각 행과 열이 만나는 지점마다 특별한 '조리법'을 적용하는 거죠."*
> 

## 1.2 역행렬

- 역행렬 A^(-1)은 원래 행렬 A와 곱했을 때 단위행렬이 되는 행렬입니다.
- **주요 특징:**
    1. 정방행렬(n x n)만 역행렬을 가질 수 있음
    2. 행렬식(determinant)이 0이 아닐 때만 존재
    3. 역행렬을 곱하면 원래의 행렬 효과를 '취소'할 수 있음

```python
A = np.array([[1, 2], [3, 4]])
A_inv = np.linalg.inv(A)
print("행렬 A:\\n", A)
print("A의 역행렬:\\n", A_inv)

# 검증
print("A * A^(-1):\\n", np.dot(A, A_inv))
# 결과:
# 행렬 A:
#  [[1 2]
#  [3 4]]
# A의 역행렬:
#  [[-2.   1. ]
#  [ 1.5 -0.5]]
# A * A^(-1):
#  [[1.0000000e+00 0.0000000e+00]
#  [8.8817842e-16 1.0000000e+00]]

```

> *"역행렬은 마법의 '실행 취소' 버튼 같아요. 행렬 A가 어떤 변환을 나타낸다면, 그 역행렬은 그 변환을 정확히 되돌리는 역할을 합니다."*
> 

## 1.3 의사역행렬

- 의사역행렬(Moore-Penrose 역행렬)은 정방행렬이 아니거나 역행렬이 존재하지 않는 행렬에 대해 정의되는 일반화된 역행렬입니다.
    
    **-주요 특징:**
    
    1. 모든 행렬에 대해 정의됨 (정방행렬이 아니어도 됨)
    2. 최소제곱법 문제 해결에 유용
    3. 완벽한 역행렬이 없을 때 '최선의 근사'를 제공

```python
A = np.array([[1, 2, 3], [4, 5, 6]])
A_pinv = np.linalg.pinv(A)
print("행렬 A:\\n", A)
print("A의 의사역행렬:\\n", A_pinv)

# 검증
print("A * A+ * A:\\n", np.dot(np.dot(A, A_pinv), A))
# 결과:
# 행렬 A:
#  [[1 2 3]
#  [4 5 6]]
# A의 의사역행렬:
#  [[-0.94444444  0.44444444]
#  [-0.11111111  0.11111111]
#  [ 0.72222222 -0.22222222]]
# A * A+ * A:
#  [[1. 2. 3.]
#  [4. 5. 6.]]
```

> *"의사역행렬은 완벽한 '실행 취소'가 불가능할 때 사용하는 '최선의 근사' 버튼 같아요. 원래 변환을 완벽히 되돌릴 수는 없지만, 가능한 한 가장 가까운 결과를 제공합니다."*
> 

# 2. 벡터 연산 심화

## 2.1 고유값 (Eigenvalues)
- 고유값은 행렬을 특정 스칼라 값으로 곱했을 때 방향이 변하지 않는 벡터(고유벡터)에 대응하는 스칼라 값입니다.
- **주요 특징:**
    1. 정방행렬에 대해서만 계산 가능
    2. 고유값의 개수는 행렬의 차원과 같음
    3. 행렬의 대각합(trace은 모든 고유값의 합과 같음
    4. 행렬식(determinant)은 모든 고유값의 곱과 같음

```python
A = np.array([[1, 2], [2, 3]])
eigenvalues = np.linalg.eigvals(A)

print("행렬 A:\\n", A)
print("고유값:", eigenvalues)

# 결과:
# 행렬 A:
#  [[1 2]
#  [2 3]]
# 고유값: [-0.23606798  4.23606798]

```

> *"고유값을 찾는 것은 마치 행렬이라는 변환 기계의 '강도 조절 다이얼'을 찾는 것과 같아요. 이 다이얼은 변환의 세기를 나타내며, 양수면 확대, 음수면 축소와 방향 전환을 의미합니다. 예를 들어, -0.23606798이라는 고유값은 해당 방향으로 변환이 약 0.24배로 축소되고 방향이 반대가 됨을 나타내죠."*
> 

## 2.2 고유벡터 (Eigenvectors)

- 고유벡터는 행렬에 의해 변환될 때 방향이 변하지 않고 오직 크기만 변하는 0이 아닌 벡터입니다.
- **주요 특징:**
    1. 각 고유값에 대응하는 고유벡터가 존재
    2. 고유벡터는 행렬 변환 후에도 방향이 변하지 않음
    3. 서로 다른 고유값에 대응하는 고유벡터들은 선형독립
    4. 고유벡터는 스칼라 배를 해도 여전히 고유벡터임

```python
A = np.array([[1, 2], [2, 3]])
eigenvalues, eigenvectors = np.linalg.eig(A)

print("행렬 A:\\n", A)
print("고유벡터:\\n", eigenvectors)

# 검증
for i in range(len(eigenvalues)):
    print(f"고유값 {eigenvalues[i]}에 대한 고유벡터 검증:")
    print(np.allclose(A.dot(eigenvectors[:, i]), eigenvalues[i] * eigenvectors[:, i]))

# 결과:
# 행렬 A:
#  [[1 2]
#  [2 3]]
# 고유벡터:
#  [[-0.85065081 -0.52573111]
#  [ 0.52573111 -0.85065081]]
# 고유값 -0.23606797749978969에 대한 고유벡터 검증:
# True
# 고유값 4.236067977499790에 대한 고유벡터 검증:
# True

```

> *"고유벡터를 찾는 것은 마치 행렬이라는 변환 기계의 '비밀 통로'를 찾는 것과 같아요. 이 통로를 통과하는 벡터들은 변환 후에도 방향이 변하지 않고, 오직 크기만 변합니다. 이는 마치 특별한 빛줄기가 거울에 반사될 때 방향은 그대로 유지한 채 밝기만 변하는 것과 비슷하죠."*
> 

## 3.  선형 방정식

- 선형 방정식은 Ax = b 형태의 방정식에서 x를 찾는 과정입니다. 여기서 A는 계수 행렬, b는 상수 벡터, x는 우리가 찾고자 하는 해입니다.
- **주요 특징:**
    1. 해가 존재하지 않거나, 유일하거나, 무한히 많을 수 있음
    2. 가우스 소거법, LU 분해 등 다양한 방법으로 해결 가능
    3. 역행렬을 이용한 방법보다 수치적으로 안정적이고 효율적임

```python
# 선형 방정식 Ax = b 설정
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# 방정식 풀기
x = np.linalg.solve(A, b)

print("행렬 A:\n", A)
print("벡터 b:", b)
print("해 x:", x)

# 해의 검증
print("검증 (Ax == b):", np.allclose(np.dot(A, x), b))

# 결과:
# 행렬 A:
#  [[3 1]
#  [1 2]]
# 벡터 b: [9 8]
# 해 x: [2. 3.]
# 검증 (Ax == b): True

```

> *"선형 방정식을 푸는 것은 마치 복잡한 퍼즐을 푸는 것과 같아요. 우리가 가진 정보(A와 b)를 이용해 숨겨진 답(x)을 찾아내는 거죠. NumPy는 이 퍼즐을 빠르고 정확하게 풀어주는 똑똑한 도우미 역할을 합니다. 예를 들어, 이 예제에서 우리는 '3x + y = 9'와 'x + 2y = 8'이라는 두 개의 방정식을 동시에 푸는 셈이에요. 그리고 NumPy가 순식간에 x = 2, y = 3이라는 해답을 찾아줍니다."*
>