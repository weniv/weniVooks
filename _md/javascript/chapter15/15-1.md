---
chapter: promise, async, await
title: 비동기 프로그래밍
date: 2024-05-02
---

:::div{.callout}
**관련 도서**  
::a[알잘딱깔센 JavaScript]{class="btn-link" href="https://morning-heart-e2a.notion.site/8-await-async-fetch-835e5806f6be444aa02ccfd38cb7a9b7" target="\_blank"}
::a[알잘딱깔센 비동기 프로그래밍]{class="btn-link" href="https://paullabworkspace.notion.site/JavaScript-e171d97722484860aa5b162afae83cb1" target="\_blank"}
:::

# 1. 동기와 비동기

```javascript
// 동기 - 순차적
// 호준 : 로봇 청소기 돌리고(10시)
// 호준 : 빨래하고(11시)
// 호준 : 설거지하고(12시)
// 호준 : 요리한다(1시)

// 비동기 - 비순차적
// 호준 : 로봇 청소기 돌리면서(10시)
// 호준 : 빨래도 돌리고(10시)
// 호준 : 설거지하고(10시)
// 호준 : 요리할려고 물도 끓이고(10시)
const one = '1';
const two = '2';
const three = '3';

console.log(one);
setTimeout(() => {
  console.log(two);
}, 1000);
console.log(three);

// 아래 코드는 왜 그럴까요?
const one = '1';
const two = '2';
const three = '3';

console.log(one);
setTimeout(() => {
  console.log(two);
}, 0);
console.log(three);

// 싱글쓰레드
// 일할 수 있는 녀석이 1명 -> JS

// 멀티쓰레드
// 일할 수 있는 녀석이 여러명 -> 다른언어 대부분이 지원합니다.
// * JS는 싱글쓰레드이지만 웹 브라우저는 멀티쓰레드가 가능합니다. 이에 대해서는 이 챕터의 마지막 목차인 호출스택에서 자세하게 알아봅니다.

// 우리가 이런 비동기 프로그래밍을 왜 알아야 하고, JavaScript의 실행 구조는 왜 알아야 하는가?

one(); // 페이지 로드하고
two(); // 서버에서 이미지와 상세 데이터를 받아오고(예 - http://test.api.weniv.co.kr/mall) - 1분
three(); // 읽어온 데이터를 뿌려준다
four(); // 페이지에 정적 데이터 로드
```

# 2. callback 함수와 callback 지옥

- 콜백 함수는 아래처럼 나중에 실행할 함수!

```jsx
const 버튼 = document.querySelector('.button');
버튼.addEventListener('click', function () {});

// 버튼.addEventListener('click', '다른 곳에서 짠 함수이름'); // ex('click', helloworld100)
// function helloworld100() {
//    console.log('hello world');
//    console.log('hello world');
// }
// 버튼.addEventListener('click', ()=>{});
```

```jsx
function 함수하나(출력) {
  console.log('hello');
  출력('world');
}

함수하나(console.log);
```

- 위에 코드가 작성이 되는 이유는 함수나 메서드는 결국 어떤 기능을 가리키고 있는 식별자이기 때문

```jsx
let hojun = console.log;
hojun('hello world');
```

- 함수 하나가 로그인 기능이었고, 이 로그인 기능 이후에 계좌 연동, 이미지 로드 등의 기능이 실행되어야 한다면 아래와 같이 여러 함수들의 중첩이 일어남

```jsx
user.login(
    id,
    pw,
    로그인성공,
    로그인실패,
    이미지로드,
    계좌연동...)
```

- 여기서는 콜백지옥(callback hell)이 잘 감이 안오지만 아래처럼 실제 코드로 짜보면 감이옴.

```jsx
userData.login(
    id,
    pw,
    (user) => {
        userData.getData(
            user,
            (userData) => {
                ..콜백에 콜백..
            },
            (fail) => {
                ..콜백에 콜백..
            }
        );
    },
    (fail) => {
        ..콜백에 콜백..
    },
    (user) => { //이미지 로드
        ..콜백에 콜백..
    },
    (user) => { // 계좌 연동
        ..콜백에 콜백..
    },
);
```

- 콜백 지옥 코드 체험(모던자바스크립트 예제)
  ::a[콜백 - 모던 자바스크립트]{class="btn-link" href="https://ko.javascript.info/callbacks" target="\_blank"}

# 3. Promise

- 비동기 프로그래밍을 할 수 있게 해주며 위에서 언급된 콜백 지옥을 ‘어느정도’ 탈출할 수 있게 만들어주는 것이 promise!
- promise(약속하다)는 콜백함수를 다시 부르겠다는 뜻(pending(대기)을 거쳐)
- 노드를 하실 것이라면 반드시 알아야 함!
- promise의 상태
  - pending(대기상태) - resolve(해결) - fulfilled(성공)
  - pending(대기상태) - reject(거부) - rejected(실패)

```jsx
let p = new Promise(function (resolve, reject) {
  // 실행코드
});

// resolve(value) — 작업이 성공적으로 마무리되면 호출, 결과는 value에 담김
// reject(error) — 작업이 실패시 호출, error는 error에 담김
```

```jsx
// 쉬운 예제
let p = new Promise(function (resolve, reject) {
  resolve('hello world');
})
  .then((메시지) => {
    alert(메시지);
    return 메시지.split(' ')[0];
  })
  .then((메시지) => {
    alert(메시지);
    return 메시지[0];
  })
  .then((메시지) => {
    alert(메시지);
  });

let p = new Promise(function (resolve, reject) {
  // resolve('hello world');
  reject('hello world');
})
  .then((메시지) => {
    alert(메시지);
    return 메시지.split(' ')[0];
  })
  .then((메시지) => {
    alert(메시지);
    return 메시지[0];
  })
  .then((메시지) => {
    alert(메시지);
  })
  .catch((메시지) => {
    alert('catch 실행!! :' + 메시지);
  });

let p = new Promise(function (resolve, reject) {
  // resolve('hello world');
  reject('hello world');
})
  .then((메시지) => {
    alert(메시지);
    throw Error('에러 발생!');
    return 메시지.split(' ')[0];
  })
  .then((메시지) => {
    alert(메시지);
    return 메시지[0];
  })
  .then((메시지) => {
    alert(메시지);
  })
  .catch((메시지) => {
    alert('catch 실행!! :' + 메시지);
  });

let p = new Promise(function (resolve, reject) {
  // resolve('hello world');
  // reject('hello world');
  resolve('hello world');
})
  .then((메시지) => {
    alert(메시지);
    throw Error('에러 발생!');
    return 메시지.split(' ')[0];
  })
  .then((메시지) => {
    alert(메시지);
    return 메시지[0];
  })
  .then((메시지) => {
    alert(메시지);
  })
  .catch((메시지) => {
    alert('catch 실행!! :' + 메시지);
  });
```

- console.log로 promise를 찍어보세요. `비동기`가 핵심입니다.
- 성공과 실패만 합니다. 중립은 없습니다. 대기(pending)는 있습니다.

```jsx
let p = new Promise(function (resolve, reject) {
  setTimeout(() => resolve('끝남!'), 3000);
});
console.log('hello world');
console.log(p);
//3초 후 다시 실행
console.log(p);
```

- 애러를 던져봅시다.

```jsx
let p = new Promise(function (resolve, reject) {
  setTimeout(() => reject('애러야!'), 3000);
});
console.log('hello world');
console.log(p);
//3초 후 다시 실행
console.log(p);
```

- pending(대기)에서 영원히 못빠져나오게도 할 수 있습니다.

```jsx
// 실행하지 마세요. pending에 빠집니다.
let p = new Promise(function (resolve, reject) {
  console.log('hello world');
})
  .then((d) => console.log(d))
  .catch((e) => console.log(e));
```

- 전체적인 모습은 아래와 같습니다. 실행이 되는 코드는 Node에서 살펴보도록 하겠습니다.

```jsx
new Promise((resolve, reject) => {
  /*code*/
})
  .then((result) => result)
  .then((result) => result)
  .catch((err) => err)
  .finally((result) => result);
```

- 아래 코드를 콘솔에서 실행해보세요.

```jsx
// 모던자바스크립트 예제
new Promise(function (resolve, reject) {
  setTimeout(() => resolve(1), 1000); // (*)
})
  .then(function (result) {
    // (**)

    alert(result); // 1
    return result * 2;
  })
  .then(function (result) {
    // (***)

    alert(result); // 2
    return result * 2;
  })
  .then(function (result) {
    alert(result); // 4
    return result * 2;
  });
```

```jsx
// 모던자바스크립트 예제 (살짝 수정)
new Promise(function (resolve, reject) {
  setTimeout(() => reject('error'), 1000);
})
  .then(function (result) {
    alert(result + ' : 잘 수행!');
    return result + 'one';
  })
  .catch(function (result) {
    alert(result + ' : 애러 발생!'); // 1
    return result + 'two';
  })
  .then(function (result) {
    alert(result + ' : 잘 수행!'); // 2
    return result + 'three';
  });
```

- 프러미스 체이닝

```jsx
// 모던자바스크립트 예제
let p = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(1), 10000); // (*)
});
console.log('hello world');
let p2 = p.then(function (result) {
  // (**)

  console.log(result); // 1
  return result * 2;
});
console.log('hello world2');
let p3 = p2.then(function (result) {
  // (***)

  console.log(result); // 2
  return result * 2;
});
console.log('hello world3');
let p4 = p3.then(function (result) {
  console.log(result); // 4
  return result * 2;
});
```

- 다음 예제는 프라미스 체이닝이 아님!

```jsx
// 모던자바스크립트 예제
let promise = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function (result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function (result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function (result) {
  alert(result); // 1
  return result * 2;
});
```

- 모던 자바스크립트의 콜백함수 애러처리

```jsx
// 모던자바스크립트
// 정리 전

loadScript('1.js', function (error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function (error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function (error, script) {
          if (error) {
            handleError(error);
          } else {
            // 모든 스크립트가 로딩된 후, 실행 흐름이 이어집니다. (*)
          }
        });
      }
    });
  }
});

// 정리 후
loadScript('/article/promise-chaining/one.js')
  .then((script) => loadScript('/article/promise-chaining/two.js'))
  .then((script) => loadScript('/article/promise-chaining/three.js'))
  .then((script) => {
    // 스크립트를 정상적으로 불러왔기 때문에 스크립트 내의 함수를 호출할 수 있습니다.
    one();
    two();
    three();
  });
```

# 4. 실전예제

## 4.1 코로나 접종 퍼센트 구하기

- 아래 예제를 확인해보면 1과 2가 출력되고 나중에 console.log가 출력이 되기 때문에 비동기라는 것을 알 수가 있습니다.

```jsx
const f = fetch(
  'https://raw.githubusercontent.com/paullabkorea/coronaVaccinationStatus/main/data/data.json',
)
  .then(function (response) {
    return response.json();
  })
  .then(function (json) {
    console.log(json);
    return json;
  });
console.log(f);
console.log(1);
console.log(2);
```

- 실전예제

  ::a[Response.json() - Web APIs | MDN]{class="btn-link" href="https://developer.mozilla.org/en-US/docs/Web/API/Response/json" target="\_blank"}

```jsx
fetch(
  'https://raw.githubusercontent.com/paullabkorea/coronaVaccinationStatus/main/data/data.json',
)
  .then(function (response) {
    console.log(1);
    return response.json();
  })
  .then(function (json) {
    console.log(2);
    console.log(json);
    return json;
  })
  .then(function (json) {
    console.log(3);
    console.log(json.filter((s) => s['시·도별(1)'] === '전국'));
    return;
  });
```

```jsx
// 1차 접종 퍼센트를 구해주세요!
fetch(
  'https://raw.githubusercontent.com/paullabkorea/coronaVaccinationStatus/main/data/data.json',
)
  .then(function (response) {
    console.log(1);
    return response.json();
  })
  .then(function (json) {
    console.log(2);
    console.log(json);
    return json;
  })
  .then(function (json) {
    console.log(3);
    console.log(
      json
        .filter((s) => s['시·도별(1)'] === '전국')
        .map((obj) => obj['1차 접종 퍼센트']),
    );
    return;
  });
```

```jsx
fetch(
  'https://raw.githubusercontent.com/paullabkorea/coronaVaccinationStatus/main/data/data.json',
)
  .then(function (response) {
    console.log(1);
    throw Error('애러났어유!');
    return response.json();
  })
  .then(function (json) {
    console.log(2);
    console.log(json);
    return json;
  })
  .then(function (json) {
    console.log(3);
    console.log(json.filter((s) => s['시·도별(1)'] === '전국'));
    return;
  })
  .catch((err) => alert(err));
```

## 4.2 쇼핑몰 구현하기

```jsx
fetch('http://test.api.weniv.co.kr/mall')
  .then((data) => data.json())
  .then((data) => console.log(data));

// 1. 추가 then을 사용하여 7개의 항목 productName만 출력해보세요.(console.log)
// 2. 추가 then을 사용하여 7개의 항목 중 price가 10000원 이상 되는 product를 출력하는 코드를 작성해주세요.(console.log)
// 3. 추가 then을 사용하여 7개의 항목의 productName과 price를 각각 h2와 p태그로 생성하여(DOM) 화면에 출력해주세요.
// 4. error 처리를 해주세요.

fetch('http://test.api.weniv.co.kr/mall')
  .then((productData) => productData.json())
  .then((productData) => productData)
  .then((productData) => {
    console.log(productData.map((item) => item.productName));
    return productData;
  })
  .then((productData) => {
    console.log(
      productData.map((item) => item.price).filter((item) => item >= 10000),
    );
    return productData;
  })
  .then((productData) => {
    const main = document.createElement('main');
    productData.forEach((item) => {
      const ProductCard = document.createElement('article');
      const productName = document.createElement('h2');
      const productPrice = document.createElement('p');

      productName.textContent = `상품명 : ${item.productName}`;
      productPrice.textContent = `가격 : ${item.price}`;

      ProductCard.appendChild(productName);
      ProductCard.appendChild(productPrice);

      main.appendChild(ProductCard);
    });
    document.body.appendChild(main);
  })
  .catch((error) => {
    alert('에러!');
    // error page로 리다이렉트
    console.log(error);
  });

// 5. 혹시 시간이 남으신 분들은 해당 코드를 뒤에서 배울 async, await으로 고쳐보세요!
async function getData() {
  const response = await fetch(`http://test.api.weniv.co.kr/mall`);
  const productData = await response.json();
  console.log(productData);
  console.log(productData.map((item) => item.productName));
  console.log(
    productData.map((item) => item.price).filter((item) => item > 10000),
  );

  const main = document.createElement('main');
  productData.forEach((item) => {
    const ProductCard = document.createElement('article');
    const productName = document.createElement('h2');
    const productPrice = document.createElement('p');

    productName.textContent = `상품명 : ${item.productName}`;
    productPrice.textContent = `가격 : ${item.price}`;

    ProductCard.appendChild(productName);
    ProductCard.appendChild(productPrice);

    main.appendChild(ProductCard);
  });
  document.body.appendChild(main);
}

getData();
```

# 5. async, await(에이씽크, 어웨잇)

- 일부 런타임에서는 async 없이도 await을 사용할 수 있습니다. 앞으로는 다른 런타임도 그렇게 될 것이고요. (top level await)

```jsx
async function f() {
  return '완료';
}

console.log(f);
console.log(f().then(alert));

// 완료가 된 다음 실행해보세요.
f();
```

```jsx
// 모던 자바스크립트 예제 (살짝 수정)
async function f() {
  return 100;
}

f()
  .then(function (result) {
    // (**)

    alert(result); // 1
    return result * 2;
  })
  .then(function (result) {
    // (***)

    alert(result); // 2
    return result * 2;
  })
  .then(function (result) {
    alert(result); // 4
    return result * 2;
  });
```

- await은 (크롬을 제외한 브라우저의 런타임) 일반 함수에서는 사용이 불가합니다. await은 프로미스 앞에서만 사용됩니다. 아래 코드를 실행하고 앞에 async키워드를 제거해보세요.

```jsx
// 모던 자바스크립트 예제
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('완료!'), 1000);
  });

  let result = await promise; // 프라미스가 이행될 때까지 기다림 (*)

  alert(result); // "완료!"
}

f();
```

- 이번에는 await을 제거해봅시다.

```jsx
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('완료!'), 1000);
  });

  let result = promise;
  console.log(result);
  alert(result);
}

f();
```

- 시간을 3초로 하여 어떤 결과가 나오는지 봅시다.

```jsx
// 모던 자바스크립트 예제 (살짝 수정)
async function f() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('완료!'), 3000);
  });

  let result = await promise; // 프라미스가 이행될 때까지 기다림 (*)

  alert(result); // "완료!"
  return 100;
}

f()
  .then(function (result) {
    // (**)

    alert(result); // 1
    return result * 2;
  })
  .then(function (result) {
    // (***)

    alert(result); // 2
    return result * 2;
  })
  .then(function (result) {
    alert(result); // 4
    return result * 2;
  });
```

- 프라미스 체이닝이 아닌경우

```jsx
// 프라미스 체이닝이 아닌 경우
let p = new p(function (resolve, reject) {
  setTimeout(() => resolve(10), 1000);
});

p.then((result) => {
  console.log(result);
  return result ** 2;
});

p.then((result) => {
  console.log(result);
  return result ** 2;
});

p.then((result) => {
  console.log(result);
  return result ** 2;
});
```

```jsx
// 모던 자바스크립트의 잘못된 예제 (https://ko.javascript.info/async-await)
// 보라님에게 제보해주세요.ㅎㅎ 시간이 지나면서 보완이 되어벼러서 잘못된 내용이 된 것입니다.

let response = await fetch(
  'https://raw.githubusercontent.com/paullabkorea/coronaVaccinationStatus/main/data/data.json',
);
let data = await response.json();
```

- 추가된 문법
  - top-level-await
    ```jsx
    // 해당 코드는 상위 async function이 없음에도 사용 가능합니다.
    const productData = await fetch('http://test.api.weniv.co.kr/mall').then(
      (data) => data.json(),
    );
    ```
  - for await (변수 of 프로미스배열) 문법
