---
chapter: promise, async, await
title: 실행 컨텍스트와 호출 스택
date: 2024-05-02
---

# 1. 실행 컨텍스트

:::div{.callout}
이해하기 어려운 부분입니다. 중요한 부분만 캐치하는 것을 권합니다.

🗝 **point** 🗝

1. 함수의 동작 순서를 알 수 있다.
2. setTimeout의 실행 시간을 보장하기 힘들다.(비동기 함수의 실행 순서를 알 수 있다.)
3. JavaScript는 싱글쓰레드이지만 브라우저는 멀티쓰레드이다. 백그라운드(Web APIs - DOM-document, AJAX-XMLHttpRequest, Timeout-setTimeout…)로 넘어가면 멀티로 작동한다.
   :::

- 실행 컨텍스트(Execution context) : 작성한 코드 실행 환경
  - variable 환경 - 외부 Scope의 주소 참조(최초 값), 컨텍스트 내부의 식별자 정보(최초 값)
  - lexical 환경 - 외부 Scope의 주소 참조(변경 값), 컨텍스트 내부의 식별자 정보(변경 값)
  - thisBinding - 컨텍스트가 바라보는 this
- 실행 컨텍스트 스택(stack) : 실행 코드를 추적 및 관리하기 위한 자료구조

## 1.1 코드의 종류와 그에 따른 생성 컨텍스트

- 전역 코드(global code) - 전역 실행 컨텍스트
- 함수 코드(function code) - 함수 실행 컨텍스트
- eval 코드(eval code) - eval 실행 컨텍스트
  ```jsx
  console.log(eval('2 + 2'));
  ```
- 모듈 코드(module code) - 모듈 실행 컨텍스트(모듈 내부에 함수가 있다면 함수 실행 컨텍스트)

:::div{.callout}
위 4가지 분류는 ECMAScript 분류에 따른 것입니다. (일부 책에서 모듈 코드 대신 블록 코드를 언급하고 있기에 공식 문서 기준으로 분류하였습니다.)

::a[ECMAScript® 2022 Language Specification]{class="btn-link" href="https://262.ecma-international.org/13.0/#sec-types-of-source-code" target="\_blank"}
![](/images/javascript/chapter14/02-1.png)
:::

## 1.2 코드의 실행

- 소스코드의 평가(변수, 함수 등을 컨텍스트 관리 스코프에 등록) → 소스코드의 실행
- 실행 예제

  1. (생성) 전역 실행 컨텍스트 생성
  2. (등록) x, y, z, sum를 먼저 전역 실행 컨텍스트에 등록(variable 환경, lexical 환경)
  3. (실행) x, y, z에 각각 값을 할당(lexical 환경 값 변경), sum을 호출
  4. (생성) sum의 함수 실행 컨텍스트 생성
  5. (등록) a, b를 함수 실행 컨텍스트에 등록(variable 환경, lexical 환경)
  6. (실행) a와 b에 각각 값을 할당(lexical 환경 값 변경), a+b+z를 연산하여 return 해야 하는데 z값이 내부 스코프에 없음 → 스코프 체인을 타고 올라가 z라는 변수가 상위에 있는지 확인하여 가져옴

     ![](/images/javascript/chapter14/02-2.png)

```jsx
function sum(a, b) {
  return a + b + z;
} // 스코프 체이닝 발생
let x;
let y;
let z;
x = 10;
y = 20;
z = 100;
console.log(sum(x, y));
```

## 1.3 렉시컬 환경

실행 컨텍스트(Execution context) : 코드의 실행 환경

렉시컬 환경(Lexical Environment) : 식별자 관리(스코프 관리, 값의 저장)

# 2. 호출스택

- js 코드

```jsx
function one() {
  two();
}
function two() {
  three();
}
function three() {
  console.log('end');
}
one();
```

- (호출 스택) 쌓이면서 하나씩 빠짐

```jsx
console.log('end');
three();
two();
one();
anonymous; // 가상 전역 컨텍스트, 이것도 마지막에 빠짐
```

- 그러면 아래 코드는?

```jsx
console.log(1);
setTimeout(function () {
  console.log(2);
}, 1000); // setTimeout(()=> console.log(2), 1000)
console.log(3);
```

---

::a[이벤트 루프 연습장 다운로드]{class='btn-link' href="/images/javascript/chapter15/eventloop-note.pptx" target="\_blank" download="이벤트루프 연습장"}

- 호출 스택(Call Stack)이 모두 끝나야 백그라운드 실행합니다. 중간에 실행되는 경우 없어요. 이 스택이 위에서 배운 실행 컨택스트 스택이며, 실행 컨택스트들이 쌓입니다. 여기서는 함수라고 읽으셔도 무리가 없습니다. 태스크 큐(Task Queue)는 콜백 큐(Callback Queue)라고도 부릅니다. 메모리는 메모리 힙(Memory Heap)이라고도 부릅니다.
- 이벤트 루프를 설명하는 영상은 매우 많고, 설명이 조금씩 다릅니다. 이유는 대부분이 복잡한 개념을 단순화 해서 설명하고 있기 때문이에요. 또한 항목도 지속해서 추가됩니다.
- 저는 'Node.js 교과서' 기준으로 설명으로 설명해드리도록 하겠습니다.

![이벤트 루프](/images/javascript/chapter14/02-3.png)

```jsx
console.log(1);
setTimeout(실행, 1000); // 핵심 : 1초를 보장하지 않는다!!
console.log(3);
function 실행() {
  console.log(2);
}
```

1. 메모리에 실행함수 적재
2. 호출스택에 anonymous(전역컨텍스트) 들어감
3. console.log(1)이 호출 스택에 쌓임
4. console.log(1)이 실행되어 console에 1을 찍고 스택에서 사라짐
5. 백그라운드에 timer(실행, 1) (계속 시간을 카운팅하는 중) - 비동기 코드가 여기 들어갑니다!
6. console.log(3)이 스택에 쌓임
7. console.log(3)이 실행되어 console에 3를 찍고 스택에서 사라짐
8. anonymous 사라짐
9. 1초가 지나가면 백그라운드에서 태스크 큐로 '실행' 함수를 가져옴(백그라운드에서 없어짐)
10. 태스크 큐에서 실행함수를 호출 스택으로 가져옴
11. '실행'함수 위에 console.log(2)가 쌓임
12. console.log(2)이 실행되어 console에 2를 찍고 스택에서 사라짐
13. '실행' 함수가 호출 스택에서 사라짐

::a[참고영상]{class="btn-link" href="https://www.notion.so/95d4666c69af49babd64c5badc78fe1f?pvs=21" target="\_blank"}
