---
chapter: 전개 구문과 디스트럭쳐링
title: 디스트럭쳐링
date: 2024-04-30
---

많은 분들이 헷갈려하는 악명높은 디스트럭쳐링입니다! 천천히 알아보도록 합시다

디스트럭쳐링은 ES6 부터 지원하는 문법으로, 배열이나 객체와 같은 데이터 구조를 분해하여 변수에 할당하는 표현식입니다. 이를 통해 변수에 속성이나 요소를 간편하게 할당할 수 있습니다. 구조 분해 할당이라 표현하기도 합니다.

> 쉽게 말하자면, 배열이나 객체를 **분해**하여 안에 있는 데이터를 변수에 순서대로 할당해주는 문법으로 이해하시면 되겠습니다!

:::div{.callout}
**‘destructuring’ 이라는 이름에 대하여 생각해봅시다.**  
*destructuring*이란 단어는 영어사전에 나오지 않습니다.
때문에 저는 초반에 이름에서 느껴지는 감이 없어서 문법 자체를 이해하기가 좀 어려웠는데요,

"de-"는 "제거하다"라는 뜻의 접두사이고, "structure"는 "구조"를 뜻합니다. 즉, "destructuring"은 "구조를 해체하는 행위"를 뜻하는 합성어입니다.

이렇듯 영어 구조적 특징을 통해 자바스크립트 문법을 해석해보는것도 학습에 도움이 됩니다
:::

ES6 이전에 사용했던 수동적인 디스트럭쳐링에 대해 살펴봅시다.

```jsx
let food1, food2, food3;

const categories = { food1: '과일', food2: '채소', food3: '육류' };

food1 = categories.food1;
food2 = categories.food2;
food3 = categories.food3;

console.log(food1, food2, food3);
```

위의 코드에서 우리는 객체안의 값을 하나 하나 빼내어 각각 별개의 변수에 할당하는 모습을 볼 수 있습니다.

할당하고자 하는 값에 해당하는 변수 선언이 필요하기 때문에, n개의 할당을 해주고자 하면 n줄의 코드 작성이 필요합니다.

위의 코드는 지금도 사용함에 있어서 문법적인 오류가 없는 코드입니다. 하지만 더 간결하고 빠르게 작성할 수 있는 구문으로 개선해봅시다.

## 2.1 디스트럭쳐링의 기본 구조

```jsx
let obj = { one: 1, two: 2 };
let myNum = obj.one;
console.log(myNum);
```

```jsx
let obj = { one: 1, two: 2 };
let { one: myNum } = obj;
console.log(myNum);
```

위의 코드와 아래 코드는 정확히 같은 결과를 콘솔에 출력합니다.

우리가 눈 여겨 봐야할 부분은 두 번째 코드의 디스트럭쳐링 부분( `{one: myNum}` )입니다.

어디서 많이 본 모습이 아닌가요? 생김새가 정확히 객체 리터럴과 동일합니다. 모습은 동일하지만 하는 일은 완전히 반대입니다. 객체 리터럴로서의 `{one: myNum}` 구문은 `one` 이 데이터의 이름을, `myNum` 이 데이터의 값을 나타낸다면, 디스트럭쳐링의 `{one: myNum}` 구문은 `myNum` 이 데이터의 이름을, `one` 이 데이터의 값을 나타냅니다.

비슷하게 생긴 모습 때문에 헷갈릴 수 있지만, 자바스크립트 엔진은 단순히 할당연산자( `=` ) 의 왼쪽에 있으면 디스트럭쳐링, 오른쪽에 있으면 객체 리터럴로 해석합니다.

```jsx
let { one: myNum } = { one: 1 };
// 왼쪽이 디스트럭쳐링, 오른쪽이 객체리터럴입니다.
console.log(myNum);
```

아직까지는 디스트럭쳐링이 왜 좋은지 잘 모르겠습니다.

이제 아래 코드를 보시면 디스트럭쳐링의 이름을 데이터 값의 이름과 동일하게 바꾼 모습을 볼 수 있습니다. 이렇게 이름을 동일하게 지어도 상관없습니다. 이제 데이터의 이름은 `myNum` 에서 `one` 으로 바뀌었습니다.

```jsx
let { one: one } = { one: 1 };
// 왼쪽이 디스트럭쳐링, 오른쪽이 객체리터럴입니다.
console.log(one);
```

그리고 디스트럭쳐링은 이름과 콜론을 생략할 수 있습니다. 그럼 최종적으로 아래와 같은 모습이 됩니다.

```jsx
let { one } = { one: 1 };
// 왼쪽이 디스트럭쳐링, 오른쪽이 객체리터럴입니다.
console.log(one);

let { one, two, three, four } = { one: 1 };
// 디스트럭쳐링은 콜론을 통해 변수를 추가적으로 생성할 수 있습니다.
console.log(one);
console.log(two);
console.log(three);
console.log(four);
```

자! 먼길을 오셨습니다. 이제 디스트럭쳐링을 통해 처음에 봤던 수동 디스트럭쳐링을 처리해보겠습니다.

```jsx
/**
let food1, food2, food3;

const categories = {food1 : '과일', food2 : '채소', food3 : '육류'};

food1 = categories.food1;
food2 = categories.food2;
food3 = categories.food3;
*/

const { food1, food2, food3 } = { food1: '과일', food2: '채소', food3: '육류' };

console.log(food1, food2, food3);
```

짠! 5줄의 코드가 단 한 줄로 끝나는 기적을 보셨습니다! 🪄

만약 객체를 반환하는 함수가 있을 경우, 함수의 반환값을 받는 변수를 굳이 만들 필요도 없습니다!

```jsx
const obj = { food1: '과일', food2: '채소', food3: '육류' };

function objReturn() {
  return obj;
}

// 반환값을 바로 디스트럭쳐링합니다.
const { food1, food2, food3 } = objReturn();

console.log(food1, food2, food3);
```

이렇듯 디스트럭쳐링을 이용하면 반복과 불필요한 변수 생성을 줄여 코드를 깔끔하게 작성할 수 있도록 도와줍니다.

## 2.2 배열의 디스트럭쳐링

지금까지는 객체의 디스트럭쳐링을 주로 살펴봤습니다.

배열의 디스트럭쳐링은 대괄호( `[ ]` )를 사용하여 할당할 변수 이름을 나열하는 방식입니다. 이를 통해 배열의 요소를 각각의 변수에 할당할 수 있습니다.

아래는 배열의 디스트럭쳐링을 사용한 예시입니다.

```jsx
const arr = [1, 2, 3];

const [a, b, c] = arr;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
```

위 코드에서는 arr이라는 배열을 선언하고, 구조 분해 할당을 사용하여 각각의 요소를 a, b, c 변수에 할당합니다. 이후 각 변수의 값이 출력됩니다.

## 2.3 함수의 디스트럭쳐링

함수의 디스트럭쳐링은 함수의 매개변수를 분해하여 변수에 할당하는 방법입니다. 이를 통해 함수에서 각각의 인수를 간편하게 사용할 수 있습니다.

아래는 함수의 구조 분해 할당을 사용한 예시입니다.

```jsx
function myFunc([a, b]) {
  console.log(a);
  console.log(b);
}

const arr = [1, 2];

myFunc(arr);
```

위 코드에서는 myFunc라는 함수를 선언하고, 디스트럭쳐링을 사용하여 함수의 매개변수를 변수 a, b에 할당합니다. 이후 전달인자로 [1, 2] 배열을 전달하여 함수를 호출합니다. 함수 안에서는 각 변수의 값이 출력됩니다.
