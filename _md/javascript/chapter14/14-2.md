---
chapter: 객체지향 프로그래밍
title: 객체지향 프로그래밍이란?
date: 2024-05-02
---

# 3. 프로토타입 (prototype)

자 그런데 문제가 하나 있습니다. 우리는 손쉽게 객체를 생산할 수 있지만, 객체의 메서드를 등록 할때마다 새로운 함수를 생성하고 있습니다.

```jsx
this.sayYourName = function () {
  console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
};
```

바로 이 부분이 문제입니다. 우리는 100개의 객체를 생성할때마다 역시 100개의 함수를 새로 만들고 있는것 입니다. 이러한 자원의 낭비를 해결하기 위해 등장한 것이 바로 프로토타입입니다.

```jsx
function NewFactory2(name) {
  this.name = name;
}

NewFactory2.prototype.sayYourName = function () {
  console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
};
```

**프로토타입이란 무엇인가?**

prototype은 특정 객체에 대한 참조입니다. 즉 어떠한 공간을 가리키고 있습니다.

생성자 함수가 인스턴스를 생성하게 되면 그 안에는 숨겨진 프로퍼티인 [[Prototype]] 이 존재하게 됩니다. 코드상에서는 `__proto__`로 표현됩니다. `__proto__` 프로퍼티는 자신을 만든 생성자 함수의 `prototype`을 참조하는 역할을 합니다. 즉, new 키워드를 통해 생성자 함수의 `prototype`과 인스턴스의 `__proto__` 가 연결됩니다.

```jsx
function Test() {}

const obj = new Test();

obj.__proto__ === Test.prototype;
```

:::div{.callout}
**잠시만요 … `prototype` 과 `__proto__` 는 다른건가요???**  
네 맞습니다. prototype은 오직 function안에 존재하는 참조값입니다. `__proto__` 는 객체 안에 존재하는 숨겨진 프로퍼티입니다. 인스턴스는 `__proto__`를 통해 생성자 함수의 `prototype`에 접근하여 필요한 여러가지 값과 메서드를 사용할 수 있습니다.

```jsx
function Test() {}

const obj = new Test();

console.log(obj.prototype); // undefined
console.log(obj.__proto__ === Test.prototype); // true
```

:::

이렇듯 프로토타입은 모든 인스턴스가 하나의 메서드를 공유하도록 만들어 자원을 더 효율적으로 사용하도록 도와줍니다. 생성된 객체끼리 메서드를 비교하여 같은 곳을 참조하는지 살펴보는것도 이해하는데 도움이 됩니다.

- 실습: 우리가 만들었던 음식 로봇객체의 메서드를 프로토타입으로 분리해보세요, 그리고 객체의 메서드가 서로 동일한 주소를 참조하는지 확인해보세요.

- 실습2: 우리가 객체지향 개념에서 만들었던 ‘나’ 와 ‘대상’ 객체를 생성자를 통해서 만들어 볼 수 있도록 코드를 수정해봅시다.

# 4. 객체의 상속

이미 CSS 에서 익숙하게 다루었던 상속이라는 개념은 자바스크립트에서도 존재합니다.

이번 시간에는 자바스크립트에서 상속이 어떤 식으로 일어나는지 알아보겠습니다.

자바스크립트의 상속은 기본적으로 prototype을 통해 일어납니다.

```jsx
const obj = {
  name: 'test',
};

console.log(obj.hasOwnProperty('name'));

const arr = [1, 2, 3];

console.log(arr.hasOwnProperty('name'));
```

배열 arr의 `__proto__` 가 Array함수의 `__proto__`를 참조하고, Array함수의 `__proto__` 가 Object 함수의 `__proto__` 를 참조하고 있기 때문에 Array의 `prototype`에 존재하지 않는 Object 객체의 프로퍼티와 메서드를 사용할 수 있습니다. 이처럼 자기 자신에게 존재하지 않는 프로퍼티나 메서드를 프로토타입을 통해 추적하는 과정을 **프로토타입 체이닝**이라고 합니다.

:::img{width="400px" alt="" src="/images/javascript/chapter14/01-2.png"}
:::img{width="400px" alt="" src="/images/javascript/chapter14/01-3.png"}

:::div{.callout}
자바스크립트의 타입들은 기본적으로 Object 타입을 상속받고 있습니다.

```jsx
console.log(Array.prototype.__proto__ === Object.prototype);
console.log(Number.prototype.__proto__ === Object.prototype);
console.log(String.prototype.__proto__ === Object.prototype);
console.log(Math.__proto__ === Object.prototype);
```

:::

이번에는 우리가 직접 생성한 생성자 함수를 통해 상속을 받도록 해보겠습니다.

먼저 부모의 역할을 할 생성자 함수를 만들고,

```jsx
function Parent() {
  this.name = '재현';
}
Parent.prototype.rename = function (name) {
  this.name = name;
};
Parent.prototype.sayName = function () {
  console.log(this.name);
};
```

자식 역할의 생성자 함수를 만듭니다.

```jsx
function Child() {
  Parent.call(this);
}

Child.prototype = Object.create(Parent.prototype); // 지정된 프로토타입 객체를 갖는 새 객체를 만듭니다.

Child.prototype.canWalk = function () {
  console.log('now i can walk!!');
};
```

위의 코드에서 call 함수는 Child 함수의 this가 Parent 생성자 함수의 this를 바라보게 만듭니다. 즉, Child 를 통해 생성된 인스턴스의 this 가 Parent 함수안의 프로퍼티에 접근할 수 있게합니다.

그리고 Object.create 함수는 주어진 인자를 Child.prototype에 연결하는 역할을 합니다. 즉 Parent 객체의 프로토타입을 Child 객체의 프로토타입이 참조하게 합니다.

위의 두 가지 과정을 통해 Child 객체는 Parent 객체의 모든 것을 상속받게 됩니다.

이렇게 prototype을 이용해 메소드를 인스턴스들이 공유하도록 하여 메모리 공간을 절약할 수 있었습니다.

그렇다면 이 코드의 단점은 무엇일까요?

1. 객체 안에 존재하던 메소드가 prototype 이라는 키워드와 함께 외부로 빠져나왔습니다. 이제 코드가 별로 아름답지 못해보입니다. 중괄호 안에 모든것이 옹기종기 모여있던 객체의 모습과 거리가 멀어졌습니다.
2. 보편적인 객체지향 코드의 모습과 차이가 있습니다. 그 이유는 바로 자바스크립트가 무엇인지 잘 모르는 다른 언어의 프로그래머들입니다. 이들은 prototype이 뭔지 모릅니다! 심지어 prototype은 보통 함수에서는 의미가 없습니다! 오직 생성자 함수에서만 의미를 가지기 때문입니다. C++나 자바 혹은 파이썬을 전공한 프로그래머들에게 객체지향적으로 작성한 자바스크립트 코드를 보여주면 분명 멘붕에 빠질겁니다. 우선 class라는 키워드는 온데간데 없고 수상한 prototype 이라는 키워드만 잔뜩 보일테니까요.
