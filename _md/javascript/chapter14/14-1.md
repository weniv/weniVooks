---
chapter: 객체지향 프로그래밍
title: 객체지향 프로그래밍이란?
date: 2024-05-02
---

# 1. 객체지향 프로그래밍이란 무엇일까?

객체지향은 프로그래밍 방법론중에 하나로, 프로그램을 작성할 때 객체들을 만들어 서로 소통하도록하는 방법이라고 할 수 있습니다.

그렇다면 여기서 말하는 객체란 무엇일까요?

우리가 앞서서 배운 **자바스크립트 객체**가 키,값 쌍으로 이루어진 데이터의 묶음이라면, **객체 지향의 객체**는 우리가 표현하고자 하는 구체적인 사물을 **추상적**으로 표현한것 이라고 볼 수 있습니다.

:::figure
::img{width="600" alt="추상화된 황소" src="/images/javascript/chapter14/01-1.png"}
::figcaption[이 그림은 무엇을 표현한 것일까요?]
:::

:::div{.callout}
**피카소의 추상화 과정**
![](/images/javascript/chapter14/01-4.png)
:::

즉 추상화란 필요한 최소한의 정보로 대상을 표현하는것을 의미합니다.

만약 저를 추상적인 객체로 표현한다면, 즉 저를 객체로 표현한다면

```jsx
const me = {
  name: '한재현',
  address: '제주도 제주시 인다 1길',
  phoneNum: '010-8000-0000',
  canWalk: function () {
    console.log('재현이가 걷는다.');
  },
};
```

이렇게 표현할 수 있습니다.

그리고 또한 객체는 행동과 상태를 가집니다. 여기서 행동은 메소드, 상태는 프로퍼티 정도로 이해하시면 됩니다.

자자 그럼 저에게 새로운 능력을 부여해봅니다.

```jsx
const me = {
  name: '한재현',
  address: '제주도 제주시 인다 1길',
  phoneNum: '010-8000-0000',
  canWalk: function () {
    console.log('재현이가 걷는다.');
  },
  teaching: function (student) {
    student.levelUp();
  },
};
```

그리고 새로운 객체를 만들어봅니다.

```jsx
const lion = {
  level: 1,
  levelUp: function () {
    this.level++;
  },
};
```

이제 능력을 발휘해 보겠습니다!

```jsx
me.teaching(lion);
```

이처럼 객체와 객체가 서로 메소드를 통해 상호작용하게 하는것이 바로 **객체지향 프로그래밍**이라고 할 수 있습니다.

- 실습 : 여러분 자신을 추상화 해봅시다. 그리고 상호작용 하고 싶은 대상을 만들어보고 서로 상호 작용 할 수 있는 메소드를 만들어 봅시다.

자 이제 여러분들은 객체를 통한 추상화를 배워봤습니다. 하지만 문제가 있습니다. 우리가 만들어낸 객체는 한번 생성하고 나면 끝입니다. 좀 더 효율적인 방법으로 객체를 만들어 보겠습니다.

# 2. **생성자 (constructor)**

**생성자란** 객체를 만들 때 new 연산자와 함께 사용하는 함수입니다.

우리는 이미 사용해본 생성자가 있습니다.

```jsx
let myArr = new Array(1, 2, 3);
```

이러한 생성자를 내장 생성자라고 합니다.

## 2.1 **우리는 왜 생성자를 사용할까요?**

생성자의 장점은 생성자를 통해 생성된 객체는 같은 **프로퍼티**와 **메서드**를 공유할 수 있다는 것입니다.

```jsx
let myArr = new Array(1, 2, 3);
let myArr2 = new Array(4, 5, 6);

myArr2.length;
myArr.length;

myArr.forEach((item) => {
  console.log(item);
});

myArr2.forEach((item) => {
  console.log(item);
});
```

생성자의 장점. 조금 이해가 가시나요? 자 그럼 우리만의 생성자를 만들어 볼 수도 있습니다.

## 2.2 커스텀 **생성자 만들어보기**

생성자는 함수이기 때문에 기본적으로 함수가 필요합니다. 생성자 함수는 암묵적으로 대문자로 시작하는 이름을 가지는 것으로 약속되어 있습니다.

```jsx
function Factory() {}
```

그리고 new 키워드를 통해 객체를 생성합니다.

```jsx
function Factory() {}
let robot1 = new Factory();
```

Factory 생성자 함수는 따로 return 값을 가지지 않지만 new키워드가 앞에 붙게되면 실행되었을 때 자동적으로 객체를 생성하고 반환합니다. 이렇게 반환되어 만들어진 객체를 다른 말로 **인스턴스(instance)** 라고 합니다.

때문에 **생성자 함수와 객체의 관계는 instanceof 로 확인** 할 수 있습니다.

```jsx
robot1 instanceof Factory;
```

자 그러면 이제 우리만의 프로퍼티와 메서드를 가진 로봇 객체를 만들어 봅시다.

```jsx
function NewFactory(name) {
  this.name = name;
  this.sayYourName = function () {
    console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
  };
}
```

원래 함수안에서의 this는 함수를 호출한 객체를 참조합니다. 하지만 생성자 함수 앞에 new 연산자가 사용되면 함수안의 this는 생성자가 만들어낸 객체 즉, 인스턴스를 참조합니다.

자 이제 객체 즉, 인스턴스를 생성해 봅시다.

```jsx
let robot1 = new NewFactory('브랜든');
```

우리가 만든 robot1 이 정상적으로 가동되는지 확인해 봅시다.

- 실습 : 음식 이름의 배열을 전달하면 배열안에서 랜덤하게 메뉴를 뽑아내는 로봇객체의 생성자를 만들어보세요.

이렇듯 우리가 필요에 따라서 배열(Array), 객체(Object)를 사용하는 것 처럼, 우리가 필요할 때 사용할 수 있는 우리만의 객체를 만들어서 사용할 수 있도록 도와주는 것이 바로 생성자입니다.
