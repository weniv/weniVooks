---
chapter: 변수
title: 변수 특징
date: 2024-05-21
---

# 2. 변수 키워드와 특징

|        | var | let | const |
| ------ | --- | --- | ----- |
| 재선언 | O   | X   | X     |
| 재할당 | O   | O   | X     |

```jsx
// 변수의 키워드를 생략하고 선언과 할당을 하면 오류가 발생하지 않습니다.
valueA = 10;
console.log(valueA);
```

→ 엄격모드(strict mode)에서는 오류가 발생됨으로 권장되지 않습니다.

```jsx
// 엄격모드
'use strict';

valueA = 10;
console.log(valueA);
```

```jsx
// 재선언
var valueB = 20;
var valueB = 30;

let valueC = 10;
let valueC = 20; // 재선언 오류 발생
```

```jsx
// 재할당
var valueVar = 15;
valueVar = 25;

let valueLet = 20;
valueLet = 30;

const valueLet = 5;
valueLet = 10; // 재할당 오류 발생
```

<aside>
💡 **어떤 키워드를 사용해서 선언해야 할까요?**

`var` 키워드는 변수의 재선언이 가능하기 때문에 예기치 못한 오류가 발생할 수 있습니다.
따라서 코드의 가독성과 유지보수성을 높이기 위해 let과 const를 사용하는 것이 좋습니다.

let과 const 키워드는 서로 다른 용도를 가지고 있습니다. 그러나 const를 사용하는 것이 더 좋은 경우가 많습니다.

1. **의도하지 않은 값의 변경을 방지**
   변수의 값이 한 번 할당되면 변경할 수 없습니다. 따라서 의도하지 않은 값의 변경을 방지할 수 있어, 코드의 예측 가능성을 높이며 버그를 줄일 수 있습니다.
2. **가독성 향상**
다른 개발자들이 변수의 값이 변경될 가능성이 없다는 것을 빠르게 인지할 수 있으며 선언을 할 때 초기화를 함께 해야하기 때문에 어떤 데이터가 사용되는지 확인하기 용이합니다. 이런 const의 특성은 코드의 가독성을 높이고 유지보수성을 향상시킵니다.
</aside>

## 2.1. 메모리 저장 방식

변수를 선언하면 값 뿐만 아니라 변수의 이름도 메모리에 저장됩니다. 다시 말해 변수의 이름과 할당된 값이 메모리에 각각 저장이 됩니다.

```jsx
var a;
let b = 10;
const name = 'weniv';
```

![Untitled](/images/javascript/chapter02/Untitled.png)

```jsx
a = 30;
b = 20;
```

![Untitled](/images/javascript/chapter02/Untitled%201.png)

<aside>
💡 **매니지드 언어**

자바스크립트는 메모리 할당과 해제를 언어 자체에서 자동으로 관리하는 매니지드 언어입니다. 따라서 개발자가 직접 메모리 주소에 접근하거나 조작할 필요가 없습니다.

이미지에서 사용된 메모리 주소나 주소 표기법(@)은 이해를 돕기 위한 방식으로 실제 자바스크립트에서는 메모리 주소와 표기법에 대한 내용을 제공하지 않습니다.

</aside>

<aside>
💡 **가비지 컬렉터**

매니지드 언어인 자바스크립트 특성 상 사용자가 직접 메모리 해제가 불가능합니다. 사용되지 않는 메모리를 관리하기 위하여 가비지 컬렉터를 내장합니다.

가비지 컬렉터는 메모리 공간을 검사하여 사용되지 않는 메모리를 해제하여 메모리 누수를 방지합니다.

</aside>

## 2.2. 스코프 (scope)

스코프란 변수의 접근성과 생존 기간을 제어하는 **‘생존 범위’**를 의미합니다. 변수 선언에 사용하는 키워드별로 각각 다른 스코프를 갖습니다.

1. **전역 스코프**: 어디서든 접근 가능한 변수 영역
2. **함수 스코프**: 함수 내에서만 접근 가능한 변수 영역, var로 선언한 변수는 함수 스코프를 갖습니다.

   ```jsx
   var a = 10;
   let b = 20;
   const c = 30;

   function funcScope() {
     console.log('----- Function Scope ------');
     console.log('전역변수: ', a, b, c);
     var fA = 40;
     let fB = 50;
     const fC = 60;
     console.log('함수 내부: ', fA, fB, fC);
   }
   funcScope();
   // console.log("함수 변수", fA, fB, fC);
   ```

3. **블록 스코프**: 중괄호로 감싸진 코드 블록 단위로 접근 가능한 변수 영역을 나타냅니다. let과 const로 선언한 변수는 블록 스코프를 갖습니다.

   ```jsx
   {
     console.log('----- Block Scope ------');
     console.log('전역변수: ', a, b, c);

     var bA = 70; // 함수 스코프이기 때문에 전역 변수가 됩니다.
     let bB = 80;
     const bC = 90;
     console.log('블록 내부: ', bA, bB, bC);
   }
   console.log('블록 변수: ', bA, bB, bC);
   ```
