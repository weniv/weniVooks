---
chapter: 변수
title: var, let, const
date: 2024-04-30
---

|        | var | let | const |
| ------ | --- | --- | ----- |
| 재선언 | O   | X   | X     |
| 재할당 | O   | O   | X     |

:::div{.callout}
**어떤 키워드를 사용해서 선언해야 할까요?**

`var` 키워드는 변수의 재선언이 가능하기 때문에 예기치 못한 오류가 발생할 수 있습니다.
따라서 코드의 가독성과 유지보수성을 높이기 위해 let과 const를 사용하는 것이 좋습니다.

let과 const 키워드는 서로 다른 용도를 가지고 있습니다. 그러나 const를 사용하는 것이 더 좋은 경우가 많습니다.

1. **의도하지 않은 값의 변경을 방지**  
   변수의 값이 한 번 할당되면 변경할 수 없습니다. 따라서 의도하지 않은 값의 변경을 방지할 수 있어, 코드의 예측 가능성을 높이며 버그를 줄일 수 있습니다.
2. **가독성 향상**  
   다른 개발자들이 변수의 값이 변경될 가능성이 없다는 것을 빠르게 인지할 수 있으며 선언을 할 때 초기화를 함께 해야하기 때문에 어떤 데이터가 사용되는지 확인하기 용이합니다. 이런 const의 특성은 코드의 가독성을 높이고 유지보수성을 향상시킵니다.
   :::

# 1. 스코프 (scope)

변수, 함수, 객체 등의 식별자가 유효한 범위를 뜻합니다. 변수를 선언한 키워드에 따라서 스코프가 결정됩니다.

## 전역 스코프 (global scope)

코드의 가장 바깥 영역에 선언된 변수나 함수는 전역 스코프를 갖습니다. 코드 어느 곳에서나 접근할 수 있으며, 브라우저 환경에서는 window 객체가 전역 스코프를 나타냅니다. 프로그램의 어느 부분에서나 접근 및 수정이 가능하기 때문에 코드의 유지보수성을 떨어뜨릴 수 있습니다.

```jsx
var greeting = 'Hello';

function sayHello(name) {
  console.log(`${greeting}, ${name}!`);
}

function sayHi(name) {
  greeting = 'Hi';
  sayHello(name);
}

console.log(greeting);
sayHi('weniv');
sayHello('licat');
```

## 함수 스코프 (function scope)

함수 내부에서 `var` 키워드로 선언된 변수나 함수는 해당 함수 스코프에 포함됩니다. 함수 스코프 내에서 선언된 변수는 함수 내부에서만 접근 가능하며, 함수 외부에서는 접근할 수 없습니다.

```jsx
function outerFunc() {
  var info = 'outerFunc';

  function innerFunc() {
    console.log('innerFunc');
  }

  console.log(info);
  innerFunc();
}

outerFunc();
console.log(info); // ReferenceError
innerFunc(); // ReferenceError
```

## 블록 스코프 (block scope)

자바스크립트 문법에는 여러 줄의 코드를 하나로 묶어주는 단위인 블록(`{}`)이 존재합니다. let과 const를 사용하면 중괄호로 묶인 코드 블록 내부에서만 유효한 변수를 선언할 수 있습니다.

```jsx
if (true) {
  let greeting = 'Hello';
  const name = 'Weniv';

  console.log(`${greeting}, ${name}`);
}

console.log(greeting); // ReferenceError
console.log(name); // ReferenceError

for (let i = 0; i < 10; i++) {
  console.log(i);
}
console.log(i); // ReferenceError
```

# 2. 호이스팅 (hoisting)

**‘hoist’** 는 끌어올리다는 뜻을 가지고 있습니다. 자바스크립트에서 변수와 함수의 선언이 해당 스코프의 맨 위에 끌어올려지는 것처럼 동작하는 현상을 ‘호이스팅’이라고 합니다.

아래 코드에서 어떤 값이 출력될 지 예측해봅시다.

```jsx
console.log(a);
var a = 10;
```

결과를 확인해보면 ReferenceError도, 변수에 할당된 10도 아닌 undefined가 출력되는 것을 확인할 수 있습니다. 이 현상이 발생하는 이유는 바로 ‘호이스팅’이 일어났기 때문입니다.

## var

변수의 선언문은 다음과 같이 선언문(`var a`)과 초기화문(`a = 10`;)으로 나눠서 표현할 수 있습니다. 이 중 선언문이 스코프의 맨위로 끌어 올려지는 것처럼 동작하게 됩니다.

즉 다음과 같이 선언문이 스코프의 최상단으로 끌어올려지게 되고, var 키워드를 사용하는 경우에는 undefined로 초기화되어, `console.log(a)`에서 undefined가 출력되게 됩니다.

```jsx
var a; // undefined로 초기화
console.log(a);

a = 10;
```

## let, const

```jsx
console.log(b);
console.log(c);

let b = 20;
const c = 30;
```

```jsx
let b;
const c;

console.log(b);
console.log(c);

b = 20;
c = 30;
```

let과 const 키워드를 사용하는 경우에도 호이스팅이 발생합니다. 하지만 변수에 값이 할당되기 전까지 어떤 값도 할당되지 않습니다. 따라서 스코프의 최상단부터 초기화문까지 변수를 사용하면 초기화되지 않은 값에 접근이 불가하다는 오류가 발생하게 됩니다. 이를 **일시적 사각지대 TDZ(Temporal Dead Zone)** 이라고 이야기합니다.
