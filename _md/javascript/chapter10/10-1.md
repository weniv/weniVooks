---
chapter: 함수2 - 함수 심화
title: 함수 심화
date: 2024-05-02
---

# 1. 구조분해할당을 이용한 아규먼트 처리

구조분해 할당을 통해 함수에 전달하는 인자의 기본값을 지정할 수 있습니다.

```jsx
function printMe({ name, age, email } = {}) {
  console.log(`이름: ${name}, 나이: ${age}, 이메일: ${email}`);
}

const me = {
  name: '재현',
  age: 25,
  email: 'jaehyun@something.com',
};

printMe(me);
```

:::div{.callout}
위의 코드에서 매개변수에 빈 객체를 할당하고 있습니다. 없어도 잘 동작하지만, 만약 할당하지 않는다면, printMe 함수에 인자를 넘기지 않고 실행했을 때 에러가 발생하게 됩니다. 인자 없이 실행할 경우를 가정한다면 빈 객체를 할당해 안전하게 예외 처리하도록 합시다 🙂
:::

- **함수에서 객체를 인자로 전달받는 방법**

```jsx
// https://www.freecodecamp.org/news/elegant-patterns-in-modern-javascript-roro-be01e7669cbd/
// 개선할 여지가 있는 예제
function 함수4(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부){ // 회원 등급 권한
    console.log('함수기능')
    return
}

함수4('Gold', true, true, true, '대화방 전체 백업 가능', true) // 가독성이 떨어진다.

function 함수4({
        회원등급,
        글쓰기,
        글읽기,
        채널관리,
        백업,
        소셜로그인여부
    }){
    console.log('함수기능')
    console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부)
    return
}

함수4({
    회원등급: "Gold",
    글쓰기: true,
    글읽기: true,
    채널관리: false,
    백업: "부분가능",
    소셜로그인여부: true
})

///////입력되지 않은 값은 undefined///////

function 함수4({
        회원등급,
        글쓰기,
        글읽기,
        채널관리,
        백업,
        소셜로그인여부
    }){
    console.log('함수기능')
    console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부)
    return
}

함수4({
    회원등급: "Gold",
    채널관리: false,
    백업: "부분가능",
    소셜로그인여부: true
})

///////초깃값 설정1///////

function 함수4({
    회원등급 = 'Gold',
    글쓰기 = true,
    글읽기 = true,
    채널관리 = true,
    백업 = '부분가능',
    소셜로그인여부 = true
    }){
    console.log('함수기능')
    console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부)
}

함수4({
    회원등급 : 'Silver',
    소셜로그인여부: true
})

///////초깃값 설정2///////
// 참고삼아서만 보세요.
let one
let two
let three
{one, two, three}

let {one, two, three} = {one: 10, two: 100, three: 200} // 작동
let {one:30, two, three} = {one: 10, two: 100, three: 200} // Error

    // 함수에서 받는 부분      // 아규먼트를 전달해주는 부분
let {one = 30, two, three} = {one: 10, two: 100, three: 200} // 등호가 된다는 원리가 이 이유입니다.

function 함수4({
    회원등급: 'Gold', // 안되는 이유?
    글쓰기,
    글읽기,
    채널관리,
    백업,
    소셜로그인여부
    }){
    console.log('함수기능')
    console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부)
    return
}

함수4({
    회원등급 : 'Silver',
    소셜로그인여부: true
})

////// 아규먼트 없이 호출 가능 //////
function 함수({
        a = 2,
        b = 1,
        c = 3
    } = {}) {
    console.log(a, b, c);
    return a + b + c;
}
console.log(함수({a: 20, b: 30, c: 10}));
함수() // 아규먼트 없이 호출 가능

// 설명
// O
function 함수(a=10, b=20, c=30){
    return a + b + c
}
함수()

// X
function 함수({a=10, b=20, c=30}){
    return a + b + c
}
함수()

// O
function 함수({a=10, b=20, c=30}){
    return a + b + c
}
함수({}) // 이 코드를 축소한 코드가 위의 코드입니다.

// 함수에서 받는 부분         // 아규먼트를 전달해주는 부분
// let {one = 1, two = 2} = {one:100}
// let {one = 1, two = 2} = {}  // 이 방식이 간소화된 것입니다.
// let {a=10, b=20, c=30} = undefined
```

# 2. **rest 문법**

함수의 매개변수에 `...`를 붙이면 사용자가 제공한 모든 매개변수를 배열안에 넣도록 지정합니다. 이를 `나머지(rest) 매개변수`라 합니다.

rest 문법을 이용할 때 주의해야할 점은

1. 매개변수에는 하나의 `rest`만 존재할 수 있습니다.
2. `rest`는 반드시 함수 정의의 마지막 매개변수여야 합니다.

아래 코드에서는 rest 문법을 이용해 매개변수를 선언했습니다.

```jsx
function 함수2(a, b, ...c) {
  console.log(c);
  return Math.max(...c);
}

함수2('hello', 'world', 10, 20, 30, 40);

function 함수2([a, b], ...c) {
  console.log(a);
  console.log(b);
  console.log(c);
}

함수2([1, 2], 10, 20, 30, 40);
```

:::div{.callout}
rest 문법이 spread 문법과 비슷해보여요!  
맞습니다. 두 문법은 똑같이 생겼는데요! 사용하는 위치에 따라 spread와 rest로 나누어집니다.  
자바스크립트 엔진은 일반적인 객체나 배열안에서 사용되는 `…` 은 spread, 함수의 마지막 매개변수에 사용되는 `…` 은 rest 문법으로 인식합니다.
:::

# 3. 매개변수의 초기화

함수의 매개변수는 선언만 할 수도 있지만, 선언과 동시에 값을 할당하여 초기화도 가능합니다.

매개변수의 초기화는 기본적으로 왼쪽에서 오른쪽의 순서로 설정됩니다.

```jsx
function 함수3(a = 10, b = 20, c = 30) {
  return a + b + c;
}

console.log(함수3());
console.log(함수3(100));
console.log(함수3(100, 200));
console.log(함수3(100, 200, 300));

console.log(함수3((c = 1000))); // 1030이 되어야 하는거 아니에요?
// 1050

console.log(함수3((c = 1000), (a = 2000))); // 3020이 되어야 하는거 아니에요?
// 3030

// 값이 순서대로 들어갔습니다.
```

# 4. 자바스크립트 Scope

스코프란 변수의 접근성과 생존 기간을 제어하는 ‘생존 범위’를 의미합니다.

```jsx
const func1 = function () {
  var a = 1;
  var b = 2;

  console.log(a + b);
};

var a = 20;

func1();
```

위의 코드에서는 `var` 키워드를 이용해서 전역변수를 선언해 봤습니다.

변수 a는 어디서든 접근 가능한 전역 변수임에도 불구하고 함수안의 a 와 함수 밖의 a는 완전히 별개의 변수임을 알 수 있습니다.

그리고 함수안의 a변수는 함수가 종료면 함스 스코프가 가비지 컬랙션으로 수거되기 때문에, 메모리상에서 자동으로 제거됩니다.

이렇듯 스코프는 이름이 충돌하는 문제를 덜어주고, 자동으로 메모리를 관리합니다.

**스코프의 종류**

1. 전역 스코프
   - 스크립트의 어디서든 접근이 가능하기 때문에 사용이 쉽습니다.
   - 타인과의 협업, 라이브러리 사용시 충돌의 가능성이 있습니다.
2. 함수 스코프
   - 함수 내부에서 정의된 변수와 매개변수는 함수 외부에서 접근할 수 없습니다.
   - 함수 내부에서 정의된 변수라면 함수의 어느 부분에서도 접근 할 수 있습니다.
3. 블록 스코프 (ES6)
   - 중괄호 안에서만 접근 가능합니다.
   - 블록 내부에 정의된 변수는 블록의 실행이 끝나면 해제됩니다.

```jsx
let z = 100;
function sum(x) {
  // x는 매개변수(parameter)이면서 지역변수(local val)
  let y = 50; // y는 지역변수
  z = z + y;
  return x + y;
}
console.log(sum(10)); // 10은 전달인자(argument)
console.log(x);
console.log(y);
console.log(z);
// 키워드로 인해 전역, 지역이 갈리는 것은 아닌지, let, var, const 모두 테스트 해보세요.
```

```jsx
// 블록 레벨 스코프
if (true) {
  // for문이어도 마찬가지입니다.
  let x = 10;
  const y = 10;
}
console.log(x, y);

// 밖에 선언된 x는 함수 내부에서도 접근 가능합니다.
let x = 100;
function xplus() {
  x = x + 10;
}

xplus();
console.log(x);

// 함수가 종료된 다음에는 선언된 변수는 휘발됩니다.
function xplus() {
  let a = 100;
  a = a + 10;
}

xplus();
console.log(a); // Error

// 함수 안에 함수
function a() {
  console.log('a 실행');
  function b() {
    console.log('b 실행');
  }
  b();
}

a();
b(); // Error
```

블록레벨 스코프를 연습하기 위해 아래 예제의 실행 결과를 예측해보세요.

```jsx
let a = 10;

function outer() {
  let b = 20;

  function inner() {
    let c = 30;
    console.log(a, b, c);
  }

  inner();
  console.log(a, b);
}

outer();
console.log(a);
```

# 5. 콜백함수

콜백함수란 함수에 매개변수로 전달되어 실행되는 함수를 의미합니다.

```jsx
function sum(x, y, 콜백함수) {
  콜백함수(x + y);
  return x + y;
}

function documentWriter(s) {
  document.write('콜백함수', s);
}

sum(10, 20, documentWriter);

// map 의 사용을 통한 콜백함수
let arr = [1, 2, 3, 4, 5];
arr.map(제곱);

function 제곱(x) {
  return x ** 2;
}

arr.map((x) => x ** 2);

//  forEach의 사용을 통한 콜백함수
let arr = [1, 2, 3, 4, 5];
arr.forEach((e) => console.log(e ** 2));

function 제곱(x) {
  console.log(x ** 2);
}
```

:::div{.callout}
**first class 언어**  
JavaScript에서는 함수를 변수에 할당할 수 있습니다. 이러한 함수를 변수에 할당한 후, 해당 변수를 매개변수로 다른 함수에 전달하거나, 다른 함수의 반환값으로 사용할 수 있습니다. 이렇게 하면 함수를 조합하여 더 복잡한 기능을 수행할 수 있습니다. 이러한 기능을 지원하는 언어를 first class 언어라고 하며 Python, Ruby등이 이러한 언어군에 속합니다.
:::

# 6. 함수의 호이스팅(Hoisting)

:::figure
::img{width="400" alt="" src="/images/javascript/chapter10/01-1.png"}
::figcaption[이렇게 무언가를 끌어올리는 장치를 영어로 호이스트(hoist)라고 합니다.]
:::

호이스팅(한국어로 번역하면 ‘끌어 올리기’)은 변수나 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 현상을 말합니다. 즉, 코드에서 변수나 함수를 선언하기 전에 해당 변수나 함수를 사용할 수 있는 것처럼 보이는 현상을 의미합니다.

```jsx
console.log(x);
console.log(y);
console.log(z);
var x = 1;
let y = 2;
const z = 3;

sayHi(); // "Hello, lions!"
function sayHi() {
  console.log('Hello, lions!');
}
```

위의 코드에는 변수 선언문과 함수 선언문이 정의되어 있습니다. 그리고 해당 변수와 함수를 선언하기 전에 각각 참조하고 있습니다. 하지만 실행 결과에서는 변수 x는 `undefined`로, 함수 sayHi는 "Hello, lions!"를 출력하게 됩니다. 이것은 호이스팅에 의해 변수와 함수가 해당 스코프의 최상단으로 끌어올려졌기 때문입니다.

하지만, 호이스팅은 변수의 선언만을 끌어올리고, 변수의 초기화나 할당은 끌어올려지지 않습니다. 따라서 변수의 값을 초기화하기 전에 참조하면 `undefined`가 반환되는 것입니다.

따라서 함수 표현식은 변수 선언만을 끌어올리기 때문에 함수를 선언하기 전에 함수를 호출하면 에러가 발생합니다. 이와 반대로 함수 선언문은 전체를 끌어올리기 때문에 위의 코드처럼 함수를 선언하기 전에 함수를 호출할 수 있습니다.

비교적 최근에 등장한 let, const, class를 이용한 선언문은 일시적 사각지대(Temporal Dead Zone)라는것을 만들어서 호이스팅이 되었지만 안된 것처럼 동작하게 합니다. 그 이유는 호이스팅은 개발자가 의도하지 않은 결과를 만들기 때문에, 코드의 가독성과 유지보수성을 해치므로, 호이스팅이 발생하지 않도록 하기 위해서입니다.

:::div{.callout}
**Temporal Dead Zone(TDZ)이란?**

코드상에 let, const로 선언된 변수와 상수는 **TDZ**(**T**emporal **D**ead **Z**one. 임시 접근 불가구역) 구역에 배치됩니다. 이 값들은 선언에 대한 초기화가 실행된 후에 TDZ에서 제거되어 사용 가능한 상태가 됩니다. TDZ는 말 그대로 접근이 불가능하기 때문에, 초기화 전에 TDZ에 배치된 변수에 접근하려고 하면 에러를 발생시키게 됩니다.
:::

# 7. 재귀함수

재귀함수(Recursive function)는 함수가 자기 자신을 호출하는 것을 말합니다.

1. 재귀함수는 무한히 반복될 수 있기 때문에 보통 재귀 호출이 멈출 수 있는 종료조건을 체크해야합니다.
2. 반복문으로 구현할 수 있는 것은 재귀함수로 모두 구현 가능합니다. 그 반대로 재귀함수로 구현 가능한 것은 반복문으로 대부분 구현(복잡도를 증가시키면 모두) 가능합니다.

```jsx
// 팩토리얼은 1부터 n까지의 곱을 구하는 함수를 의미합니다.
function factorial(n) {
  if (n <= 1) {
    return n;
  }
  return n * factorial(n - 1);
}

// factorial(5) == 5 * factorial(4) == 5 * 24
// factorial(4) == 4 * factorial(3) == 4 * 6
// factorial(3) == 3 * factorial(2) == 3 * 2
// factorial(2) == 2 * factorial(1) == 2 * 1
// factorial(1) == 1
```

```jsx
// sigma는 1부터 n까지의 합을 계산하는 함수를 의미합니다.
function sigma(n) {
  if (n <= 1) {
    return n;
  }
  return n + sigma(n - 1);
}

// sigma(5) == 5 + sigma(4) == 5 + 10
// sigma(4) == 4 + sigma(3) == 4 + 6
// sigma(3) == 3 + sigma(2) == 3 + 3
// sigma(2) == 2 + sigma(1) == 2 + 1
// sigma(1) == 1
```

```jsx
function reverse(text) {
  if (text.length <= 1) {
    return text;
  }
  return reverse(text.slice(1)) + text[0];
}

// reverse('hello') == reverse('ello') + 'h' == 'olle' + 'h'
// reverse('ello') == reverse('llo') + 'e' == 'oll' + 'e'
// reverse('llo') == reverse('lo') + 'l' == 'ol' + 'l'
// reverse('lo') == reverse('o') + 'l' == 'o' + 'l'
// reverse('o') == 'o'
```

# 8. 즉시 실행함수

1. 앞에서 잠시 다뤘었죠? 즉시 실행하고 외부에서 컨트롤 할 필요가 없는 함수입니다.
2. function scope를 이용하기 때문에 메모리 효율적입니다.

```jsx
// 익명 즉시 실행 함수
(function () {
  let a = 1;
  let b = 2;
  return a + b;
})();

// 기명 즉시 실행 함수
(function foo() {
  let a = 3;
  let b = 5;
  return a * b;
})();

foo(); // ReferenceError: foo is not defined
// 어차피 실행하지 못해서 의미가 없음.
// 메모리 효율적으로 관리하기 위해 바로 실행해야 하는 것들을 즉시 실행함수로 관리
```

- 연습문제(배운것을 사용하여 아래 화살표 함수로 되어 있는 것을 일반 함수로 바꿔주세요.)

# 9. 클로저(Closure)

클로저란 **폐쇠된 공간 안에 데이터에 접근하기 위한 테크닉**입니다.

예시로 보는게 이해가 빠릅니다. 아래 예제에서는 add5, add10이 클로저입니다.

좀 더 풀어서 얘기하자면, 외부 함수에 대한 접근 권한을 내부 함수에 위임함으로서 폐쇠된 공간 안의 데이터에 접근할 수 있도록 하는 테크닉입니다.

그러면 왜 사용할까요? 클로저를 사용하면 특정 변수나 함수를 외부에서 접근할 수 없도록 숨길 수 있습니다. 이를 통해 private 변수와 메서드를 구현할 수 있습니다.

::a[클로저 | MDN]{class="btn-link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures" target="\_blank"}

```jsx
function makeAdder(x) {
  var y = 1;
  return function (z) {
    y = 100;
    return x + y + z;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);
//클로저에 x와 y의 환경이 저장됨

console.log(add5(2)); // 107 (x:5 + y:100 + z:2)
console.log(add10(2)); // 112 (x:10 + y:100 + z:2)
//함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
//지역스코프에서 값을 찾고, 없으면 그 밖에 있는 스코프에서 찾고, 계속해서 찾아 올라가 전역 스코프까지 찾아보는 것을 스코프체이닝
```

```jsx
function 제곱(x) {
  function 승수(y) {
    return y ** x;
  }
  return 승수;
}

var 제곱2 = 제곱(2);
var 제곱3 = 제곱(3);

제곱2(10);
제곱3(10);
```

```jsx
function 제곱(x) {
  return function (y) {
    return y ** x;
  };
}

var 제곱2 = 제곱(2);
var 제곱3 = 제곱(3);

제곱2(10);
제곱3(10);
```

함수 내부에서 선언해야 합니다. 호출된 위치는 상관 없습니다.

```jsx
const x = 100;

function a() {
  const x = 1;
  b();
}

function b() {
  console.log(x);
}

a(); // 100
b(); // 100

// 비교대상

const xx = 100;

function a() {
  const xx = 1;
  function b() {
    console.log(xx);
  }
  b();
}

a();
```

이러한 클로져의 사용을 실제로 만날 수 있는 테크닉이 바로 ‘쓰로틀링’(**Throttling**)입니다.

::a[Throttling in JavaScript Easiest Explanation]{class="btn-link" href="https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081" target="\_blank"}

```jsx
function throttle(mainFunction, delay) {
  let timerFlag = null; // Variable to keep track of the timer

  // Returning a throttled version
  return (...args) => {
    if (timerFlag === null) {
      // If there is no timer currently running
      mainFunction(...args); // Execute the main function
      timerFlag = setTimeout(() => {
        // Set a timer to clear the timerFlag after the specified delay
        timerFlag = null; // Clear the timerFlag to allow the main function to be executed again
      }, delay);
    }
  };
}
```

```jsx
// Define a function that fetches some data from an API
function fetchData() {
  console.log('Fetching data...');
  // Simulate an API call with a random delay
  setTimeout(() => {
    console.log('Data fetched!');
  }, Math.random() * 1000);
}

// Throttle the fetchData function with a delay of 5000 ms
const throttledFetchData = throttle(fetchData, 5000);

// Add an event listener to the window scroll event that calls the throttledFetchData function
window.addEventListener('scroll', throttledFetchData);
```

# 10. 생성자 함수 (Constructor)

자바스크립트에서 객체를 생성하는 방식은 대표적으로 두 가지가 있습니다.

하나는 앞서서 배운 객체 리터렬 표현식, 그리고 나머지가 생성자 함수를 이용한 방식입니다.

따라서 생성자 함수는 사용자 정의 객체를 생성할 때 사용되는 함수입니다.

**생성자 함수의 특징**

- 일반 함수와 구분하기 위해 생성자 함수 이름 첫 글자는 대문자로 시작합니다.
- 반드시 `'new'` 연산자를 붙여 실행해야합니다. new 연산자는 생성자 함수의 this 가 인스턴스를 바라보도록 만들어주는 역할을 합니다.

```jsx
let book = {
  책이름: '알잘딱깔센 JavaScript 비동기 프로그래밍 - 비동기 너 내 동기가 돼라',
  책가격: 0,
  저자: ['구나영', '김경림'],
  출판일: '2022.08.12',
};
// 책이 100권이라면?

function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = new Book('JS', 0, ['이호준'], '2099.10.30');
let book2 = new Book('Python', 100000, ['이호준'], '2099.11.30');
let book3 = new Book('React', 1000000, ['이호준'], '2099.12.30');

console.log(book1, book2, book3);
```

- 실제로 아래와 같이 동작

```jsx
function Book(책이름, 책가격, 저자, 출판일) {
  // this = {}
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
  // return this
}
```

- 일반함수로 바꾸었을 때(new 키워드를 사용하지 않았을 경우)

```jsx
function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = Book('JS', 0, ['이호준'], '2099.10.30');
let book2 = Book('Python', 100000, ['이호준'], '2099.11.30');
let book3 = new Book('React', 1000000, ['이호준'], '2099.12.30');

console.log(book1, book2, book3); // book1과 book2는 반환값이 나와버림
```

- 생성자 함수를 사용하는 이유
  - 동일한 프로퍼티를 가지는 객체 생성
  - prototype을 이용하여 메모리 효율을 높일 수 있음

생성자 함수는 객체지향 자바스크립트에서 좀 더 자세히 얘기해보겠습니다 🙂
