---
chapter: 연산
title: 연산
date: 2024-05-13
---

# 1. 산술 할당 연산

산술 연산과 동시에 변수에 값을 할당하는 연산자입니다. 기존 변수의 값을 수정할 때 유용하게 사용됩니다.

```javascript-exec
x += 10; // x = x + 10;
console.log(x);

x -= 2;
console.log(x);

x *= 3;
console.log(x);

x /= 2;
console.log(x);

x %= 5;
console.log(x);

x **= 2;
console.log(x);
```

:::div{.callout}
**Syntax Sugar (문법 설탕)**

내부적인 동작은 동일하지만 기존 문법을 더 간결하고 편리하게 표현하는 대체 문법
:::

# 2. 비교 연산

## 2.1. 동등과 부등

값을 비교합니다. 피연산자의 타입이 다른 경우에는 **타입 변환**을 수행한 후 비교합니다. 원시타입은 값이 같을 때, 객체 타입은 동일한 객체를 참조할 때만 true를 반환합니다.

```jsx
let x = 20;
let y = 10;

console.log(x == 20); // true
console.log(x == '20'); // true

console.log(x != y); // true
console.log(y != '10'); // false

let obj1 = { a: 1, b: 2 };
let obj2 = obj1;
let obj3 = { a: 1, b: 2 };
console.log(obj1 == obj2); // true
console.log(obj1 == obj3); // false
console.log([] == []); // false
```

### 자동 형 변환(type coercion)

연산과 비교를 위하여 자바스크립트 엔진이 데이터 형을 자동으로 변환하는 것을 말합니다. 개발자의 의도와 상관없이 코드에 따라 강제로 형을 변환합니다.

1. 원시값끼리 비교할 때는, 숫자로 변환한 후 비교합니다.

```jsx
console.log(0 == null); // false
console.log(null == null); // true
console.log(undefined == null); // true
```

<aside>
💡 숫자 중 NaN은 자기 자신을 포함한 어떤 값과도 동등하거나 일치하지 않습니다.

따라서 값이 NaN인지 판별하기 위해서는 isNaN 또는 Number.isNaN을 사용해야 합니다.

```jsx
console.log(NaN == NaN); // false

// 값이 NaN인지 판별하는 법
console.log(isNaN('hello')); // true
console.log(Number.isNaN('hello'); // false
```

[isNaN() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/isNaN)

[Number.isNaN() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)

</aside>

1. null과 undefined 끼리 비교할 경우에만 true를 반환합니다.

```jsx
console.log(0 == null); // false
console.log(null == null); // true
console.log(undefined == null); // true
```

1. 객체와 원시타입을 비교할 때는, 객체를 원시타입에 맞춰 변환합니다.

```jsx
console.log([1, 2] == '1,2'); // true
console.log([] == 0); // true
console.log([] == true); // false
```

## 2.2. 일치와 불일치

## 2.3. 일치 (===) / 불일치(!==)

값과 타입이 일치하는지 비교합니다. 타입 변환을 수행하지 않는 엄격한 비교를 수행합니다. 자동으로 타입이 변환하는 것을 방지하기 위하여 동등 연산자보다는 일치 연산자를 사용하는 것을 권장합니다.

```jsx
let x = 20;
let y = 10;

console.log(x === 20); // true
console.log(x === '20'); // **false**

console.log(x !== y); // true
console.log(y !== '10'); // true
```

# 3. 논리연산과 단축평가

## 3.1. 논리곱 단축평가

```jsx
let age = 10;
console.log(age > 5 && age < 20); // true
console.log('licat' && 'wade'); // wade
```

논리곱 연산에서 모든 값이 Truthy 하다면 가장 마지막 값을 반환하고, Falsy한 값이 있다면 가장 처음 만나는 falsy한 값을 반환합니다. 논리곱 연산에서 False를 만나면 뒤에 값이 True가 오더라도 False로 평가되기 때문에 나머지 평가를 생략하게 됩니다. 이를 **단축 평가**라고 합니다.

```jsx
console.log('licat' && 'wade'); // wade
console.log('licat' && 0 && 'wade' && NaN); // 0

let isLoggedIn = true;
isLoggedIn && console.log('Hello world!');
```

## 3.2. 논리합 단축평가

논리합 연산자 또한 단축 평가가 일어납니다. 모든 피연산자가 Falsy라면 가장 마지막 값을 반환하고, Truthy한 값이 있다면 가장 처음 만나는 Truthy한 값을 반환합니다.

```jsx
console.log('licat' || 'wade'); // licat
console.log(0 || NaN || 'licat' || 'wade'); // licat

let name = window.prompt('이름을 입력하세요');
name = name || '사용자';
console.log(`${name}님 환영합니다!`);
```

# 4. nullish 병합

왼쪽 피연산자가 null도 아니고 undefined도 아니면 왼쪽 피연산자를 반환하고, 아닌 경우에만 오른쪽에 있는 피연산자를 반환합니다. 즉, undefined이나 null이 아닌 값을 반환합니다.

```jsx
let a = null;
let b = 23;

console.log(a ?? b);
console.log(b ?? a);
```

OR 연산자와 유사하게 생겼지만, 첫 번째 truthy를 반환하는 OR 연산자와 달리 nullish 연산자는 첫 번째로 ‘값이 할당된’ 피연산자를 반환합니다. 즉, 첫 번째로 오는 null과 undefined가 아닌 값을 반환하게 됩니다.

```jsx
let name = window.prompt('이름을 입력하세요');
name = name ?? '사용자';
console.log(`${name}님! 안녕하세요.`);
```

[Nullish coalescing operator - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing)

# 5. 옵셔널 체이닝

객체의 속성값에 접근할 때, 속성이 존재하지 않아도 오류가 발생하지 않습니다. 하지만 중첩된 객체의 속성에 접근할 때는 주의가 필요합니다. 다음 코드에서 오류가 나는 이유는 `user1.address`가 `undefined`로 반환되며 `undefined`는 프로퍼티를 가지고 있지 않아 오류가 발생합니다.

```jsx
const user1 = {
  name: 'licat',
  age: '20',
};

console.log(user1.address); // undefined
console.log(user1.address.city); // TypeError
```

이런 오류를 방지하기 위해 단축 평가를 이용할 수 있습니다. 다음 코드에서는 `user1.address`가 undefined로 falsy하기 때문에 단축 평가를 종료하고 undefined를 출력합니다.

```jsx
console.log(user1 && user1.address && user1.address.city);
```

단축평가를 옵셔널 체이닝(?.)을 이용하여 간결하게 표현할 수 있습니다. 프로퍼티 뿐만 아니라 메서드도 유효성을 확인한 후 실행할 수 있습니다. 객체가 null이나 undefined일 때 오류를 발생하지 않고 undefined를 반환합니다.

```jsx
console.log(user1?.address?.city ?? 'Jeju');
console.log(user1.greeting?.());
```

---

# 2. 비교 연산

비교 연산은 값이 크고 작음을 비교하거나 같고 다름을 비교하는 연산을 말합니다. 결과는 항상 true 또는 false 중 하나의 값을 반환합니다.

## 2.1. 대소관계 연산자

```jsx
let x = 20;
let y = 10;

console.log(x > y); // true
console.log(x < y); // false

console.log(x >= y); // true
console.log(x <= y); // false
```

<aside>
💡 **문자열 대소관계 비교**

두 피연산자가 모두 문자열인 경우 사전순으로 비교합니다.

```jsx
'apple' < 'banana';
'10' < '2';
```

</aside>

## 2.2. 동등(==) / 부등(!=)

# 3. 논리 연산

## 3.1. 논리곱 AND (&&)

논리곱 연산자는 두 개의 피연산자가 모두 true일 때만 true를 반환합니다. 이 때, 피연산자가 불리언이 아닌 경우에는 값이 Truthy한지 Falsy한지를 판단합니다.

```jsx
console.log(`true && true : ${true && true}`);
console.log(`true && false : ${true && false}`);
console.log(`false && true : ${false && true}`);
console.log(`false && false : ${false && false}`);
```

## 3.2. 논리합 OR (||)

논리합 연산자는 두 개의 피연산자 중 적어도 한 개 이상이 true이면 true를 반환합니다. 즉, 두 피연산자가 모두 false일 때만 false를 반환하게 됩니다.

```jsx
console.log(`true || true : ${true || true}`);
console.log(`true || false : ${true || false}`);
console.log(`false || true : ${false || true}`);
console.log(`false || false : ${false || false}`);
```

## 3.3. 논리 부정 NOT (!)

논리 부정 연산자는 단일한 피연산자를 가지며, 논리값을 부정합니다. 즉, true를 false로, false를 true를 변환합니다.

```jsx
console.log(!true);
console.log(!false);

console.log(!'hello');
console.log(!!'hello'); // 형 변환
```

# 4. nullish 연산자 (??)

# 5. 옵셔널 체이닝 (?.)
