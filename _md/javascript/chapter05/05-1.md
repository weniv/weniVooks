---
chapter: Type2 - 객체타입
title: 객체타입
date: 2024-05-13
---

# 1. 객체타입 (Object Types)

객체타입의 특징은

1. 객체는 프로퍼티로 값과 메서드를 가지며, 이 둘은 각각 객체의 상태와 동작을 나타냅니다.
2. 값을 변수에 저장할 때 값 자체가 아닌 **값의 위치**가 저장된다는 점입니다. 때문에 객체 값을 다른 변수에 할당 할때는 값 자체가 복사되어 저장되는 것이 아닌 **값의 참조(위치)** 가 저장됩니다.
3. 다만 다른 책이나 강의에서 call by reference, call by value라고 언급이 되어 있는 경우도 있는데 이렇게 말하는 것은 적당치 않습니다. JavaScript는 call by value만 존재하기 때문입니다. (추후 언급할 내용입니다. 잘 이해가 안되시면 뒤에서 다시 언급하니 넘어가셔도 괜찮습니다. 잘 정리된 글이 있어 블로그 링크를 하단에 첨부합니다.)

   ::a[[JS] 📚 Call by Value & Call by Reference (+ Call by Sharing)]{class="btn-link" href="https://inpa.tistory.com/entry/JS-📚-Call-by-Value-Call-by-Reference" target="\_blank"}

```jsx
let arr1 = [1, 2, 3];
let arr2 = arr1;
console.log(arr2);

arr1[0] = 10;
// arr1 = [10, 20];
console.log(arr2);

// 비교해보세요.
let value1 = 10;
let value2 = value1;
console.log(value2);

value1 = 20;
console.log(value2);
```

:::div{.callout}
원시타입도 메서드가 존재했던것 같은 느낌적인 느낌이 있습니다!
맞습니다. 원시타입도 프로퍼티와 메서드를 사용했었죠? 자바스크립트는 원시타입도 마치 객체타입처럼 사용할 수 있게 autoboxing 이라는 과정을 거치게 됩니다.

이런 과정을 거치는 이유는 원시타입도 객체타입처럼 사용할 수 있게 함으로써 일관적인 사용 경험을 사용자에게 제공하기 위해서입니다.

```jsx
let val = 'hello!';
console.log(val.toUpperCase());

// 위의 코드가 내부적으로는 아래처럼 실행됩니다. 이것이 바로 autoboxing 입니다.

let val = 'hello!';
let temp = new String('hello!');
console.log(temp.toUpperCase());
temp = null;
```

:::
