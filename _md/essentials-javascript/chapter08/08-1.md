---
chapter: 조금 더 깊이 들여다보기
title: this
date: 2024-04-03
---

# 1. this란?

this는 객체를 가리키는 참조 변수입니다. this는 호출되는 위치에 따라 다른 값을 출력하기 때문에 우리에게 혼란을 줍니다.

아래 예제에서 this는 위의 경우에는 window, 아래의 경우에는 myObj입니다. 분명 같은 기능을 하고 있는데 말이죠.

```jsx
function a() {
  console.log(this);
}
a();
```

```jsx
let myObj = {
  val1: 100,
  func1: function () {
    console.log(this);
  },
};

myObj.func1();
```

여기서는 상황마다 this가 가리키는 값을 출력해보는 시간을 가지도록 하겠습니다. this 는 상당히 혼란스러운 내용이니 추후 제대로 정리할 필요가 있습니다.

## 1.1 전역 컨텍스트

```jsx
console.log(this); // 브라우저에서는 window 객체
```

- 전역 컨텍스트에서 `this`는 전역 객체(브라우저에서는 `window`)를 가리킵니다.

## 1.2 함수 호출

```jsx
function foo() {
  console.log(this); // 브라우저에서는 window 객체
}

foo();
```

- 일반 함수 내부에서 `this`는 전역 객체를 가리킵니다.

## 1.3 메서드 호출

```jsx
const person = {
  name: 'Alice',
  greet: function () {
    console.log(`Hello, I'm ${this.name}`); // Hello, I'm Alice
  },
};

person.greet();
```

- 객체의 메서드 내에서 `this`는 그 메서드를 호출한 객체를 가리킵니다.

## 1.4 이벤트 헨들러

이벤트 핸들러 내에서 this는 이벤트가 발생한 DOM 요소를 가리킵니다.

```jsx
<button id="btn">Click me!</button>

<script>
const button = document.getElementById('btn');
button.addEventListener('click', function() {
  console.log(this); // <button id="btn">Click me!</button>
});
</script>
```

# 2. this 값을 사용자의 의도대로 조작하기

함수의 apply(), call(), bind() 메소드를 사용하면 this를 조작하거나 고정해 둘 수 있습니다.

이는 사용자가 원하는 의도대로 binding을 통한 컨트롤을 할 수 있게 합니다.

## **2.1. call()**

call() 메서드의 인수에 this 로 사용할 값을 전달할 수 있습니다.

```jsx
var peter = {
  name: 'Peter Parker',
  sayName: function () {
    console.log(this.name);
  },
};

var bruce = {
  name: 'Bruce Wayne',
};
peter.sayName.call(bruce);

// peter.sayName.call(bruce) 의 결과는 무엇이 될지 생각해 봅시다.
```

## **2.2. apply()**

apply() 메서드의 인수에 this 로 사용할 값과 실행할 메서드의 매개변수값을 배열 형태로 전달할 수 있습니다.

```jsx
var peter = {
  name: 'Peter Parker',
  sayName: function (is, is2) {
    console.log(this.name + ' is ' + is + ' or ' + is2);
  },
};

var bruce = {
  name: 'Bruce Wayne',
};

peter.sayName.apply(bruce, ['batman', 'richman']);

/* peter.sayName.apply(bruce, ['batman', 'richman']) 의 결과가 무엇이 될지 생각해보고 
apply 를 call로 바꾸어 호출했을 때와 비교해 봅시다. */
```

## **2.3. bind()**

bind() 는 this가 고정된 새로운 함수를 반환합니다.

```jsx
function sayName() {
  console.log(this.name);
}

var bruce = {
  name: 'bruce',
  sayName: sayName,
};

var peter = {
  name: 'peter',
  sayName: sayName.bind(bruce),
};

peter.sayName();
bruce.sayName();

/* peter.sayName() 과 bruce.sayName() 의 결과 값이 무엇이 될지 생각해봅시다. */
```

<aside>
💡 this에 바인딩되는 객체가 동적으로 결정되는 기명함수와 달리 화살표 함수의 경우 상위 스코프의 this를 가리킵니다(Lexical this).

</aside>

```jsx
const person = {
    name: 'hojun',
    age: 25,
    a(){
        console.log(this);
        console.log(this.name);
        function b() {
            console.log(this);
            console.log(this.name);
            function c() {
                console.log(this);
                console.log(this.name);
            }
            c()
        }
        b()
    }
}
person.a()

//출력
{name: 'hojun', age: 25, a: ƒ}
hojun

Window {window: Window, self: Window, document: document, name: '', location: Location, …}
''

Window {window: Window, self: Window, document: document, name: '', location: Location, …}
''
```

```jsx
// a에서 this = person
// b에서 this = 상위스코프(상위에서 person을 보고있음) 즉 person
// c에서 this = 상위스코프(상위에서 person을 보고있음) 즉 person
const person = {
    name: 'hojun',
    age: 25,
    a(){
        console.log(this);
        console.log(this.name);
        let b = () => {
            console.log(this);
            console.log(this.name);
            let c = () => {
                console.log(this);
                console.log(this.name);
            }
            c()
        }
        b()
    }
}
person.a()

//출력
{name: 'hojun', age: 25, a: ƒ}
hojun

{name: 'hojun', age: 25, a: ƒ}
hojun

{name: 'hojun', age: 25, a: ƒ}
hojun
```

---

다음과 같이 콜백의 this가 전역을 바라보고 있지 않은 경우도 있습니다.

```jsx
[1, 2, 3].forEach(
  function () {
    console.log(this);
  },
  [10, 20, 30],
);
```
