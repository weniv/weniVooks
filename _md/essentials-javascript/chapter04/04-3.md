---
chapter: 연산
title: 객체타입 메서드~
date: 2024-05-13
---

## 1.2. 숫자형 메서드

### 1.2.1. parseInt(), parseFloat()

이 함수들은 문자열을 숫자로 변환합니다. `parseInt`는 정수로, `parseFloat`는 실수로 변환합니다. 두 번째 인자로는 진수를 전달할 수 있습니다. 해당 진법에 맞게 문자열을 인식하여 숫자로 변환합니다.

```javascript-exec
console.log(`parseInt('hello') : ${parseInt('hello')}`); // NaN (문자열 'hello'는 숫자로 변환 불가)
console.log(`pareInt('110', 2): ${parseInt('110', 2)}`); // 6 (2진수 110을 10진수로 변환)
console.log(`parseInt('30b') : ${parseInt('30b')}`); // 30 (문자열 '30b'에서 숫자 부분만 변환)
console.log(`parseFloat('45.4') : ${parseFloat('45.4')}`); // 45.4 (문자열 '45.4'를 실수로 변환)
```

### 1.2.2. toString()

이 메소드는 숫자를 문자열로 변환합니다. 원하는 진수로 표현할 수도 있습니다.

```javascript-exec
let num = 5;
console.log(`num.toString() : ${typeof num.toString()}`); // string (숫자 5를 문자열 '5'로 변환)
console.log(`num.toString() : ${(3).toString()}`); // '3' (숫자 3을 문자열 '3'로 변환)
console.log(`num.toString(2) : ${(3).toString(2)}`); // '11' (숫자 3을 2진수로 변환하여 '11'로 표현)
```

:::div{.callout}
`3.toString()`은 왜 에러가 발생할까요? 자바스크립트 엔진은 숫자 뒤의 점을 소수점으로 인식하기 때문입니다. 따라서 `(3).toString()`처럼 소괄호를 사용해 숫자를 감싸주어야 합니다.

```javascript-exec
// console.log(3.toString());
console.log((3).toString());
```

:::

### 1.2.3. toFixed()

toFixed는 소수점 이하 자릿수를 지정하여 문자열로 반환합니다. 인자를 지정하지 않으면 소수점 이하를 제거하고 문자열로 반환합니다.

```javascript-exec
let num = 5.123456;
console.log(`num.toFixed() : ${num.toFixed()}`); // 5 (소수점 이하 자릿수를 지정하지 않으면 정수로 반환)
console.log(`num.toFixed(2) : ${num.toFixed(2)}`); // 5.12 (소수점 이하 2자리까지 반환)
console.log(`num.toFixed(4) : ${num.toFixed(4)}`); // 5.1235 (소수점 이하 4자리까지 반환)
```

### 1.2.4. isNaN

이 함수는 값이 NaN인지 확인합니다. 전달받은 값을 숫자형으로 변환하여 NaN인지 판별합니다. `Number.isNaN()`이 조금 더 나중에 나온 메서드로 값을 숫자형으로 변환하지 않아 정확하게 NaN을 판별합니다. 실무에서는 `Number.isNaN()`을 사용하는 것을 권합니다. 다만 `isNaN()`도 여전히 사용되고 있으므로 알아두시는 것이 좋습니다.

```javascript-exec
console.log(`isNaN('5') : ${isNaN('5')}`); // false (문자열 '5'는 숫자로 변환 가능)
console.log(`isNaN(3) : ${isNaN(3)}`); // false (숫자 3은 숫자)
console.log(`isNaN('b3') : ${isNaN('b3')}`); // true (문자열 'b3'는 숫자로 변환 불가)
console.log(`isNaN('3b') : ${isNaN('3b')}`); // true (문자열 '3b'는 숫자로 변환 불가)
console.log(isNaN(undefined)); // true (undefined는 숫자로 변환 불가)

console.log(Number.isNaN(undefined)); // false (undefined는 NaN이 아님)
console.log(Number.isNaN(null)); // false (null은 NaN이 아님)
console.log(Number.isNaN(NaN)); // true (NaN은 NaN)
```

:::div{.callout}
**isNaN과 Number.isNaN의 차이**  
`isNaN()`은 값이 NaN인지 확인할 때, 전달받은 값을 숫자형으로 변환하여 NaN인지 판별합니다. `Number.isNaN()`은 값을 숫자형으로 변환하지 않아 정확하게 NaN을 판별합니다. 따라서 `Number.isNaN()`을 사용하는 것을 권합니다.

```javascript-exec
console.log(isNaN('5')); // false (문자열 '5'는 숫자로 변환 가능)
console.log(Number.isNaN('5')); // false (문자열 '5'는 숫자로 변환 가능)
```

```javascript-exec
console.log(isNaN(undefined)); // true (undefined는 숫자형으로 변환하면 NaN)
console.log(Number.isNaN(undefined)); // false (undefined는 NaN이 아님)
```

:::

# 3. 원시 타입의 메서드

메서드는 일반적으로 객체 타입에서만 사용할 수 있는 기능입니다. 그러나 자바스크립트에서

메서드는 객체 타입의 값에서 사용 가능한 기능을 제공합니다. 하지만 원시 타입의 값에서도 메서드를 사용할 수 있습니다. 이는 자바스크립트 엔진이 원시 타입의 값을 객체로 변환하여 메서드를 사용할 수 있게끔 처리하기 때문입니다.

```javascript-exec
let val = 'hello!';
console.log(val.toUpperCase());
```

위 코드는 실제로 아래와 같이 동작합니다. 일시적으로 문자열 객체를 만들고 이 객체에 있는 메서드를 호출한 뒤, 객체를 제거합니다. 이처럼 원시타입을 마치 객체 타입처럼 사용할 수 있게 하는 것을 '원시 래퍼 타입'이라고 합니다.

```javascript
let temp = new String('hello!');
console.log(temp.toUpperCase());
temp = null;
```

이 과정을 거치는 이유는 원시타입도 객체타입처럼 다양한 메서드를 사용할 수 있게 함으로써 일관적인 사용 경험을 제공하기 위함입니다.
