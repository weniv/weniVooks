---
chapter: 비동기 프로그래밍
title: fetch API
date: 2024-04-30
---

# 1. fetch API

그리고 시간이 흘러 콜백지옥으로 고통받던 개발자들에게 희소식이 전해집니다.

바로 XMLHttpRequest 를 대체할 새로운 API 가 등장했으니 이름하여 fetch 입니다. fetch는 여러가지 뜻이 있지만 여기서는 ‘가져오다, 찾아내다’의 의미로 사용되고 있습니다.

XHR과 fetch의 가장 큰 차이점은

XMLHttpRequest 가 생성하는 인스턴스는 통신의 기능을 수행하는 XMLHttpRequest 객체를 반환했지만

![Untitled](/images/essentials-javascript/chapter14/Untitled%202.png)

fetch는 인스턴스를 만들지 않고, 대신 ‘약속’을 반환한다는 것입니다.

![Untitled](/images/essentials-javascript/chapter14/Untitled%203.png)

# 2. fetch API 사용해보기

프라미스가 비동기 통신을 매우 쉽게 만들어준다는것을 앞에서 배워볼 수 있었습니다

자 처음에 fetch는 Promise를 반환한다는 얘기에서 시작해 여기까지 왔군요! 이제 다시 fetch로 돌아가겠습니다.

```jsx
let result = fetch(
  'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json',
);
console.log(result);
```

fetch는 함수처럼 바로 실행할 수 있습니다. XHR 객체에 비해 무척 간단하죠?

fetch 함수를 실행하면 바로 인자로 전달한 url에 접근해 데이터를 다운로드 받게 됩니다. 다운로드가 완료되면 바로 fulfilled 상태의 프로미스가 반환됩니다. 그리고 resolve 함수를 자동으로 호출합니다.

마찬가지로 fetch 함수는 네트워크 오류가 발생하면 reject 상태의 프로미스를 반환합니다. 그리고 reject 함수를 자동으로 호출합니다. 코드가 더 간단해지겠죠?

콘솔로 result를 찍어보면 promise 객체가 보일겁니다.

자 그럼 promise 객체는 크게 두 가지 상황을 가정한 메소드를 가졌었죠 바로 then 과 catch 입니다.

```jsx
let result = fetch(
  'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json',
);

result.then((data) => {
  console.log(data);
});
```

fulfilled 상태의 프라미스를 반환하기 때문에 then을 통해 데이터를 잘 가져올 수 있을겁니다. 그리고 콘솔을 보면 이번에는 Response 라는 객체가 보입니다.

Response 는 요청에 대한 종합적인 응답 정보가 저장되어 있는 객체입니다.

우리가 필요한것은 JSON 데이터이기 때문에 .json() 메소드를 통해 자바스크립트 객체로 변환이 가능한 promise 객체를 반환받을 수 있습니다. 때문에 여기서 한번 더 then 메소드를 이용해야 우리가 필요한 데이터를 뽑아낼 수 있습니다.

```jsx
fetch(
  'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json',
)
  .then((response) => {
    // response.ok 는 응답이 성공적(200-299)일 경우 true, 아니면 false를 반환합니다.
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => {
    console.log(data);
    return data;
  })
  // fetch 함수는 네트워크 오류가 발생하면 reject 상태의 프로미스를 반환합니다.
  .catch((error) => {
    console.error(error);
  });
```

자 그럼 이제 fetch를 이용해 XHR객체로 AJAX 통신을 했던 코드를 수정해봅시다.

:::div{.callout}
**response.ok**
response.ok 는 응답이 성공적(`200-299`)일 경우 true, 아니면 false를 반환합니다.
하지만 fetch의 경우 네트워크 통신이 완료되면 자동으로 fulfilled 상태의 프로미스가 반환되는데 왜 이런 예외처리가 필요할까요?
사실 fetch 는 HTTP 응답 코드가 `200`이 아닌 '실패' 상태여도 **`resolve`** 상태의 프로미스를 반환합니다. 개발자가 의도한 데이터를 받지 못했지만, 서버와의 통신 자체는 성공했기 때문에 약속이 이행됐다고 판단하기 때문입니다. ( 앞서 살펴본 XHR 부분에서 통신 예외 처리시 `requestObj.readyState == 4` 만 확인했다고 보시면 됩니다. )
때문에 사용자가 의도한 데이터를 무사히 전달받기 위해서는 response.ok를 이용한 예외처리가 필수적입니다.
:::
