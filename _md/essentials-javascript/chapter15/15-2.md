---
chapter: 비동기 통신
title: 동기와 비동기
date: 2024-04-30
---

[8. 비동기(콜백함수, 프로미스, await/async, fetch)](https://www.notion.so/8-await-async-fetch-835e5806f6be444aa02ccfd38cb7a9b7?pvs=21)

[알잘딱깔센 JavaScript 비동기 프로그래밍 - 비동기 너 내 동기가 돼라](https://www.notion.so/JavaScript-e171d97722484860aa5b162afae83cb1?pvs=21)

## 2. 동기 VS 비동기

- 일상에서 마주치는 동기와 비동기

1. 마트에서 물건을 구입할 때 계산대에서 손님들이 물건을 계산하러 줄을 섭니다.
2. 첫 손님이 지갑을 찾느라 잠시 계산을 못하는 상황이 발생합니다.
3. 이때 점원이 손님이 지갑을 찾고 돈을 꺼낼 때 까지 가만히 기다리고 있다면 동기적 처리,
4. 기다리면서 동시에 비어있는 옆 계산대로 이동해 첫 손님이 지갑을 찾을 동안 잠시 다음 손님의 계산을 먼저 처리한다면 비동기적 처리라고 볼 수 있습니다.

- 코드로 살펴보는 동기와 비동기

```jsx
// 자바스크립트 코드는 기본적으로 순서대로(동기적으로) 실행됩니다.
console.log(1);
console.log(2);
[3, 4, 5].forEach((i) => console.log(i));
console.log(6);
```

```jsx
console.log(1);
// setTimeout으로 콜백함수가 일정시간 뒤에 실행하도록 코드를 작성합니다. 순서대로 실행되지 않습니다.(비동기적으로 실행). 이러한 비동기 실행 코드는 setInterval, addEventListener 와 같은 함수들이 있습니다.
setTimeout(() => console.log(2), 100);
[3, 4, 5].forEach((i) => console.log(i));
console.log(6);
```

### 🔥 callback 지옥 🔥

Ajax가 널리 쓰이게 되면서 비동기 처리방법이 매우 중요해졌습니다.
Ajax는 기본적으로 비동기적으로 서버와의 통신을 처리하기 때문에 Ajax와 기존의 동기식 코드를 함께 작성하면 코드의 실행순서에 문제가 발생합니다.
자바스크립트 엔진은 비동기 코드가 끝날때까지 다른 코드의 실행을 멈추지 않기 때문입니다.

```jsx
// sudo코드
const result = 비동기통신함수();

const result2 = 비동기통신함수2();

const total = result + result2;

// 이런 방식은 불가능합니다. result와 result2에 무슨 값이 들어있을지 생각해보세요.
```

앞서 작성한 XHR 코드를 수정해서 확인해봅시다.

```jsx
let result;
function xhrRequest() {
  const requestObj = new XMLHttpRequest();
  requestObj.open('GET', 'message.txt');
  requestObj.onreadystatechange = () => {
    if (requestObj.readyState === 4 && requestObj.status === 200) {
      result = requestObj.responseText;
      console.log(result); // 콘솔에 무엇이 찍히는지 확인해봅시다.
    }
  };
  requestObj.send();
}

xhrRequest();
console.log(result); // 콘솔에 무엇이 찍히는지 확인해봅시다.
```

이러한 결과로 인해 통신이 끝난 다음에야 다음 함수가 실행되도록 콜백함수로 코드를 작성해야합니다.
결국 일반적인 동기식 코드처럼 비동기 함수 실행 후 다음 라인에서 다른 함수를 실행하는, 순차적으로 함수들을 나열하는 방식이 불가능합니다. 비동기 코드가 끝나고 콜백으로 함수를 부르고, 다음 함수를 또 콜백으로 부르는 형태가 되야합니다.

```jsx
const total = 비동기통신함수(
  input,
  통신함수의결과를가공하는함수1(
    result,
    비동기통신함수2(통신함수의결과를가공하는함수2(result, result2)),
  ),
);

// 이렇게 비동기 함수가 끝나기 전에 중간 중간에 필요한 콜백함수를 실행시키며 사용할 수 밖에 없었습니다.
```

실제 예시를 위해 유저를 검색하고 알맞는 인사말을 건네는 간단한 프로그램을 작성해보겠습니다.

### 4.1 Promise? 약속? 약속이란 무엇일까!?

약속은 약속이죠. 맞습니다. 우리가 생각하는 바로 그 약속(무언가를 할 것이라 미리 정하는 행위)입니다.

우리가 스타벅스에서 커피를 주문하는 상황을 생각해봅시다.

1. 스타벅스에 가서 커피를 주문할 때, 카운터에서 잠시 고민을 하겠죠? (pending : 보류중인, 대기중인)
2. 오늘의 커피를 주문해보겠습니다. 주문을 받은 점원은 우리에게 “_오늘의 커피는 대략 10분 ~ 15분 정도 커피를 내리는 시간이 필요합니다. 완료되면 알려드리겠습니다._” 라고 얘기할겁니다. 우리에게 약속(promise)하는거죠. 이때 약속은 우리에게 ‘**결과**(커피를 주거나 or 못주거나)’를 준다는 것입니다.
3. 그리고 우리는 커피가 만들어지는 동안(Asynchronously) 공부하기 적당한 테이블을 찾고, 노트북(맥북)을 꺼내고, 잠시 마음을 가다듬어봅니다.

4.1. 그럼 잠시 뒤 커피가 만들어져 나옵니다! 즉, 우리의 주문이 해결되었고(resolved : 해결된, 결정된 ), 약속이 이루어졌습니다. (fulfilled : 약속을 이행, 완수 )

4.2. 그런데 어쩌면 이런 상황이 발생할 수도 있습니다. 점원이 급하게 와서 오늘의 커피에 사용할 원두가 떨어졌다는거죠(실재로 있었던 일입니다… ㅠ). 그렇다면 약속이 이뤄지지 않은 즉, 거절된 상태(rejected)가 됩니다.

위의 예시에 나온 키워드들을 잘 생각해보면서 실제 코드로 작성해 보겠습니다.

```jsx
// 커피를 주문하는 프로미스 객체를 생성합니다. 생성자에는 약속을 지키기 위한 resolve와, 약속을 지키지 못했을 때를 대비한 reject 두 가지를 인자로 전달합니다.
// 프로미스 객체를 생성하는 순간 프로미스 생성자함수의 콜백 함수가 실행됩니다. 이를 실행자(executor)라 부릅니다.
const orderCoffee = new Promise((resolve, reject) => {
  const requestObj = new XMLHttpRequest();
  requestObj.open('GET', 'orderCoffee.txt');
  requestObj.onreadystatechange = () => {
    if (requestObj.readyState === 4) {
      if (requestObj.status === 200) {
        const result = requestObj.responseText;
        // resolve 메소드가 실행되면 then 메소드가 자동으로 호출됩니다.
        resolve(result);
      } else {
        // resolve 메소드 호출이 없는 상태에서 reject 메소드가 실행되면 catch 메소드가 자동으로 호출됩니다.
        reject(
          new Error(
            `커피주문이 정상적으로 이뤄지지 않았습니다.: ${requestObj.status}`,
          ),
        );
      }
    }
  };
  requestObj.send();
});

// 이 부분에 주목해주세요. then 메소드를 사용하면 비동기 코드를 마치 동기적인 코드처럼 작성할 수 있습니다. 앞에서 작성한 XHR 코드와 비교해보는것도 좋습니다.

// resolve 메소드가 실행될때 전달된 인자는 then 메소드의 콜백함수의 인자로 전달됩니다.
orderCoffee
  .then((asyncResult) => {
    console.log(asyncResult);
    console.log('약속이 이루어졌습니다.');
    return asyncResult;
  })
  .catch((error) => {
    // then 메소드는 프라미스 객체를 반환하기 때문에 catch 메소드를 이어서 쓰는것이 가능합니다.
    // resolve 메소드와 마찬가지로 reject 메소드가 실행될때 전달된 인자는 catch 메소드의 콜백함수의 인자로 전달됩니다.
    console.log(error);
  });
```

정리해보면,

프로미스는 비동기 코드를 마치 동기적인 코드처럼 작성할 수 있습니다. 어째서 이게 가능할까요?

우리는 약속을 의미하는 Promise 객체를 만들었고, 이 약속은 이행되거나(fulfilled), 거절되거나(reject) 둘 중에 한 가지 결과만을 가지게 될겁니다. (물론 두 가지 모두 이뤄지지 않는다면 계속 pending(대기중) 상태가 되겠지만, 실제로 이렇게 코드를 작성할 일은 없겠죠?)

때문에 통신의 결과는 코드상에서는 아직 알 수 없지만,

‘이행되거나 거절되거나 둘 중의 하나의 결과는 전달될거라 약속하고 작업을 진행하자!’

라는 개념으로 만들어졌기 때문에 then과 catch를 이용해 동기적으로 코드를 이어 쓸 수 있는것 입니다.

자 이제 아까 만들었던 인사말 프로그램을 프로미스로 수정해보는건 어떨까요? 콜백 지옥에서 해방되어 봅시다.
