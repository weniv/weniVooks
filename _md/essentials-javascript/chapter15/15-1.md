---
chapter: TDD와 Jest
title: TDD
date: 2024-04-30
---

# 18. TDD와 Jest

# 1. TDD란?

TDD는 Test Driven Development의 약자입니다.

테스트 주도 개발 즉, 테스트를 통한 기능의 구현이라 표현 할 수 있습니다.

우리가 이번 시간에 학습하게될 테크닉은 Unit Test(단위테스트) 입니다.

### Unit Test란?

- 특정 조건에서 함수(Unit)가 어떻게 작동해야 하는지 정의하고, 그러한 정의대로 함수가 잘 작동하는지 확인하는 방법론입니다.

<aside>
🧐 **테스트의 종류**

단위 테스트와 E2E(End-to-End) 테스트는 소프트웨어 개발에서 사용되는 대표적인 테스트 유형입니다.

- **단위 테스트**는 코드의 가장 작은 단위인 단위를 테스트합니다. 이때의 단위는 함수, 메서드 또는 클래스일 수 있습니다. 단위 테스트는 일반적으로 개발자가 작성하며 별도의 테스트 파일을 통해 실행됩니다.
- **E2E 테스트**는 소프트웨어 시스템의 전체 기능을 테스트합니다. 브라우저와 상호 작용을 통하여 테스트를 진행할 수 있습니다. 예를 들어, 테스트 라이브러리에서 지원하는 API 명령어의 cy.visit() 메서드를 사용하여 특정 URL로 이동하고 cy.click() 메서드를 사용하여 버튼을 클릭할 수 있습니다.

각 유형의 테스트는 소프트웨어의 다른 부분을 테스트하므로 모두 중요합니다. 단위 테스트는 내가 작성한 함수가 올바르게 작동하는지 확인하는 데 도움이 되고, E2E 테스트는 전체 시스템이 올바르게 작동하는지 확인하는 데 도움이 됩니다.

</aside>

우리가 사용할 TDD 라이브러리는 Jasmine 입니다 ([https://jasmine.github.io/](https://jasmine.github.io/))

### **TDD 의 단계**

TDD 에서는 코딩을 할때 기능을 바로 개발하지 않고, 테스트 주도 개발이라는 말 그대로 **테스트 코드**를 먼저 작성합니다. 이때 테스트 코드는 다음과 같은 단계를 먼저 거치게 됩니다.

1. 적색 단계 : 성공하기 위해 테스트에 실패하는 단계
2. 녹색 단계 : 테스트에 성공한 단계
3. 리팩터 단계 : 테스트에 성공한 코드를 기반으로 코드의 품질을 높이는 단계 (refactoring)

![위니브](/images/essentials-javascript/chapter15/TDD.png)

위니브

TDD는 이 세 가지 단계의 끊임없는 반복이라고 할 수 있습니다.

### TDD 실습

1. 환경 구성은 간단하게 스탠드얼론 방식을 이용합니다. ([https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases) )
2. 간단한 함수를 테스트 해봅니다.
3. 객체지향적 코드를 구현하여 TDD 해봅니다.

## 결론

### TDD의 장점

1. 자바스크립트는 인터프리터 언어. 컴파일러의 역할을 테스트를 통해 대신 수행하여 기능의 구동을 보장합니다. 이는 곧 코드를 안정적이고 견고하게 만들어 줍니다.
2. 구현해야 하는 기능에 대한 높은 분석을 요구하기 때문에 서비스에 대한 이해도가 상승하고 품질을 우선하는 사고를 하게됩니다.

### TDD를 사용할 때 주의해야할 점

1. 테스트 코드를 따로 작성해야 하기 때문에 시간이 더 들어가고 이는 곧 업무에 대한 부담으로 다가옵니다. 때문에 프로젝트가 급박하다면 TDD 를 사용하지 않는 편이 좋습니다. 프로젝트의 성격에 따라 신중히 판단해야합니다.
2. TDD 가 모든 예외 상황을 해결해주지는 않습니다. 결국 테스트 코드를 작성하는 사람이 고려하지 않은 상황은 테스트 코드도 놓칠 수 있기 때문에 테스트 코드를 작성했다고 해서 방심할 수는 없습니다. 테스트 코드는 견고하고 안정적인 코드를 지향하는 것이지 결코 완벽하진 않습니다.

# **2. Jest란?**

제스트는 테스트 코드를 찾고, 테스트를 실행하고, 실패인지 성공인지를 판단하는 테스트 러너입니다.

meta 에서 개발하고 관리하고 있습니다. ([https://jestjs.io/](https://jestjs.io/))

제스트만의 특징은
Html 요소를 탐색하는데 **접근성 마커 즉, WAI-ARIA를 이용합니다**. TDD 를 작성함으로서 자연스럽게 접근성을 향상시키는 장점이 있습니다. 제스트가 요소를 WAI-ARIA를 통해 찾을 수 있다는것은 스크린 리더들도 역시 WAI-ARIA를 이용할 수 있다는 얘기입니다.

<aside>
💡 WAI-ARIA란?
Web Accessibility Initiative - Accessible Rich Internet Applications 의 약자로 HTML태그에 속성을 통한 추가 시맨틱을 제공하여 부족한 접근성을 개선합니다.

[https://www.w3.org/WAI/standards-guidelines/aria/](https://www.w3.org/WAI/standards-guidelines/aria/)[https://developer.mozilla.org/en-US/docs/Learn/Accessibility/WAI-ARIA_basics](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/WAI-ARIA_basics)

</aside>

### 1. 제스트를 사용해보겠습니다.

1. **npx 명령어를 통해 리엑트 앱을 생성해봅시다.**

```bash
npx create-react-app color-button
```

1. **react 설치가 완료되고 프로젝트가 생성되었습니다. 터미널을 통해 제안을 해주는군요 🙂**

![Untitled](/images/essentials-javascript/chapter15/Untitled.png)

1. **설치가 완료되었으면 npm test를 해봅시다.**

제스트가 와치모드로 실행되는것을 확인 할 수 있습니다.

와치모드는 파일에 수정 사항이 감지될 경우 자동으로 테스트를 실행해주는 상태를 의미합니다.

<aside>
💡 만약 제스트 실행 시 노드 버전 이슈로

![스크린샷 2022-01-26 오전 10.22.08.png](/images/essentials-javascript/chapter15/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.22.08.png)

이런 에러가 발생한다면 제스트와 관련된 패키지를 설치 해주셔야 합니다.

```bash
npm i -D --exact jest-watch-typeahead@0.6.5
```

</aside>

1. enter 를 눌러 테스트를 실행해봅니다.

아무런 테스트 코드를 작성하지 않았지만 뭔가 성공했습니다! ㅎㅎ

일단 q를 눌러 test 상태에서 빠져나갑니다.

### 2. 자 이제 내부적으로 어떻게 테스트가 실행되었는지 살펴보겠습니다.

1. 제스트가 실행 코드는 App.test.js 에 있습니다.

```jsx
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

- **Test** **함수** : 글로벌 함수. 두 가지 인자를 가집니다. 첫번째 인자는 문자열로 테스트의 설명입니다. 자스민에서는 describe 입니다. 두번째 인자는 테스트를 실행하는 테스트 함수입니다.
- **Render 함수** : 인자로 받는 JSX의 가상돔을 생성합니다. 여기서는 app 컴포넌트를 전달받습니다.
- **Screen** : 생성된 가상돔에 접근하기 위한 전역 객체입니다.

<aside>
💡 render와 screen은 모두 import { render, screen } from '@testing-library/react'; 에서 왔습니다.
React Testing Library 는 테스트를 위한 virtual DOM을 제공합니다. Jest 는 바로 그 테스트 코드를 찾아서 실행합니다.

</aside>

- **getByText 함수** : 인자로 전달된 텍스트를 가지는 돔 안의 요소를 찾습니다. 여기서는 정규표현식을 사용했군요. /learn react/i 뒤에 붙은 i는 대소문자를 구분하지 않겠다는 의미입니다.

- **expect 함수** : 익숙하죠? 제스민에도 있었습니다. 기대한 결과가 성공인지 실패인지 판단하는 함수입니다.
- **.toBeInTheDocument** : matcher 함수입니다. 제스민의 .toBe() 함수가 기억나시나요? 제스트에도 존재합니다.

1. 이번에는 테스트를 실패 해봅시다. App.js 의 텍스트를 ‘Learn Vue’ 로 변경해보고 npm test를 실행 해봅니다.

1. 수정 했던 코드를 원상 복구해서 와치 모드가 잘 작동하는지도 확인해 봅시다. 🙂

### 3.간단한 기능테스트를 직접 해봅시다.

기본적인 문법과 내용에 대해 살펴봤습니다. 이제 간단한 기능을 테스트 해보겠습니다!

1. App.js 안의 return 키워드 안의 내용들과 App.test.js 안의 테스트 함수 안의 내용을 모두 지웁니다.

1. 누르면 색이 바뀌는 버튼을 만들고 테스트 해보겠습니다. App.test.js 파일에 테스트 코드를 추가합니다.

```jsx
test('버튼이 제대로 잘 작동하고 있습니까?', () => {
  render(<App />);

  const button = screen.getByRole('button', { name: 'change to blue!' });

  expect(button).toHaveStyle({ backgroundColor: 'red' });
});
```

- 코드에서 요소를 찾을 때 getByRole 로 찾는 것이 보입니다. role은 aria에서 사용하는 요소의 역할을 의미하는 속성입니다. 특정 요소는 role 을 명시하지 않아도  암묵적으로 가지고 있는 경우도 있습니다.([https://www.w3.org/TR/html-aria/#docconformance](https://www.w3.org/TR/html-aria/#docconformance))
- role 값이 틀렸을 경우 친절하게 제스트에서 제안을 해주기도 합니다.
- 암묵적인 role이 없는 요소의 경우 role 속성을 직접 명시해줍니다.

<aside>
💡 role의 종류에 대해 궁금하다면 여기를 참고해보세요. [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)

</aside>

- getByRole함수는 두번째 인자로, 찾아야할 요소 안의 텍스트는 무엇인지 알려줘야합니다.
- toHaveStyle 함수 : 요소가 특정한 CSS 스타일을 가지고 있는지 체크합니다.

<aside>
💡 이런 matcher 함수들의 종류가 궁금하다면 여기를 참고해 보세요.
https://github.com/testing-library/jest-dom

</aside>

1. 이제 테스트를 진행해 보겠습니다. 어떤 결과가 보이시나요?

1. 이제 App.js를 수정해보겠습니다. 아래 코드를 추가해 봅시다.

```jsx
<div>
  <button style={{ backgroundColor: 'red' }}>change to blue!</button>
</div>
```

<aside>
💡 JSX 에서 마크업에 표현식을 넣고싶다면 중괄호를 사용해야합니다.

</aside>

1. 다시 테스트를 돌려봅시다.

1. 이제 기능을 추가해봅시다. 버튼을 클릭했을 때 색이 변하는지 확인하는 테스트입니다.

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
```

- import 구문에 fireEvent를 추가했습니다. 가상돔과의 상호작용이 가능하도록 하는 객체입니다. 계속해서 아래 코드를 추가합니다.

```jsx
fireEvent.click(button);
expect(button).toHaveStyle({ backgroundColor: 'blue' });
expect(button.textContent).toBe('change to red!');
```

1. 테스트에 실패합니다.

- 아직 버튼을 클릭했을 때의 기능을 추가하지 않았기 때문입니다. useState 함수를 통해 현재의 버튼 색을 저장하도록 하겠습니다. App.js 상단에 import 구문을 추가합니다.

```jsx
import { useState } from 'react';
```

- useState 함수는 두 가지 요소를 가지는 배열을 반환합니다. 첫번째 요소는 state의 값, 두번째는 state의 값을 설정하는 함수입니다.

```jsx
const [buttonColor, setColor] = useState('red');
```

- ‘red’ 문자열이 buttonColor 상수의 값이 됩니다.
  setColor 는 buttonColor 상수의 값을 바꿀 수 있는 함수를 참조합니다.

1. 이제 이벤트를 달아보겠습니다.

```jsx
const [buttonColor, setColor] = useState('red');
const newColor = buttonColor === 'red' ? 'blue' : 'red';

return (
  <div>
    <button
      style={{ backgroundColor: buttonColor }}
      onClick={() => setColor(newColor)}
    >
      change to {newColor}!
    </button>
  </div>
);
```

1. 테스트를 돌려보고 결과를 확인합니다.

1. 이제 npm start로 실제로 잘 동작하는지 확인해볼 단계입니다.
