---
chapter: 비동기 통신
title: AJAX
date: 2024-04-30
---

## 1. AJAX 의 탄생

때는 1990년대…

OS 시장의 절대 강자 마이크로소프트(줄여서 마소)가 Internet Explorer3 를 만들 때 즈음, Windows OS에 JAVA언어를 기반으로 한 기능들을 만들고 있었습니다.

그리고 JAVA에 대한 권리를 가지고 있던 썬마이크로시스템즈는 로열티를 지불하지 않고 무단으로 JAVA를 사용해 이득을 취했던 마소를 고소합니다.

![썬마이크로시스템즈의 로고. 소프트웨어 시장의 숨은 강자였으나 닷컴버블의 여파를 피하지 못하고 오라클에 인수 합병되어 사라졌습니다.](15%20AJAX%2028e639cede984e12aeff37c2200eaad9/Untitled.png)

썬마이크로시스템즈의 로고. 소프트웨어 시장의 숨은 강자였으나 닷컴버블의 여파를 피하지 못하고 오라클에 인수 합병되어 사라졌습니다.

치열한 법정 공방 끝에 결국 마소가 패배하고, Windows OS에서 JAVA와 관련된 것들을 제거했어야 했습니다.

이때 JAVA에 많은 의존을 하고 있던 앱이 바로 이메일을 보내기 위해 만들어진 어플리케이션인 <Outlook> 이었습니다.

![**마이크로소프트 아웃룩. 이메일 전송과 사용자 일정관리에 특화된 앱입니다.**](15%20AJAX%2028e639cede984e12aeff37c2200eaad9/Untitled%201.png)

**마이크로소프트 아웃룩. 이메일 전송과 사용자 일정관리에 특화된 앱입니다.**

기존 자바로 작동하던 몇 가지 기능을 자바스크립트로 대신하기로 결정한 마소는 새로운 JS 객체를 탄생시키게 되는데요, 그때 탄생한 것이 바로 ActiveXObject 입니다.

ActiveXObject의 핵심 기능이 바로 JS코드를 통해 HTTP 요청을 서버로 보내고 응답을 받을 수 있었다는것 입니다.

덕분에 브라우저는 이전처럼 페이지를 리프레쉬 하지 않아도 HTTP 요청을 보내 데이터를 전달받아 데이터를 갱신할 수 있었습니다. 이후, 이를 이용한 본격적인 웹 앱들이 등장하기 시작합니다. 대표적으로 한번에 수백명에게 메일을 보내는 것이 가능한 최초의 서비스인 Gmail, 실시간으로 화면을 업데이트하면서 지도를 볼 수 있게 한 Google Maps 등의 앱 들이 크게 히트를 치기 시작합니다.

시간이 흘러 ActiveXObject는 XMLHttpRequest라는 이름으로 업데이트 되었고,

2005년에 이르러 제시 제임스 게럿(Jesse James Garrett)이라는 개발자가 이러한 JS 기술을 이용해 비동기적으로 서버와 통신할 수 있는 방법들을 묶어 AJAX라고 명명하여 부르기 시작했습니다.([https://designftw.mit.edu/lectures/apis/ajax_adaptive_path.pdf](https://designftw.mit.edu/lectures/apis/ajax_adaptive_path.pdf))

<aside>
🧐 그럼 AJAX가 나오기 이전에는 서버와 통신이 어떤 식으로 이루어졌었나요?
AJAX가 나오기 이전에는 클라이언트가 데이터를 서버에 요청하는 방법은 브라우저 주소창에 특정 URL을 입력하거나, HTML 요소인 <a> 혹은 <form>을 이용하는것 이었습니다.

1. 서버는 요청 받은 데이터와 함께 데이터가 포함되어 있는 HTML 파일을 같이 전송하였습니다. 이것은 필요한 데이터만 받아오는것에 비해 엄청나게 비효율적이었고,

   ![마치 작고 귀여운 아기 벨로시랩터 레고가 가지고 싶다면 5만원짜리 세트로 구입해야만 하는것과 비슷합니다(…)](15%20AJAX%2028e639cede984e12aeff37c2200eaad9/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.39.39.png)

   마치 작고 귀여운 아기 벨로시랩터 레고가 가지고 싶다면 5만원짜리 세트로 구입해야만 하는것과 비슷합니다(…)

2. HTML파일 자체가 교체되는 방식이기 때문에 화면이 랜더링 되면서 번쩍이는 현상도 함께 나타났습니다.

   ![스크린샷 2023-04-23 오전 1.37.22.png](15%20AJAX%2028e639cede984e12aeff37c2200eaad9/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.37.22.png)

</aside>

## 3. XMLHttpRequest

서버와의 비동기 통신을 가능하게 하는 여러 기능들을 가진 자바스크립트 객체입니다.

```jsx
// XHR 객체를 생성합니다.
const requestObj = new XMLHttpRequest();
requestObj.open('GET', 'url'); // 요청을 초기화합니다. 통신방법과 요청을 발신할 대상의 주소를 전달합니다.
requestObj.onreadystatechange = () => {
  // readystate 가 변화하면 실행되는 이벤트리스너 입니다.
  // readystate : 요청을 보내는 클라이언트의 상태를 의미합니다.
  // readystate의 종류
  // 0 (UNSENT) - XHR 객체가 생성되었지만 아직 초기화되지 않았습니다.
  // 1 (OPENED) - open()함수가 호출되어 요청이 초기화되었습니다.
  // 2 (HEADERS_RECEIVED) - send()함수가 호출되었습니다.
  // 3 (LOADING) - 데이터를 다운받는 중 입니다.
  // 4 (DONE) - 통신이 완료되었습니다.
  if (requestObj.readyState == 4 && requestObj.status == '200') {
    const result = requestObj.responseText;
  }
};
requestObj.send(); // 서버로 요청을 보냅니다. send 메소드가 실행되어야만 우리가 위에서 설정한 내용들이 의미를 가지게 됩니다.
```

<aside>
🧐 requestObj.status
readyState가 서버와의 통신상태를 나타낸다면, status는 서버의 응답상태를 나타냅니다.
200은 요청한 내용이 성공적으로 완료되었음을 의미합니다.
[https://developer.mozilla.org/ko/docs/Web/HTTP/Status](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)

</aside>

<aside>
🧐 **readyState와 status**

개발자들은 종종 readyState와 status를 혼동합니다. 간단한 비유로 설명해보겠습니다.

배가 너무 고파서 1시간 후에 집에서 저녁을 먹기 위해 피자를 주문해야 합니다. 그래서 배달앱을 꺼내 피자를 한판 주문합니다.

이때 배달하는 사람이 피자 배달을 완료했는지, 아니면 배달 중인지 추적합니다. (readyState)

피자가 집에 도착하고 피자가 올바르게 만들어졌는지 확인합니다. 피자가 타지 않았는지, 재료를 잘못 넣었는지, 또는 주문대로 내가 원하는 피자가 맞는지 확인합니다. (status)

결론적으로, readyState === 4 (즉, 피자가 집에 도착했음)이고 status === 200 (즉, 피자가 올바르게 만들어졌음)인 경우에만 모든 통신이 계획대로 잘 진행되었다는 것을 의미합니다.

</aside>

실제 코드로 작성해봅시다. 버튼을 누르면 데이터를 비동기적으로 가져와 화면에 표시하는 앱을 만들어 보겠습니다.
