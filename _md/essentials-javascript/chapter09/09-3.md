---
chapter: 함수 활용하기
title: 다양한 함수
date: 2024-04-30
---

# 1. 콜백함수

콜백 함수는 다른 함수의 매개변수로 전달되어 실행되는 함수를 의미합니다. 콜백 함수를 이용하면 함수의 실행 순서를 제어할 수 있어 이벤트 처리, 배열 메서드, 비동기 처리 등 다양한 상황에서 사용됩니다.

```javascript-exec
function sum(x, y, callback) {
  callback(x + y);
  return x + y;
}

function consolePrint(text) {
  console.log('콜백 함수: ', text);
}

sum(10, 20, consolePrint);
```

```javascript-exec
function square(x) {
  return x ** 2;
}

let arr = [1, 2, 3, 4, 5];
console.log(arr.map(square));

arr.map((x) => x ** 2);
```

:::div{.callout}
**first class 언어**  
JavaScript에서는 함수를 변수에 할당할 수 있습니다. 이러한 함수를 변수에 할당한 후, 해당 변수를 매개변수로 다른 함수에 전달하거나, 다른 함수의 반환값으로 사용할 수 있습니다. 이렇게 하면 함수를 조합하여 더 복잡한 기능을 수행할 수 있습니다. 이러한 기능을 지원하는 언어를 first class 언어라고 하며 Python, Ruby등이 이러한 언어군에 속합니다.
:::

# 2. 재귀함수

재귀함수(Recursive function)는 함수가 자기 자신을 호출하는 함수를 뜻합니다. 재귀 함수를 이용하면 반복문을 사용하지 않고도 반복적인 작업을 수행할 수 있습니다. 즉, 반복문으로 해결할 수 있는 문제는 재귀함수로 해결할 수 있습니다.
팩토리얼 함수를 반복문으로 구현하면 다음과 같이 작성할 수 있습니다.

```javascript-exec
function factorial(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
factorial(5);
```

재귀 함수로 구현하면 다음과 같이 작성할 수 있습니다.

```javascript-exec
function factorial(n) {
if (n <= 1) {
  return 1;
}
return n * factorial(n - 1);
}
factorial(5);
// factorial(5) == 5 * factorial(4) == 5 * 24
// factorial(4) == 4 * factorial(3) == 4 * 6
// factorial(3) == 3 * factorial(2) == 3 * 2
// factorial(2) == 2 * factorial(1) == 2 * 1
// factorial(1) == 1
```

재귀 함수를 작성할 때 주의할 점은, 재귀 호출이 무한히 반복되지 않도록 종료 조건을 반드시 설정해야 합니다. 종료 조건이 없으면 함수가 무한히 호출되어 스택 오버플로우가 발생할 수 있습니다. 위 코드의 팩토리얼 함수에서 종료 조건은 `n <= 1`입니다.

1부터 n까지의 합을 구하는 sigma 함수를 재귀함수로 구현해보겠습니다.

```javascript-exec
function sigma(n) {
  if (n <= 1) {
    return n;
  }
  return n + sigma(n - 1);
}
sigma(5);
// sigma(5) == 5 + sigma(4) == 5 + 10
// sigma(4) == 4 + sigma(3) == 4 + 6
// sigma(3) == 3 + sigma(2) == 3 + 3
// sigma(2) == 2 + sigma(1) == 2 + 1
// sigma(1) == 1
```

# 3. 즉시 실행함수

함수 챕터에서 잠시 다뤘었던 즉시 실행 함수에 대해 다시 한번 알아보겠습니다. 즉시 실행 함수는 함수를 선언함과 동시에 실행하는 함수입니다. 즉시 실행 함수는 함수를 선언함과 동시에 실행하기 때문에 외부에서 함수를 호출할 필요가 없는 경우에 사용합니다. 또한 즉시 실행 함수는 function scope를 이용하기 때문에 메모리 효율적입니다.

즉시 실행 함수를 작성하는 방법은 다음과 같습니다.

```javascript-exec
// 익명 즉시 실행 함수
(function () {
  let a = 1;
  let b = 2;
  return a + b;
})();
```

즉시 실행 함수는 함수를 선언함과 동시에 실행하기 때문에 함수 이름을 작성하지 않아도 됩니다. 함수 이름을 작성하지 않는 것이 일반적입니다. 메모리를 효율적으로 관리하기 위해 바로 실행해야 하는 함수는 즉시 실행 함수로 작성합니다.

```javascript-exec
// 기명 즉시 실행 함수
(function func() {
  let a = 3;
  let b = 5;
  return a * b;
})();

func(); // ReferenceError: func is not defined
```

# 4. 클로저

## 4.1. 클로저란?

클로저란 **폐쇠된 공간 안에 데이터에 접근하기 위한 테크닉**으로, 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 클로저를 이용하면 외부 함수에 대한 접근 권한을 내부 함수에 위임함으로서 폐쇠된 공간 안의 데이터에 접근할 수 있도록 하는 테크닉입니다. 코드와 함께 살펴보겠습니다. 아래 예제에서는 add5와 add10이 클로저입니다.

```javascript-exec
function makeAdder(x) { // 외부함수
  let y = 1; // 폐쇄된 공간의 데이터
  return function (z) { // 내부함수
    return x + y + z;
  };
}

//클로저에 x와 y의 환경이 각각 저장됨
let add5 = makeAdder(5);
let add10 = makeAdder(10);

//함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
console.log(add5(2)); // 8 (x:8 + y:1 + z:2)
console.log(add10(2)); // 13 (x:10 + y:1 + z:2)
```

그렇다면 왜 클로저를 사용할까요? 클로저를 사용하면 특정 변수나 함수를 외부에서 접근할 수 없도록 숨길 수 있습니다. 이를 통해 private 변수와 메서드를 구현할 수 있습니다.

::a[Closure | MDN]{class="btn-link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures" target="\_blank"}

```javascript-exec
function exponent(x) {
  function multiplier(y) {
    return y ** x;
  }
  return multiplier;
}

var square2 = exponent(2);
var square3 = exponent(3);

square2(10);
square3(10);
```

```javascript-exec
function exponent(x) {
  return function (y) {
    return y ** x;
  };
}

var square2 = exponent(2);
var square3 = exponent(3);

square2(10);
square3(10);
```

자바스크립트 변수의 스코프는 함수가 선언된 위치를 기준으로 결정됩니다. `b()` 함수가 호출된 위치와 관계없이 `b()` 함수는 전역 스코프에 있는 x를 참조합니다.

```javascript-exec
const x = 100;

function a() {
  const x = 1;
  b();
}

function b() {
  console.log(x);
}

a(); // 100
b(); // 100

```

반면 클로저를 사용하면 다른 결과를 얻을 수 있습니다. 다음 코드에서 `b()` 함수는 `a()` 함수 내부에서 선언된 `x`를 참조합니다. 이것이 바로 클로저의 핵심 개념입니다. 함수가 선언된 위치를 기준으로 스코프가 결정되는 자바스크립트의 특성을 이용하여 a 함수 내부에서 선언된 x를 b 함수에서 참조할 수 있습니다.

```javascript-exec
const x = 100;

function a() {
  const x = 1;
  function b() {
    console.log(x);
  }
  b();
}

a(); // 1
```

즉, 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 클로저를 이용하면 함수 내부의 변수를 외부에서 접근할 수 없도록 숨기고, 함수 외부에서 함수 내부의 변수에 접근할 수 있도록 할 수 있습니다.

다음 코드에서 createCounter는 내부 함수(클로저)를 반환하며, 반환된 함수는 지역 변수인 count에 접근할 수 있습니다. 이를 통해 count 변수를 외부에서 접근할 수 없도록 숨기고, 함수 외부에서 count 변수에 접근할 수 있도록 할 수 있습니다.
createCounter로 만들어진 counter와 counter2는 서로 다른 렉시컬 환경을 가지고 있기 때문에 count 변수가 서로 다른 값을 가집니다.

```javascript-exec
function createCounter() {
    let count = 0;

    return function() {
        count++;
        console.log(count);
    };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
counter(); // 3

const counter2 = createCounter();
counter2(); // 1
counter2(); // 2

```

## 4.2. 쓰로틀링(Throttling)

클로저의 실제 활용 사례 중 하나로 **'쓰로틀링'(Throttling)** 이 있습니다. 쓰로틀링은 함수 호출의 빈도를 제어하는 기술입니다.

::a[Throttling in JavaScript Easiest Explanation]{class="btn-link" href="https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081" target="\_blank"}

```javascript-exec
function throttle(mainFunction, delay) {
  let timerFlag = null;

  return (...args) => {
    if (timerFlag === null) {
      mainFunction(...args);
      timerFlag = setTimeout(() => {
        timerFlag = null;
      }, delay);
    }
  };
}
```

위 함수는 `mainFunction`을 `delay` 시간 동안 한 번만 실행하도록 하는 `throttle` 함수입니다. 이 함수는 `mainFunction`을 실행하고 `delay` 시간 동안 다시 실행되지 않도록 합니다. 이를 통해 함수 호출의 빈도를 제어할 수 있습니다.

다음과 같이 스크롤 이벤트에 쓰로틀링을 적용하여, 스크롤 동작이 발생하더라도 5초에 한 번만 `fetchData` 함수가 실행되도록 할 수 있습니다.

```javascript-exec
function fetchData() {
  console.log('데이터를 가져오는 중...');
  setTimeout(() => {
    console.log('데이터 가져오기 완료!');
  }, Math.random() * 1000);
}

const throttledFetchData = throttle(fetchData, 5000);
window.addEventListener('scroll', throttledFetchData);
```

# 5. 생성자 함수 (Constructor)

자바스크립트에서 객체를 생성하는 방식은 대표적으로 두 가지가 있습니다. 하나는 중괄호(`{}`)를 사용한 객체 리터럴 표현식, 그리고 나머지가 생성자 함수를 이용한 방식입니다. 생성자 함수는 사용자 정의 객체를 생성할 때 사용되는 함수입니다.
생성자 함수를 이용하면 동일한 프로퍼티를 가지는 객체를 여러 개 생성할 수 있습니다. 또한 객체지향 프로그래밍에서 배울 프로토타입을 이용하여 메모리 효율을 높일 수 있습니다.

```jsx
let book = {
  책이름: '자바스크립트 에센셜',
  책가격: 15000,
  저자: ['웨이드', '하티'],
  출판일: '2024.08.24',
};
// 책이 100권이라면 모든 객체를 일일이 작성해야 하는 문제가 발생

function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = new Book('HTML/CSS 에센셜', 20000, ['로지', '지지'], '2024.7.31');
let book2 = new Book('견고한 Python', 300000, ['라이캣'], '2023.11.30');
let book3 = new Book('웹/네트워크/HTTP', 0, ['라이캣'], '2024.4.26');

console.log(book1, book2, book3);
```

생성자 함수를 작성할 때는 일반 함수와 구분하기 위해 함수 이름의 첫 글자를 대문자로 작성합니다. 관습적으로 파스칼 케이스(PascalCase)를 이용하여 함수 이름을 작성합니다. 생성자 함수를 호출할 때는 `new` 연산자와 함께 호출합니다. 생성자 함수를 호출하면 객체가 생성되고, 이때 생성된 객체를 인스턴스(instance)라고 합니다. `new` 연산자는 생성자 함수의 `this`가 인스턴스를 바라보도록 만들어줍니다.

실제로는 다음과 같이 동작합니다. 생성자 함수를 호출하면 빈 객체가 생성되고, `this`에 바인딩됩니다. 그리고 함수 내부의 코드가 실행되면서 `this`에 프로퍼티가 추가됩니다. 마지막으로 `this`가 반환됩니다.

```javascript-exec
function Book(책이름, 책가격, 저자, 출판일) {
  // this = {}
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
  // return this
}
```

이때 `new` 연산자를 사용하지 않으면 생성자 함수가 일반 함수로 동작합니다. 이때는 `this`가 전역 객체를 바라보게 됩니다. 이는 전역 객체에 프로퍼티를 추가하는 문제가 생길 수 있으니 주의해야 합니다.

```javascript-exec
function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = Book('HTML/CSS 에센셜', 20000, ['로지', '지지'], '2024.7.31');
let book2 = Book('견고한 Python', 300000, ['라이캣'], '2023.11.30');
let book3 = new Book('웹/네트워크/HTTP', 0, ['라이캣'], '2024.4.26');

// book1과 book2에는 어떤 값이 출력될까요?
console.log(book1);
console.log(book2);
console.log(book3);
```

이처럼 생성자 함수를 통해 생성된 객체는 같은 **프로퍼티**와 **메서드**를 가지게 됩니다. 이와 관련해서 객체지향 프로그래밍 챕터에서 좀 더 자세히 얘기해보겠습니다.
