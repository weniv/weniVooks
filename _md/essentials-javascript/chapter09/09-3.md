---
chapter: 함수 활용하기
title: 스코프와 클로저
date: 2024-04-30
---

# 1. 호이스팅

## 1.1. 호이스팅이란?

![](/images/essentials-javascript/chapter09/01-1.png)

이렇게 무언가를 끌어올리는 장치를 영어로 호이스트(hoist)라고 합니다.

호이스팅(한국어로 번역하면 ‘끌어 올리기’)은 변수나 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 현상을 말합니다. 즉, 코드에서 변수나 함수를 선언하기 전에 해당 변수나 함수를 사용할 수 있는 것처럼 보이는 현상을 의미합니다.
이러한 현상이 발생하는 이유는 자바스크립트 엔진이 코드를 실행하기 전에 코드를 평가하는 과정에서 선언문들은 먼저 실행하기 때문입니다. 이 때문에 변수나 함수의 선언문이 해당 스코프의 최상단으로 끌어올려지는 것처럼 동작하게 됩니다.

```jsx
console.log(x);
var x = 10;

sayHi(); // "Hello, weniv!"
function sayHi() {
  console.log('Hello, weniv!');
}
```

위의 코드에는 변수 선언문과 함수 선언문이 정의되어 있습니다. 그리고 해당 변수와 함수를 선언하기 전에 각각 참조하고 있습니다. 하지만 실행 결과에서는 변수 x는 `undefined`로, 함수 sayHi는 "Hello, weniv!"를 출력하게 됩니다. 이것은 호이스팅에 의해 변수와 함수가 해당 스코프의 최상단으로 끌어올려졌기 때문입니다.

하지만, 호이스팅은 변수의 선언만을 끌어올리고, 변수의 초기화나 할당은 끌어올려지지 않습니다. var의 경우에는 호이스팅과 동시에 암묵적으로 `undefine` 값으로 초기화합니다. `function`으로 선언한 함수는 전체를 끌어올리기 때문에 함수를 선언하기 전에 함수를 호출할 수 있습니다.

## 1.2. 일시적 사각지대(Temporal Dead Zone)

비교적 최근에 등장한 let, const, class를 이용한 선언문은 **일시적 사각지대(Temporal Dead Zone)** 라는 것을 만들어서 호이스팅은 발생하지만 변수를 사용할 수 없는 구간이 생깁니다. `undefined`로 암묵적 초기화가 일어나지 않기 때문에, 사용자가 직접 작성한 선언문 또는 할당문이 실행되기 전에 값에 접근하면 오류가 발생합니다. 이렇게 변수를 사용할 수 없는 구간을 일시적 사각지대(TDZ)라고 합니다.

```javascript-exec
console.log(y);
console.log(z);
let y = 20;
const z = 30;
```

위의 코드에서 변수 y와 z는 선언문을 만난 이후에 초기화 되어 TDZ에서 벗어나 값을 사용할 수 있습니다. 하지만 선언문을 만나기 전에 변수 y와 z를 사용하면 에러가 발생합니다.

## 1.3. 함수 표현식의 호이스팅

함수 표현식은 변수 선언만을 끌어올리기 때문에 함수 할당문 전에 함수를 호출하면 에러가 발생합니다. 이와 반대로 함수 선언문은 전체를 끌어올리기 때문에 위의 코드처럼 함수를 선언하기 전에 함수를 호출할 수 있습니다.

```javascript-exec
sayHello(); // Error
const sayHello = function() {
  console.log('Hello!');
};
```

# 2. 스코프 바인딩과 체이닝

## 2.1 실행 컨텍스트

자바스크립트의 코드는 실행하기 전에 평가하는 과정을 거치게 됩니다. 이때 실행 컨텍스트(Execution Context)가 생성되어 코드를 평가합니다. 실행 컨텍스트는 코드가 실행되는 환경을 의미하며, 코드가 실행되는 동안 변수나 함수, 객체 등을 저장하고 관리합니다. 코드의 평가 과정에서 식별자는 이 실행 컨텍스트의 렉시컬 환경에서 관리됩니다.

다음 코드를 실행하면 평가 과정에서 실행 컨텍스트가 생성되고, 변수 a와 함수 func가 전역 렉시컬 환경에 등록됩니다. 이후 함수 func가 실행되면 새로운 실행 컨텍스트가 생성되고, 변수 b가 함수의 렉시컬 환경에 저장됩니다. 이 렉시컬 환경을 통해 변수의 범위, 즉 스코프를 결정하게 됩니다. 이것을 스코프 바인딩이라고 합니다.

```javascript-exec
const a = 10;

function func() {
  const b = 20;
  console.log(a + b);
}
func();
```

이 실행 컨텍스트가 종료되면, 스코프는 가비지 컬렉션에 의해 메모리에서 제거됩니다. 이렇게 실행 컨텍스트는 코드의 실행 환경을 관리하고, 스코프를 통해 변수의 범위를 결정합니다.

## 2.2 스코프 체이닝

이 렉시컬 환경에는 식별자와 연결된 값도 저장하지만, 상위 스코프에 대한 참조도 저장합니다. 이를 통해 스코프 체인을 구성하고, 변수를 찾는 과정에서 상위 스코프로 이동할 수 있습니다. 다음 코드를 실행하면 총 3개의 렉시컬 환경이 생성됩니다. 전역 변수의 렉시컬 환경에는 x가, outer 함수가 호출된 시점에서 outer 함수의 렉시컬 환경에는 y가, inner 함수가 호출된 시점에서 inner 함수의 렉시컬 환경에는 z가 저장됩니다.

이 렉시컬 환경들은 상위 스코프에 대한 참조를 저장합니다. 즉 inner의 렉시컬 환경의 상위 스코프인 outer의 렉시컬 환경의 참조가 저장되어 있습니다. outer는 상위 스코프인 전역 렉시컬 환경을 참조하고 있습니다. 이처럼 상위 스코프에 대한 참조를 통해 스코프 체인을 구성합니다.
스코프 체이닝을 통해 여러 스코프를 따라 변수를 찾을 수 있습니다. 자바스크립트 엔진은 변수를 찾을 때 가장 가까운 스코프부터 시작하여 상위 스코프로 이동하며 변수를 탐색합니다. 같은 이름의 변수가 여러 스코프에 존재할 경우, 가장 가까운 스코프의 변수를 사용합니다.

```javascript-exec
let x = 'global';

function outer() {
   let y = 'outer';

   function inner() {
      let z = 'inner';
      console.log(x, y, z);
   }

   inner();
}
outer();
```

# 3. 클로저

## 3.1. 클로저란?

클로저(Closure)는 **함수와 그 함수가 선언된 렉시컬 환경의 조합** 입니다. 이는 함수가 자신이 생성될 당시의 환경을 기억하고 접근할 수 있게 해주는 메커니즘입니다. 클로저를 이용하면 내부 함수가 외부 함수의 변수에 접근할 수 있게 되어, 일종의 '폐쇄된 공간' 안의 데이터를 안전하게 다룰 수 있습니다.

코드와 함께 살펴보는게 보다 이해하기 쉽습니다. 다음 코드에서 makeAdder를 호출하면 함수의 렉시컬 환경이 생성이 되고, 이곳에 x(5)와 y(1)의 값이 저장됩니다. 그리고 add5를 호출하면 내부 함수가 실행되면서 x, y를 가지는 렉시컬 환경을 참조하게 됩니다. 이를 통해 add5 함수는 외부 함수의 변수에 접근할 수 있게 되는 것입니다.

```javascript-exec
function makeAdder(x) { // 외부함수
  let y = 1; // 폐쇄된 공간의 데이터
  return function (z) { // 내부함수
    return x + y + z;
  };
}

// 클로저에 x와 y의 환경이 각각 저장됨
let add5 = makeAdder(5);
let add10 = makeAdder(10);

// 함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
console.log(add5(2)); // 8 (x:8 + y:1 + z:2)
console.log(add10(2)); // 13 (x:10 + y:1 + z:2)
```

그렇다면 왜 클로저를 사용할까요? 클로저를 사용하면 특정 변수나 함수를 외부에서 접근할 수 없도록 숨길 수 있습니다. 이를 통해 private 변수와 메서드를 구현할 수 있습니다.

::a[Closure | MDN]{class="btn-link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures" target="\_blank"}

```javascript-exec
function exponent(x) {
  function multiplier(y) {
    return y ** x;
  }
  return multiplier;
}

const square2 = exponent(2);
const square3 = exponent(3);

square2(10);
square3(10);
```

자바스크립트 변수의 스코프는 함수가 선언된 위치를 기준으로 결정됩니다. `b()` 함수가 호출된 위치와 관계없이 `b()` 함수는 전역 스코프에 있는 x를 참조합니다.

```javascript-exec
const x = 100;

function a() {
  const x = 1;
  b();
}

function b() {
  console.log(x);
}

a(); // 100
b(); // 100

```

반면 클로저를 사용하면 다른 결과를 얻을 수 있습니다. 다음 코드에서 `b()` 함수는 `a()` 함수 내부에서 선언된 `x`를 참조합니다. 이것이 바로 클로저의 핵심 개념입니다. 함수가 선언된 위치를 기준으로 스코프가 결정되는 자바스크립트의 특성을 이용하여 a 함수 내부에서 선언된 x를 b 함수에서 참조할 수 있습니다.

```javascript-exec
const x = 100;

function a() {
  const x = 1;
  function b() {
    console.log(x);
  }
  b();
}

a(); // 1
```

즉, 클로저를 이용하면 함수 내부의 변수를 외부에서 접근할 수 없도록 숨기고, 함수 외부에서 함수 내부의 변수에 접근할 수 있도록 할 수 있습니다.

다음 코드에서 createCounter는 내부 함수(클로저)를 반환하며, 반환된 함수는 지역 변수인 count에 접근할 수 있습니다. 이를 통해 count 변수를 외부에서 접근할 수 없도록 숨기고, 함수 외부에서 count 변수에 접근할 수 있도록 할 수 있습니다.
createCounter로 만들어진 counter와 counter2는 서로 다른 렉시컬 환경을 가지고 있기 때문에 count 변수가 서로 다른 값을 가집니다.

```javascript-exec
function createCounter() {
    let count = 0;

    return function() {
        count++;
        console.log(count);
    };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
counter(); // 3

const counter2 = createCounter();
counter2(); // 1
counter2(); // 2

```

## 4.2. 쓰로틀링(Throttling)

클로저의 실제 활용 사례 중 하나로 **'쓰로틀링'(Throttling)** 이 있습니다. 쓰로틀링은 함수 호출의 빈도를 제어하는 기술입니다.

::a[Throttling in JavaScript Easiest Explanation]{class="btn-link" href="https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081" target="\_blank"}

```javascript-exec
function throttle(mainFunction, delay) {
  let timerFlag = null;

  return (...args) => {
    if (timerFlag === null) {
      mainFunction(...args);
      timerFlag = setTimeout(() => {
        timerFlag = null;
      }, delay);
    }
  };
}
```

위 함수는 `mainFunction`을 `delay` 시간 동안 한 번만 실행하도록 하는 `throttle` 함수입니다. 이 함수는 `mainFunction`을 실행하고 `delay` 시간 동안 다시 실행되지 않도록 합니다. 이를 통해 함수 호출의 빈도를 제어할 수 있습니다.

다음과 같이 스크롤 이벤트에 쓰로틀링을 적용하여, 스크롤 동작이 발생하더라도 5초에 한 번만 `fetchData` 함수가 실행되도록 할 수 있습니다.

```javascript-exec
function fetchData() {
  console.log('데이터를 가져오는 중...');
  setTimeout(() => {
    console.log('데이터 가져오기 완료!');
  }, Math.random() * 1000);
}

const throttledFetchData = throttle(fetchData, 5000);
window.addEventListener('scroll', throttledFetchData);
```

```

```
