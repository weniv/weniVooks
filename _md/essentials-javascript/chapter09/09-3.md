---
chapter: 비동기 프로그래밍
title: 동기와 비동기
date: 2024-04-30
---

## 2.2. Promise

Promise는 이름에서 알 수 있듯이 **약속을 하는 것**입니다. 그렇다면 무엇을 약속할까요?

우리가 스타벅스에서 커피를 주문하는 상황을 생각해봅시다.

1. 스타벅스에 가서 커피를 주문할 때, 카운터에서 잠시 고민을 하겠죠? (pending : 보류중인, 대기중인)
2. 주문을 받은 점원은 우리에게 “대략 5 ~ 10분 정도 커피를 내리는 시간이 필요합니다. 완료되면 알려드리겠습니다.\_” 라고 얘기할겁니다. 우리에게 **약속(promise)** 하는 것입니다. 이때 약속은 우리에게 커피를 주거나 또는 못 주거나에 대한 **결과를 알려준다는 것** 입니다.
3. 우리는 커피가 만들어지는 동안(Asynchronously) 공부하기 적당한 테이블을 찾고, 노트북을 꺼내고, 주문이 완료되기를 기다립니다.

4.1. 잠시 뒤 커피가 만들어져 나옵니다! 즉, 우리의 **주문이 해결되었고(resolved)**, 약속이 이루어졌습니다. (fulfilled : 약속을 이행, 완수)

4.2. 그런데 어쩌면 이런 상황이 발생할 수도 있습니다. 점원이 급하게 와서 사용할 원두가 떨어졌다고 알려줄 수도 있겠죠. 그렇다면 약속이 이뤄지지 않은 즉, **거절된 상태(rejected)**가 됩니다.

이처럼 Promise를 이용하여 비동기 연산을 다룰 수 있습니다. 비동기 작업의 결과는 즉시 알 수 없지만 '결과가 준비되면 이행되거나 거절될 것이라고 약속을 하는 것'입니다. 위의 예시를 Promise의 세 가지 상태로 다시 나타내면 다음과 같습니다.

- **대기 (Pending)** -> resolve() -> **성공 (Fulfilled)**
- **대기 (Pending)** -> reject() -> **실패 (Rejected)**

위의 예시에 나온 키워드들을 잘 생각해보면서 실제 코드로 작성해 보겠습니다.

```jsx
// 커피를 주문하는 프로미스 객체를 생성합니다. 생성자에는 약속을 지키기 위한 resolve와, 약속을 지키지 못했을 때를 대비한 reject 두 가지를 인자로 전달합니다.
// 프로미스 객체를 생성하는 순간 프로미스 생성자함수의 콜백 함수가 실행됩니다. 이를 실행자(executor)라 부릅니다.
const orderCoffee = new Promise((resolve, reject) => {
  const requestObj = new XMLHttpRequest();
  requestObj.open('GET', 'http://test.api.weniv.co.kr/');
  requestObj.onreadystatechange = () => {
    if (requestObj.readyState === 4) {
      if (requestObj.status === 200) {
        const result = requestObj.responseText;
        // resolve 메소드가 실행되면 then 메소드가 자동으로 호출됩니다.
        resolve(result);
      } else {
        // resolve 메소드 호출이 없는 상태에서 reject 메소드가 실행되면 catch 메소드가 자동으로 호출됩니다.
        reject(
          new Error(
            `커피주문이 정상적으로 이뤄지지 않았습니다.: ${requestObj.status}`,
          ),
        );
      }
    }
  };
  requestObj.send();
});

// 이 부분에 주목해주세요. then 메소드를 사용하면 비동기 코드를 마치 동기적인 코드처럼 작성할 수 있습니다. 앞에서 작성한 XHR 코드와 비교해보는것도 좋습니다.
// resolve 메소드가 실행될때 전달된 인자는 then 메소드의 콜백함수의 인자로 전달됩니다.
orderCoffee
  .then((asyncResult) => {
    console.log(asyncResult);
    console.log('약속이 이루어졌습니다.');
    return asyncResult;
  })
  .catch((error) => {
    // then 메소드는 프라미스 객체를 반환하기 때문에 catch 메소드를 이어서 쓰는것이 가능합니다.
    // resolve 메소드와 마찬가지로 reject 메소드가 실행될때 전달된 인자는 catch 메소드의 콜백함수의 인자로 전달됩니다.
    console.log(error);
  });
```

정리해보면, 프로미스는 비동기 코드를 마치 동기적인 코드처럼 작성할 수 있습니다. 우리는 약속을 의미하는 Promise 객체를 만들었고, 이 약속은 이행되거나(fulfilled), 거절되거나(reject) 둘 중에 한 가지 결과만을 가지게 될겁니다. (물론 두 가지 모두 이뤄지지 않는다면 계속 pending(대기중) 상태가 되겠지만, 실제로 이렇게 코드를 작성할 일은 없겠죠?)

때문에 통신의 결과는 코드상에서는 아직 알 수 없지만, ‘이행되거나 거절되거나 둘 중의 하나의 결과는 전달될거라 약속하고 작업을 진행하자!’ 라는 개념으로 만들어졌기 때문에 then과 catch를 이용해 동기적으로 코드를 이어 쓸 수 있는것 입니다.

::a[비동기(콜백함수, 프로미스, await/async, fetch)]{class="btn-link" href="https://www.notion.so/8-await-async-fetch-835e5806f6be444aa02ccfd38cb7a9b7?pvs=21" target="\_blank"}

::a[알잘딱깔센 JavaScript 비동기 프로그래밍 - 비동기 너 내 동기가 돼라]{class="btn-link" href="https://www.notion.so/JavaScript-e171d97722484860aa5b162afae83cb1?pvs=21" target="\_blank"}
