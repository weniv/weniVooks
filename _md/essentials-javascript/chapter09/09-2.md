---
chapter: 함수 활용하기
title: 스코프와 호이스팅
date: 2024-04-30
---

# 1. 변수 범위, 스코프

스코프는 변수의 유효 범위를 나타냅니다. 유효 범위는 다른 말로 접근성과 생존 기간을 제어하는 ‘생존 범위’라고 할 수 있습니다. 즉, 변수가 어디서 접근 가능한지를 정의합니다. 자바스크립트에서는 주로 전역 스코프와 지역 스코프로 나누어집니다.

1. 전역 스코프(Global): 코드 어느 곳에서나 접근할 수 있는 변수
2. 지역 스코프(Local): 특정 코드 블록 내에서만 접근할 수 있는 변수

   1. 함수 스코프(Function): 함수 내에서만 접근할 수 있는 변수. `var`로 선언된 변수는 함수 스코프를 가집니다.
   2. 블록 스코프(Block): 블록 내에서만 접근할 수 있는 변수. `let`과 `const`로 선언된 변수는 블록 스코프를 가집니다.

## 1.1. var의 스코프

`var`로 선언된 변수는 **전역 스코프** 또는 **함수 스코프** 를 가집니다. 전역에서 선언된 변수는 전역 스코프로 어디서든 접근할 수 있습니다. 전역으로 선언한 변수는 전역 객체인 `window` 객체의 프로퍼티로 사용할 수 있습니다.

```javascript-exec
var value = 'hello';
function func1() {
   console.log(value);
}
func1();
console.log(window.value);
```

함수 내에서 선언된 변수는 함수 스코프를 가집니다. 함수 내에서 선언된 변수는 함수 외부에서 접근할 수 없습니다. 함수 내에서 선언된 변수는 함수 내부에서만 접근할 수 있습니다.

```javascript-exec
function func1() {
   var value = 'hello';
   console.log(value);
}
func1();
console.log(value); // 함수 밖에서는 value에 접근할 수 없습니다.
```

## 1.2. let과 const의 스코프

`let`과 `const`로 선언된 변수는 **블록 스코프** 를 가집니다. 블록 스코프는 중괄호(`{}`)로 둘러싸인 범위를 말합니다. 블록 스코프는 블록 내에서만 접근할 수 있는 변수를 말합니다. 블록 내에서 선언된 변수는 블록 외부에서 접근할 수 없습니다.

```javascript-exec
{
   let value = 'hello';
   console.log(value);
}
console.log(value); // 블록 밖에서는 val에 접근할 수 없습니다.
```

`let`과 `const`로 만든 변수는 블록 밖에서 접근할 수 없습니다. 다만 아래처럼 블록 밖에서 선언된 변수는 블록 안에서 접근이 가능합니다.

```javascript-exec
let value = 10;
{
   let value2 = 20;
   console.log(value); // 블록 안에서 val에 접근할 수 있습니다.
   console.log(value2);
}
console.log(value2); // 블록 밖에서는 val2에 접근할 수 없습니다.

```

`let`과 `const`를 전역에서 선언하더라도 전역 스코프를 갖지 않습니다. 전역에서 선언된 `let`과 `const`는 전역 객체인 `window` 객체의 프로퍼티로 사용할 수 없습니다.

## 1.3. 스코프의 특징

다음 코드에서 함수 안의 a 변수와 함수 밖의 a 변수는 완전히 다른 변수입니다. 함수 안의 a 변수는 함수가 종료되면 함수 스코프가 가비지 컬랙션으로 수거되기 때문에, 메모리상에서 자동으로 제거됩니다.

```javascript-exec
const func1 = function () {
  var a = 1;
  var b = 2;
  console.log(a + b);
};

var a = 20;
func1();
```

이처럼 스코프는 이름이 충돌하는 문제를 덜어주고, 자동으로 메모리를 관리합니다.

## 1.4. 스코프 체이닝

스코프 체인은 변수를 찾는 과정에서 여러 스코프를 탐색하는 것을 말합니다. 자바스크립트 엔진은 변수를 찾을 때 가장 가까운 스코프부터 시작하여 상위 스코프로 이동하며 변수를 탐색합니다.

```javascript-exec
let x = 'global';

function outer() {
   let y = 'outer';

   function inner() {
      let z = 'inner';
      console.log(x, y, z);
   }

   inner();
}

outer();
```

위의 예제에서 `inner` 함수는 자신의 스코프 -> `outer` 함수의 스코프 -> 전역 스코프 순으로 탐색하여 변수를 찾습니다. 따라서 `inner` 함수에서는 `x`, `y`, `z` 모두에 접근할 수 있습니다.
스코프 체인은 항상 안쪽 스코프에서 바깥쪽 스코프로 이동하며 변수를 찾습니다. 같은 이름의 변수가 여러 스코프에 존재할 경우, 가장 가까운 스코프의 변수를 사용합니다.

# 2. 호이스팅(Hoisting)

## 2.1. 호이스팅이란?

![](/images/essentials-javascript/chapter09/01-1.png)

이렇게 무언가를 끌어올리는 장치를 영어로 호이스트(hoist)라고 합니다.

호이스팅(한국어로 번역하면 ‘끌어 올리기’)은 변수나 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 현상을 말합니다. 즉, 코드에서 변수나 함수를 선언하기 전에 해당 변수나 함수를 사용할 수 있는 것처럼 보이는 현상을 의미합니다.

```jsx
console.log(x);
var x = 10;

sayHi(); // "Hello, weniv!"
function sayHi() {
  console.log('Hello, weniv!');
}
```

위의 코드에는 변수 선언문과 함수 선언문이 정의되어 있습니다. 그리고 해당 변수와 함수를 선언하기 전에 각각 참조하고 있습니다. 하지만 실행 결과에서는 변수 x는 `undefined`로, 함수 sayHi는 "Hello, weniv!"를 출력하게 됩니다. 이것은 호이스팅에 의해 변수와 함수가 해당 스코프의 최상단으로 끌어올려졌기 때문입니다.

하지만, 호이스팅은 변수의 선언만을 끌어올리고, 변수의 초기화나 할당은 끌어올려지지 않습니다. 따라서 변수의 값을 초기화하기 전에 참조하면 `undefined`가 반환되는 것입니다.

따라서 함수 표현식은 변수 선언만을 끌어올리기 때문에 함수를 선언하기 전에 함수를 호출하면 에러가 발생합니다. 이와 반대로 함수 선언문은 전체를 끌어올리기 때문에 위의 코드처럼 함수를 선언하기 전에 함수를 호출할 수 있습니다.

## 2.2. 일시적 사각지대(Temporal Dead Zone)

비교적 최근에 등장한 let, const, class를 이용한 선언문은 **일시적 사각지대(Temporal Dead Zone)** 라는 것을 만들어서 호이스팅이 되었지만 안된 것처럼 동작하게 합니다. 호이스팅은 일어나지만 초기화가 되지 않기 때문에 변수를 사용할 수 없는 구간이 생기게 됩니다.

```javascript-exec
console.log(y);
console.log(z);
let y = 20;
const z = 30;
```

위의 코드에서 변수 y와 z는 선언문을 만난 이후에 초기화 되어 TDZ에서 벗어나 값을 사용할 수 있습니다. 하지만 선언문을 만나기 전에 변수 y와 z를 사용하면 에러가 발생합니다.
