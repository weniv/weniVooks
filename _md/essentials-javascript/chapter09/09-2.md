---
chapter: 함수 활용하기
title: 다양한 함수
date: 2024-04-30
---

# 1. 콜백함수

콜백 함수는 다른 함수의 매개변수로 전달되어 실행되는 함수를 의미합니다. 콜백 함수를 이용하면 함수의 실행 순서를 제어할 수 있어 이벤트 처리, 배열 메서드, 비동기 처리 등 다양한 상황에서 사용됩니다.

```javascript-exec
function sum(x, y, callback) {
  callback(x + y);
  return x + y;
}

function consolePrint(text) {
  console.log('콜백 함수: ', text);
}

sum(10, 20, consolePrint);
```

```javascript-exec
function square(x) {
  return x ** 2;
}

let arr = [1, 2, 3, 4, 5];
console.log(arr.map(square));

arr.map((x) => x ** 2);
```

:::div{.callout}
**first class 언어**  
JavaScript에서는 함수를 변수에 할당할 수 있습니다. 이러한 함수를 변수에 할당한 후, 해당 변수를 매개변수로 다른 함수에 전달하거나, 다른 함수의 반환값으로 사용할 수 있습니다. 이렇게 하면 함수를 조합하여 더 복잡한 기능을 수행할 수 있습니다. 이러한 기능을 지원하는 언어를 first class 언어라고 하며 Python, Ruby등이 이러한 언어군에 속합니다.
:::

# 2. 재귀함수

재귀함수(Recursive function)는 함수가 자기 자신을 호출하는 함수를 뜻합니다. 재귀 함수를 이용하면 반복문을 사용하지 않고도 반복적인 작업을 수행할 수 있습니다. 즉, 반복문으로 해결할 수 있는 문제는 재귀함수로 해결할 수 있습니다.
팩토리얼 함수를 반복문으로 구현하면 다음과 같이 작성할 수 있습니다.

```javascript-exec
function factorial(n) {
  let result = 1;
  for (let i = 1; i <= n; i++) {
    result *= i;
  }
  return result;
}
factorial(5);
```

재귀 함수로 구현하면 다음과 같이 작성할 수 있습니다.

```javascript-exec
function factorial(n) {
if (n <= 1) {
  return 1;
}
return n * factorial(n - 1);
}
factorial(5);
// factorial(5) == 5 * factorial(4) == 5 * 24
// factorial(4) == 4 * factorial(3) == 4 * 6
// factorial(3) == 3 * factorial(2) == 3 * 2
// factorial(2) == 2 * factorial(1) == 2 * 1
// factorial(1) == 1
```

재귀 함수를 작성할 때 주의할 점은, 재귀 호출이 무한히 반복되지 않도록 종료 조건을 반드시 설정해야 합니다. 종료 조건이 없으면 함수가 무한히 호출되어 스택 오버플로우가 발생할 수 있습니다. 위 코드의 팩토리얼 함수에서 종료 조건은 `n <= 1`입니다.

1부터 n까지의 합을 구하는 sigma 함수를 재귀함수로 구현해보겠습니다.

```javascript-exec
function sigma(n) {
  if (n <= 1) {
    return n;
  }
  return n + sigma(n - 1);
}
sigma(5);
// sigma(5) == 5 + sigma(4) == 5 + 10
// sigma(4) == 4 + sigma(3) == 4 + 6
// sigma(3) == 3 + sigma(2) == 3 + 3
// sigma(2) == 2 + sigma(1) == 2 + 1
// sigma(1) == 1
```

/\*_ 수정 _/

```jsx
function reverse(text) {
  if (text.length <= 1) {
    return text;
  }
  return reverse(text.slice(1)) + text[0];
}

// reverse('hello') == reverse('ello') + 'h' == 'olle' + 'h'
// reverse('ello') == reverse('llo') + 'e' == 'oll' + 'e'
// reverse('llo') == reverse('lo') + 'l' == 'ol' + 'l'
// reverse('lo') == reverse('o') + 'l' == 'o' + 'l'
// reverse('o') == 'o'
```

# 3. 즉시 실행함수

함수 챕터에서 잠시 다뤘었던 즉시 실행 함수에 대해 다시 한번 알아보겠습니다. 즉시 실행 함수는 함수를 선언함과 동시에 실행하는 함수입니다. 즉시 실행 함수는 함수를 선언함과 동시에 실행하기 때문에 외부에서 함수를 호출할 필요가 없는 경우에 사용합니다. 또한 즉시 실행 함수는 function scope를 이용하기 때문에 메모리 효율적입니다.

즉시 실행 함수를 작성하는 방법은 다음과 같습니다.

```javascript-exec
// 익명 즉시 실행 함수
(function () {
  let a = 1;
  let b = 2;
  return a + b;
})();
```

즉시 실행 함수는 함수를 선언함과 동시에 실행하기 때문에 함수 이름을 작성하지 않아도 됩니다. 함수 이름을 작성하지 않는 것이 일반적입니다. 메모리를 효율적으로 관리하기 위해 바로 실행해야 하는 함수는 즉시 실행 함수로 작성합니다.

```javascript-exec
// 기명 즉시 실행 함수
(function func() {
  let a = 3;
  let b = 5;
  return a * b;
})();

func(); // ReferenceError: func is not defined
```

# 4. 생성자 함수 (Constructor)

자바스크립트에서 객체를 생성하는 방식은 대표적으로 두 가지가 있습니다. 하나는 중괄호(`{}`)를 사용한 객체 리터럴 표현식, 그리고 나머지가 생성자 함수를 이용한 방식입니다. 생성자 함수는 사용자 정의 객체를 생성할 때 사용되는 함수입니다.
생성자 함수를 이용하면 동일한 프로퍼티를 가지는 객체를 여러 개 생성할 수 있습니다. 또한 객체지향 프로그래밍에서 배울 프로토타입을 이용하여 메모리 효율을 높일 수 있습니다.

```jsx
let book = {
  책이름: '자바스크립트 에센셜',
  책가격: 15000,
  저자: ['웨이드', '하티'],
  출판일: '2024.08.24',
};
// 책이 100권이라면 모든 객체를 일일이 작성해야 하는 문제가 발생

function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = new Book('HTML/CSS 에센셜', 20000, ['로지', '지지'], '2024.7.31');
let book2 = new Book('견고한 Python', 300000, ['라이캣'], '2023.11.30');
let book3 = new Book('웹/네트워크/HTTP', 0, ['라이캣'], '2024.4.26');

console.log(book1, book2, book3);
```

생성자 함수를 작성할 때는 일반 함수와 구분하기 위해 함수 이름의 첫 글자를 대문자로 작성합니다. 관습적으로 파스칼 케이스(PascalCase)를 이용하여 함수 이름을 작성합니다. 생성자 함수를 호출할 때는 `new` 연산자와 함께 호출합니다. 생성자 함수를 호출하면 객체가 생성되고, 이때 생성된 객체를 인스턴스(instance)라고 합니다. `new` 연산자는 생성자 함수의 `this`가 인스턴스를 바라보도록 만들어줍니다.

실제로는 다음과 같이 동작합니다. 생성자 함수를 호출하면 빈 객체가 생성되고, `this`에 바인딩됩니다. 그리고 함수 내부의 코드가 실행되면서 `this`에 프로퍼티가 추가됩니다. 마지막으로 `this`가 반환됩니다.

```javascript-exec
function Book(책이름, 책가격, 저자, 출판일) {
  // this = {}
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
  // return this
}
```

이때 `new` 연산자를 사용하지 않으면 생성자 함수가 일반 함수로 동작합니다. 이때는 `this`가 전역 객체를 바라보게 됩니다. 이는 전역 객체에 프로퍼티를 추가하는 문제가 생길 수 있으니 주의해야 합니다.

```javascript-exec
function Book(책이름, 책가격, 저자, 출판일) {
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
}

let book1 = Book('HTML/CSS 에센셜', 20000, ['로지', '지지'], '2024.7.31');
let book2 = Book('견고한 Python', 300000, ['라이캣'], '2023.11.30');
let book3 = new Book('웹/네트워크/HTTP', 0, ['라이캣'], '2024.4.26');

// book1과 book2에는 어떤 값이 출력될까요?
console.log(book1);
console.log(book2);
console.log(book3);
```

이처럼 생성자 함수를 통해 생성된 객체는 같은 **프로퍼티**와 **메서드**를 가지게 됩니다. 이와 관련해서 객체지향 프로그래밍 챕터에서 좀 더 자세히 얘기해보겠습니다.
