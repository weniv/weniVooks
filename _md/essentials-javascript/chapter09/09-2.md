---
chapter: 비동기 프로그래밍
title: 비동기 처리의 중요성
date: 2024-04-30
---

# 1. 자바스크립트의 런타임

자바스크립트의 엔진은 **싱글 스레드**로 동작합니다. 하지만 자바스크립트는 여러 개의 작업을 동시에 처리할 수 있는 **비동기 처리**를 지원합니다. 이를 위해서 자바스크립트가 실행되는 환경인 런타임에는 **이벤트 루프**와 **콜백 큐**가 존재합니다. 이벤트 루프는 비동기 작업이 완료되면 콜백 큐에 있는 함수를 호출하여 실행하는 역할을 합니다. 즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만, 이벤트 루프를 통해 비동기 작업을 처리할 수 있습니다.

![](/images/essentials-javascript/chapter09/runtime.png)

```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);
console.log(3);
```

Web API는 브라우저에서 제공하는 API로 비동기 작업을 처리하는 역할을 합니다. 위의 코드에서 `setTimeout`은 Web API에 의해 처리됩니다. `setTimeout`이 호출되면 Web API는 타이머를 시작하고, 타이머가 만료되면 콜백 함수를 콜백 큐에 추가합니다.

콜백 큐는 Fifo(First In First Out) 방식으로 동작합니다. 즉, 먼저 들어온 함수가 먼저 실행됩니다. 이벤트 루프는 콜 스택이 비어있을 때 콜백 큐에서 함수를 꺼내어 실행합니다. 위의 코드에서 `setTimeout`이 호출되면 Web API는 타이머를 시작하고, 타이머가 만료되면 콜백 함수를 콜백 큐에 추가합니다. 그 후, 콜 스택이 비어있을 때 이벤트 루프가 콜백 큐에서 함수를 꺼내어 실행합니다.

:::div{.callout}
**Microtask Queue와 Macrotask Queue**
마이크로태스크 큐와 매크로태스크 큐는 서로 다른 작업을 처리합니다.

- Microtask Queue: Promise, MutationObserver 등
- Macrotask Queue: setTimeout, setInterval 등

마이크로태스크 큐는 매크로태스크 큐보다 우선적으로 실행됩니다. 즉, 콜 스택이 비어있을 때 마이크로태스크 큐에 있는 작업이 먼저 실행되고, 그 후 매크로태스크 큐에 있는 작업이 실행됩니다.

```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
}, 0);
Promise.resolve().then(() => {
  console.log(3);
});
console.log(4);
```

:::

## 2. 비동기 처리의 중요성

다음 챕터에서 다룰 **AJAX(Asynchronous JavaScript and XML)** 는 비동기 통신을 통해 서버와 데이터를 주고받는 방법입니다. AJAX의 등장으로 비동기 처리 방법이 매우 처리 방법이 매우 중요해졌습니다.

다음 의사코드를 살펴보겠습니다. `비동기통신함수1`과 `비동기통신함수2`가 있을 때, 이 두 함수의 결과를 더한 값을 출력하기 위해 다음과 같이 코드를 작성해도 우리는 원하는 결과를 얻을 수 없습니다. 그 이유는 비동기 함수의 결과를 기다리지 않고 바로 console을 실행하기 때문입니다.

```js
const result1 = 비동기통신함수1();
const result2 = 비동기통신함수2();

console.log(result1 + result2);
```

앞서 작성한 XHR 코드에서 통신 함수 외부에 변수를 선언하고, 통신 함수가 끝난 후 변수에 값이 출력되는지 확인해봅시다.

```javascript
let result;
function xhrRequest() {
  const requestObj = new XMLHttpRequest();
  requestObj.open('GET', 'https://test.api.weniv.co.kr/mall');
  requestObj.onreadystatechange = () => {
    if (requestObj.readyState === 4 && requestObj.status === 200) {
      result = requestObj.responseText;
      console.log(result); // 콘솔에 무엇이 찍히는지 확인해봅시다.
    }
  };
  requestObj.send();
}

xhrRequest();
console.log(result); // 콘솔에 무엇이 찍히는지 확인해봅시다.
```

이처럼 비동기 코드는 동기 코드와 다르게 코드의 실행 순서가 보장되지 않아 결과를 예측하기 어렵습니다. 이러한 문제를 해결하기 위해 여러가지 비동기 처리 방법이 등장했습니다.

## 2.1. 콜백 함수 (callback)

통신이 끝난 후 실행할 함수를 콜백함수로 전달하는 방식입니다. 콜백함수는 함수의 인자로 전달되어 특정 시점에 실행되는 함수를 나타냅니다. 일반적인 동기식 코드처럼 비동기 함수 실행 후 다음 라인에서 다른 함수를 실행하는, 순차적으로 함수들을 나열하는 방식이 불가능합니다. 따라서 비동기 코드가 끝나고 콜백으로 함수를 부르고, 다음 함수를 또 콜백으로 부르는 형태가 되야합니다.

```js
function asyncFunc(input, callback) {
  setTimeout(() => {
    const result = input + 10;
    callback(result);
  }, 1000);
}
asyncFunc(5, (result) => {
  console.log(result);
});
```

이처럼 콜백 함수를 이용하여 비동기 처리가 완료된 후 실행할 함수를 지정할 수 있습니다. 하지만 콜백 함수를 중첩하여 사용하면 **콜백 지옥(callback hell)** 이 발생할 수 있습니다. 콜백 지옥은 콜백 함수가 중첩되는 것으로, 코드의 가독성이 떨어지고 복잡성이 증가해서 오류 처리가 어려워지는 문제가 발생합니다.

```js
function asyncFunc(input, callback) {
  setTimeout(() => {
    const result = input + 10;
    callback(result);
  }, 100);
}
function asyncFunc2(input, callback) {
  setTimeout(() => {
    const result = input + 10;
    callback(result);
  }, 100);
}
function asyncFunc3(input, callback) {
  setTimeout(() => {
    const result = input + 10;
    callback(result);
  }, 100);
}

const input = 5;
asyncFunc(input, (result) => {
  console.log('asyncFunc', result);
  asyncFunc2(result, (result) => {
    console.log('asyncFunc2', result);
    asyncFunc3(result, (result) => {
      console.log('asyncFunc3', result);
    });
  });
});
```

실제 예시를 위해 로그인을 하는 과정을 콜백함수로 작성해보겠습니다.

```jsx
function authUser(id, pw, callback) {
  setTimeout(() => {
    if (id === 'weniv' && pw === '1234') {
      callback(null, id);
    } else {
      callback(new Error('인증 실패'), null);
    }
  }, 100);
}

function getUserProfile(userId, callback) {
  setTimeout(() => {
    if (userId === 'weniv') {
      const profile = {
        userId: userId,
        name: 'weniv',
      };
      callback(null, profile);
    } else {
      callback(new Error('프로필 조회 실패'), null);
    }
  }, 100);
}

function login(id, pw) {
  authUser(id, pw, (authErr, userId) => {
    if (authErr) {
      console.error(authErr);
      return;
    }

    getUserProfile(userId, (profileErr, profile) => {
      if (profileErr) {
        console.error(profileErr);
        return;
      }
      console.log('로그인 성공');
    });
  });
}

login('licat', '0000');
login('weniv', '1234');
```
