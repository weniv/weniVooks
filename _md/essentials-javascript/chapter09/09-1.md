---
chapter: 함수 활용하기
title: 파라미터와 아규먼트
date: 2024-04-30
---

# 1. 기본값 설정하기

함수의 파라미터는 선언과 동시에 값을 할당하여 기본값을 설정할 수 있습니다. 함수 호출 시 인자를 전달하지 않으면 기본값이 사용됩니다. 매개변수의 초기화는 기본적으로 왼쪽에서 오른쪽의 순서로 설정됩니다.

```jsx
function defaultFunc(a = 10, b = 20, c = 30) {
  return a + b + c;
}

console.log(defaultFunc());
console.log(defaultFunc(100));
console.log(defaultFunc(100, 200));
console.log(defaultFunc(100, 200, 300));

console.log(defaultFunc((c = 1000)));
console.log(defaultFunc((c = 1000), (a = 2000)));
```

# 2. 구조 분해 할당

구조 분해 할당을 이용해서 함수에 전달하는 인자를 객체로 전달할 수 있습니다. 이를 통해 객체나 배열에서 원하는 값만 쉽게 추출할 수 있습니다.

```javascript-exec
function printUser(name, age, company, level, year){
  console.log(`이름: ${name}, 나이: ${age}, 회사: ${company}, 레벨: ${level}, 가입년도: ${year}`);
}
printUser('라이캣', 20, '위니브', 20, 2018);
printUser('빙키', '위니브', 16, 2020);
```

```javascript-exec
function printUser({name, age, company, level, year}){
   console.log(`이름: ${name}, 나이: ${age}, 회사: ${company}, 레벨: ${level}, 가입년도: ${year}`);
}
const licat = {
  name: "라이캣",
  age: 25,
  company: "위니브",
  level: 20,
  year: 2018,
  email: "licat@weniv.com",
};
const binky = {
  name: "빙키",
  company: "위니브",
  level: 16,
  year: 2020,
};

printUser(licat);
printUser(binky);

```

:::div{.callout}
**RORO 패턴**  
RORO는 "Recieve an Object, Return an Object"의 약자로, 객체를 받아서 구조 분해 할당을 활용하여 원하는 값만 추출한 후 다시 객체로 반환하는 방식을 말합니다. 파라미터의 이름을 명확하게 알 수 있고, 필요한 값만 선택적으로 처리할 수 있어 가독성이 높아집니다.

```javascript
function createUser({ name, age, email }) {
  // ... 로직
  return { id, name, age, email };
}

// 사용 예
const user = createUser({
  name: 'licat',
  age: 20,
  email: 'licat@weniv.com',
});
console.log(user.id);
```

::a[RORO 패턴]{class="btn-link" href="https://www.freecodecamp.org/news/elegant-patterns-in-modern-javascript-roro-be01e7669cbd" target="\_blank"}
:::

이처럼 구조 분해 할당을 이용하여 함수에 인자를 전달할 때 주의할 점이 있습니다. 다음 코드를 실행하면 어떤 결과가 나올까요?

```javascript-exec
function printUser({name, age, company, level, year}){
  console.log(`이름: ${name}, 나이: ${age}, 회사: ${company}, 레벨: ${level}, 가입년도: ${year}`);
}
printUser()
```

함수에 전달된 인자가 없거나 `undefined` 또는 `null`일 경우 오류가 발생합니다. 그 이유는 구조 분해 할당은 객체나 배열에서 속성을 추출하는 문법인데, `undefined`이나 `null`은 속성을 추출할 수 없기 때문입니다. 이를 방지하기 위해 기본값을 설정할 수 있습니다. 빈 객체를 기본값으로 설정하여 함수 호출 시 인자를 전달하지 않아도 오류가 발생하지 않도록 할 수 있습니다.

```javascript-exec
function printUser({name, age, company, level, year} = {}){
  console.log(`이름: ${name}, 나이: ${age}, 회사: ${company}, 레벨: ${level}, 가입년도: ${year}`);
}
```

또는 전달받은 인자가 객체 또는 배열인지 타입을 체크하는 조건문을 사용하는 방법도 있습니다. 이를 이용하면 인자로 객체가 아닌 값이 오는 경우를 대비할 수 있습니다.

```javascript-exec
function printUser(user){
  if(typeof user !== 'object' || user === null){
    console.error('인자는 객체 또는 배열이어야 합니다.');
    return;
  }
  const {name, age, company, level, year} = user; // 구조 분해 할당
  console.log(`이름: ${name}, 나이: ${age}, 회사: ${company}, 레벨: ${level}, 가입년도: ${year}`);
}
```

# 3. **나머지 문법**

나머지(rest) 문법을 사용하면 함수의 매개변수에 `...`를 붙여 사용자가 제공한 모든 매개변수를 배열로 만들 수 있습니다.

rest 문법을 이용할 때 주의해야할 점은 매개변수에는 하나의 `rest`만 존재할 수 있으며, 반드시 마지막 매개변수로 와야합니다. 그렇지 않으면 에러가 발생합니다. 아래 코드에서 rest 문법을 이용해 매개변수를 처리합니다.

```jsx
function restFunc(a, b, ...c) {
  return Math.min(...c);
}

restFunc(10, 20, 30, 40, 50, 60);
```

:::div{.callout}
**rest 문법이 spread 문법과 비슷해보여요!**  
맞습니다. 두 문법은 똑같이 생겼는데요! 사용하는 위치에 따라 spread와 rest로 나누어집니다.
자바스크립트 엔진은 일반적인 객체나 배열안에서 사용되는 `…` 은 spread, 함수의 마지막 매개변수에 사용되는 `…` 은 rest 문법으로 인식합니다.

```jsx
const arr = [1, 2, 3];
const newArr = [...arr]; // spread 문법
```

```
function restFunc(a, b, ...c) { // rest 문법
  console.log(c);
}
```

restFunc(10, 20, 30, 40, 50);
:::
