---
chapter: DOM
title: DOM의 이벤ㅡ 흐름
date: 2024-04-30
---

# 5. 이벤트 흐름

브라우저 화면에서 이벤트가 발생하면 브라우저는 가장 먼저 이벤트 대상을 찾기 시작합니다.

![Untitled](/images/essentials-javascript/chapter13/Untitled%202.png)

브라우저가 이벤트 대상을 찾아갈 때는 가장 상위의 window 객체부터 document, body 순으로 DOM 트리를 따라 내려갑니다. 이를 **캡처링 단계**라고 합니다.

이때 이벤트 대상을 찾아가는 과정에서 브라우저는 중간에 만나는 모든 캡처링 이벤트 리스너를 실행시킵니다. 그리고 이벤트 대상을 찾고 캡처링이 끝나면 이제 다시 DOM 트리를 따라 올라가며 만나는 모든 버블링 이벤트 리스너를 실행합니다. 이를 이벤트 **버블링 단계**라고 합니다.

그리고 이러한 과정에서 이벤트 리스너가 차례로 실행되는것을 **이벤트 전파**(event propagation)라고 합니다.

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" conten~npt="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="../reset.css" />
    <style></style>
  </head>

  <body>
    <article class="parent">
      <button class="btn" type="button">버튼</button>
    </article>

    <script>
      const parent = document.querySelector('.parent');
      const btnFirst = document.querySelector('.btn');
      btnFirst.addEventListener('click', (event) => {
        console.log('btn capture!');
      });

      window.addEventListener(
        'click',
        () => {
          console.log('window capture!');
        },
        true,
      ); // true : 캡처링 단계의 이벤트가 발생하도록 합니다.

      document.addEventListener(
        'click',
        () => {
          console.log('document capture!');
        },
        true,
      );

      parent.addEventListener(
        'click',
        () => {
          console.log('parent capture!');
        },
        true,
      );

      btnFirst.addEventListener('click', (event) => {
        console.log('btn bubble!');
      });

      parent.addEventListener('click', () => {
        console.log('parent bubble!');
      });

      document.addEventListener('click', () => {
        console.log('document bubble!');
      });

      window.addEventListener('click', () => {
        console.log('window bubble!');
      });
    </script>
  </body>
</html>
```

# 6. 이벤트 target, currentTarget

부모부터 자식까지 일련의 요소를 모두 타고가며 진행되는 이러한 이벤트의 특징 덕분에 이벤트 객체에는 target, currentTarget 이라는 속성이 존재합니다.

**target** 속성에는 이벤트가 발생한 진원지의 정보가 담겨 있습니다. target 속성을 통해 이벤트 리스너가 없는 요소의 이벤트가 발생했을 때도 해당 요소에 접근 할 수 있습니다.

**currentTarget** 속성에는 이벤트 리스너가 연결된 요소가 참조되어 있습니다.

```html
<article class="parent">
  <ol>
    <li><button class="btn-first" type="button">버튼1</button></li>
    <li><button type="button">버튼2</button></li>
    <li><button type="button">버튼3</button></li>
  </ol>
</article>

<script>
  const parent = document.querySelector('.parent');
  parent.addEventListener('click', function (event) {
    console.log(event.target);
    console.log(event.currentTarget);
  });
</script>
```

# 7. 이벤트 위임

앞에서 우리는 이벤트의 흐름을 통해 이벤트 리스너가 없는 요소의 이벤트가 발생했을 때도 해당 요소에 접근 할 수 있다는 것을 알게 되었습니다.

이를 이용해 이벤트 리스너가 없어도 마치 리스너가 있는 것 처럼 사용 할 수 있습니다.

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="../reset.css" />
    <style></style>
  </head>

  <body>
    <article class="parent">
      <ol>
        <li><button class="btn-first" type="button">버튼1</button></li>
        <li><button type="button">버튼2</button></li>
        <li><button type="button">버튼3</button></li>
      </ol>
    </article>

    <script>
      const parent = document.querySelector('.parent');
      parent.addEventListener('click', function (event) {
        console.log(event.target);
        if (event.target.nodeName === 'BUTTON') {
          event.target.textContent = '버튼4';
        }
      });
    </script>
  </body>
</html>
```

이러한 테크닉을 **이벤트 위임**이라고 합니다.

# 8. 이벤트의 this

이벤트 리스너 함수 내부에서의 this 값은 이벤트가 연결된 노드를 참조합니다.

```html
<article class="parent">
  <ol>
    <li><button class="btn-first" type="button">버튼1</button></li>
    <li><button type="button">버튼2</button></li>
    <li><button type="button">버튼3</button></li>
  </ol>
</article>

<script>
  const parent = document.querySelector('.parent');
  parent.addEventListener('click', function (event) {
    console.log(this);
  });

  const myObj = {
    name: 'jaehyun',
    walk() {
      parent.addEventListener('click', () => {
        console.log(this.name + ' is walking');
      });
    },
  };
</script>
```

이는 event.currentTarget 속성의 참조값과 유사합니다.

만약 이벤트 리스너 함수를 화살표 함수로 쓴다면 this 가 가리키는 대상이 달라진다는 점에 유의하세요.

# 9. 실습

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="reset.css" />
    <style>
      /* 직접 셀렉트 박스 만들기 */
      h2 {
        margin: 30px;
      }

      .cont-select {
        position: relative;
        width: 200px;
      }

      .btn-select {
        width: 100%;
        padding: 13px 14px;
        color: #000;
        font-size: 12px;
        line-height: 14px;
        text-align: left;
        border: 1px solid #c4c4c4;
        box-sizing: border-box;
        border-radius: 10px;
        cursor: pointer;
        background: url('images/icon-Triangle-down.png') right 13px center
          no-repeat;

        /* 말줄임 추가 */
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .btn-select:focus {
        outline: 3px solid #f8e4ff;
      }

      .list-member {
        display: none;
        width: 100%;
        overflow: hidden;
        position: absolute;
        left: 0;
        top: 51px;
        background: #fff;
        border: 1px solid #c4c4c4;
        box-shadow: 4px 4px 14px rgba(0, 0, 0, 0.15);
        border-radius: 10px;
      }

      .btn-select.on {
        background: url('images/icon-Triangle-up.png') right 13px center
          no-repeat;
      }

      .btn-select.on + .list-member {
        display: block;
      }

      .list-member li {
        height: 40px;
        padding: 5px 18px;
      }

      .list-member li button {
        display: block;
        height: 30px;
        width: 100%;
        border: none;
        background-color: #fff;
        border-radius: 8px;
        cursor: pointer;

        /* 말줄임 추가 */
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .list-member li button:focus,
      .list-member li button:hover {
        background-color: #f8e4ff;
      }
    </style>
  </head>

  <body>
    <h2>셀렉트 박스 만들기</h2>
    <article class="cont-select">
      <button class="btn-select">나의 최애 프로그래밍 언어</button>
      <ul class="list-member">
        <li><button type="button">Python</button></li>
        <li><button type="button">Java</button></li>
        <li><button type="button">JavaScript</button></li>
        <li><button type="button">C#</button></li>
        <li><button type="button">C/C++</button></li>
      </ul>
    </article>
  </body>
</html>
```

# 10. 이벤트 흐름 조작

## 10.1. preventDefault()

브라우저의 기본 이벤트 동작을 취소합니다.

브라우저는 HTML 태그를 통해 여러가지 기능들을 제공합니다. 하지만 때때로 그러한 기능이 방해가 되는 경우가 있습니다.

```html
<!-- 앵커의 기본 동작을 중지 -->
<a href="https://www.naver.com" class="link">네이버 링크입니다만..</a>
<script>
  const link = document.querySelector('.link');
  link.addEventListener('click', (event) => {
    console.log('clicked');
    event.preventDefault();
  });
</script>

<!-- submit 의 기본 동작을 중지 -->
<form action="">
  <button type="submit" class="submit">제출</button>
</form>
<script>
  const submit = document.querySelector('.submit');
  submit.addEventListener('click', (event) => {
    console.log('clicked');
    event.preventDefault();
  });
</script>
```

이렇듯 종종 브라우저의 기본 동작을 중지하고 자바스크립트를 통해 기능을 처리하고자 할때 사용합니다.

**preventDefault** **실습**

이벤트 타입 contextmenu를 이용해 브라우저 오른쪽 버튼 이벤트 막고 '해당 페이지에서는 오른쪽 클릭을 제한합니다.’ 경고 띄우기

## 10.2 stopPropagation()

앞에서 우리는 preventDefault를 통해 브라우저의 기본 이벤트 동작을 취소해봤습니다. 하지만 이때 우리가 앞에서 배웠던 이벤트 흐름, 즉 이벤트 전파(이벤트 프로파게이션)를 막지는 못합니다.

```html
<form action="">
  <button type="submit" class="submit">제출</button>
</form>

<script>
  const submit = document.querySelector('.submit');
  submit.addEventListener('click', (event) => {
    console.log('clicked');
    event.preventDefault();
    // event.stopPropagation();
  });

  document.body.addEventListener('click', () => {
    console.log('event still alive!');
  });
</script>
```

이때 만약 이벤트 전파를 막고 싶다면 `event.stopPropagation()` 코드를 추가합니다.

**stopPropagation() 실습**

```html
<h1>나의 todo list</h1>
<p>
  1. 오늘 저녁에는 부대찌게를 끓여 먹겠다.<button type="button">삭제</button>
</p>
<p>2. 후식으로 슈팅스타를 먹겠다.<button type="button">삭제</button></p>
<p>
  3. 자기 전에 반드시 내일 아침 메뉴를 생각해두겠다.<button type="button">
    삭제
  </button>
</p>
```

위와 같은 HTML코드 구조가 있을 때

1. P 태그를 클릭하면 p 태그의 컨텐츠를 출력하는 alert 창을 띄워주고
2. 삭제 버튼을 클릭하면 삭제할 것인지를 물어보는 confirm 창을 띄워주고, 확인을 누르면 P태그를 삭제합니다.
