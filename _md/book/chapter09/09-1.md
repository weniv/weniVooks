---
chapter: 설계 도면 Class
title: 실제 만든 게임 코드로 보는 Class의 활용
date: 2024-04-04
---

# 1. classes

ES6 부터 class라는 키워드를 사용할 수 있게 되었습니다. 클래스란 객체를 생산하는 생산 도면 혹은 청사진이란 표현을 자주 사용합니다. 즉 엄청나게 많이 사용하는 비유, 클래스는 붕어빵의 틀이다 라는 표현이 등장합니다.

![붕어빵 틀과 붕어빵](/images/basecamp-javascript/chapter09/1.png)

![청동검 거푸집](/images/basecamp-javascript/chapter09/2.png)

혹은 국사 시간에 많이 만나본 이미지를 떠올릴 수도 있습니다.

# 2. class의 사용법

class 키워드 + 이름 + 중괄호로 이루어져 있습니다.

클래스의 결과물은 인스턴스를 생성하는것입니다. 생성자를 이용한 타입 생성과 그 결과가 정확하게 일치합니다.

```jsx
// function Robot(name) {
//     this.name = name;
// }

// Robot.prototype.sayYourName = function () {
//     console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
// }

class Robot {
  // 클래스의 생성자 함수입니다. 하나의 클래스는 하나의 생성자만 정의할 수 있습니다.
  // 그리고 생성자 함수는 new 키워드가 호출될때 자동으로 실행됩니다.
  constructor(name) {
    this.name = name;
  }

  // 메소드를 정의합니다. 메소드는 클래스가 생성한 인스턴스를 통해 사용할 수 있습니다.
  sayYourName() {
    console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
  }
}
```

자바스크립트만의 사용자 정의 타입 생성(객체 생성) 방법을 다른 언어의 클래스 문법처럼 바꿔준 것이 바로 자바스크립트 클래스(classes)입니다!

:::div{.callout}
이처럼 내부적인 동작은 동일하지만 더 보기 좋고 편리하게 개선된 문법을 슈가신텍스 (Syntactic sugar) 라고 부릅니다. (classes 문법은 단순한 설탕문법은 아닙니다. 여러가지 추가된 문법이 있습니다.)

:::

# 2. class 상속받기

클래스의 상속은 extends 키워드를 사용합니다. 상속을 받는 클래스는 ‘파생 클래스’(derived classes)라고 부릅니다.

```jsx
class Animal {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, I'm ${this.name}.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }

  bark() {
    console.log('Woof!');
  }
}

const dog = new Dog('Buddy', 'Labrador');
dog.sayHello(); // Hello, I'm Buddy.
dog.bark(); // Woof!
```

위 예제에서 Dog 클래스는 Animal 클래스를 상속받습니다. Dog 클래스의 constructor에서 super()를 호출하여 부모 클래스의 constructor를 실행하고, 자식 클래스에서 필요한 추가 속성(breed)을 정의합니다.

Dog 클래스는 부모 클래스(Animal)의 sayHello() 메서드를 그대로 사용할 수 있으며, 자신만의 메서드(bark)도 추가로 가지고 있습니다.

이처럼 상속을 사용하면 기존 클래스의 기능을 재사용하면서도 필요에 따라 자식 클래스에서 기능을 추가하거나 변경할 수 있어 코드의 재사용성과 유지보수성이 높아집니다.

# 3. 비공개(private) 프로퍼티

:::div{.callout}
"#(샾)이 나오기 전에는 \_(언더바)를 사용하는 경우도 있었고, 지금도 이렇게 사용하고 있는 곳이 있습니다.

언더바는 읽기 전용으로 사용하겠다는 표시입니다. 다만 강제사항이 아니라서 실제로 수정이 가능한 변수입니다. 사용하는 곳이 있기도 하니 기억해주세요.

아직 비공개 프로퍼티가 널리 퍼지진 않았습니다. 나온지 얼마 안된 문법이라 주의를 요합니다.

- 개발자 도구에서는 #을 했어도 접근이 가능합니다. .html파일에서 실행해주세요.
  :::

비공개 프로퍼티는 객체 안의 중요한 정보를 안전하게 보호하여 프로그램이 뜻하지 않게 변경되는 것을 막는 역할을 합니다.

만약 여러분이 class를 통해 인스턴스를 만들었을 때 보통 우리는 아무런 제약없이 인스턴스의 프로퍼티에 접근하는 것이 가능합니다.

```jsx
class Robot {
  constructor(name) {
    this.name = name;
  }

  sayYourName() {
    console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
  }
}

const bot = new Robot('smith');

bot.name; // smith
```

또한 프로퍼티의 값을 수정하는 것도 가능합니다.

```jsx
bot.name = 'jay';
bot.name; // jay
```

하지만 중요한 데이터를 조심스럽게 다뤄야 할 경우, 그래서 이런 데이터를 외부에서 함부로 수정할 수 없게 만들고 싶을 때 우리는 비공개 프로퍼티로 데이터를 변경할 수 있습니다.

```jsx
class Robot {
  #password;

  constructor(name, pw) {
    this.name = name;
    this.#password = pw;
  }

  sayYourName() {
    console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
  }

  getPassword() {
    return this.#password;
  }

  setPassword(pw) {
    this.#password = pw;
  }
}
```

\# 키워드를 이용하면 프로퍼티를 비공개로 전환할 수 있습니다.

이제 #password 의 값에 접근하고 수정하려면 반드시 해당하는 기능을 하는 메서드를 사용해야합니다.

이때 값을 불러오는 메서드를 getter 메서드, 값을 수정하는 메서드를 setter 메서드로 부릅니다.

get, set 키워드를 이용해 아래처럼 코드를 좀 더 단순화 할 수 있습니다.

```jsx
class Robot {
  #password;

  constructor(name, pw) {
    this.name = name;
    this.#password = pw;
  }

  sayYourName() {
    console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
  }

  get password() {
    return this.#password;
  }

  set password(pw) {
    this.#password = pw;
  }
}

const bot = new Robot('재현', 1234);
```

이렇게 get과 set 키워드를 사용하면 마치 객체의 프로퍼티에 접근하듯 값을 다룰수 있게 됩니다.

:::div{.callout}
get 과 set을 사용할 때 주의할 점!

get과 set을 사용하면 마치 객체의 프로퍼티를 수정하는것 같은 간편함을 느낄 수 있습니다. 하지만 해당 코드를 직접 작성하지 않은 협업자들에게는 오해를 불러일으킬 소지가 있습니다. get, set 안에 어떤 로직이 들어있는지 파악하지 못하고 단순히 객체의 프로퍼티를 수정한다는 착각을 일으킬 수 있기 때문입니다.

때문에 협업 시에는 주석이나, 가이드 문서를 만들어 충분한 정보를 제공해주는것이 좋습니다.

또한 private 필드 선언을 한 프로퍼티의 경우 get, set 키워드를 사용하면, 비공개 하였음에도 불구하고 일반 프로퍼티처럼 접근이 가능하게됩니다.
:::
