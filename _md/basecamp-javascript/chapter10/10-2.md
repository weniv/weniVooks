---
chapter: 비동기 프로그래밍
title: fetch와 async, await
date: 2024-06-07
---

# 1. 실무에서 사용하는 fetch

위니브에서 개발하고 있는 스터디인(https://www.studyin.co.kr/) 서비스에 접속하여 네트워크 탭을 클릭한 후 새로고침을 해보세요. 이렇게 하면 서버로부터 데이터를 받아오는 과정을 확인할 수 있습니다. 여기서 아래 이미지처럼 `Fetch/XHR`이라는 항목을 클릭해보세요. 실제 이 서비스가 어떠한 데이터를 받아와서 화면에 출력하는지 확인할 수 있습니다. 그리고 각각의 파일을 클릭한 다음 우클릭하시면 `fetch` 코드도 확인할 수 있습니다.

![](/images/basecamp-javascript/chapter10/1.png)

# 2. fetch

이처럼 `fetch`는 실무에서 매우 많이 사용되는 코드입니다. `fetch`는 자바스크립트에서 제공하는 비동기 통신 API입니다. 이를 사용하면 앞서 본 것 처럼 서버에 네트워크 요청을 보내고 새로운 정보를 받아올 수 있습니다. 실무에서 자주 사용되기 때문에 아래와 같은 구현 테스트 문제로도 자주 출제 됩니다. 구현 테스트는 보통 서류 전형을 통과하고 면접 전에 보는 테스트를 말합니다.

![](/images/basecamp-javascript/chapter10/2.png)

이 `fetch`는 앞서 배운 `Promise`를 기반으로 구현되어 있습니다. `.then()`이나 `.catch()`를 통해 코드 분기를 할 수 있는 것이죠. 응답 값에 따라 `.then()`이나 `.catch()`를 적절히 사용할 수 있습니다. 따라서 이번 장을 들어가기 전 Promise에 대한 이해가 필요합니다. 혹시 이 챕터로 바로 넘어왔다면 앞 챕터인 `Promise`를 먼저 읽어보세요.

예제 코드에서는 `fetch()`를 사용하여 [http://test.api.weniv.co.kr/mall](http://test.api.weniv.co.kr/mall)에 데이터 요청을 보내고, 응답 데이터를 받아와 다양한 방식으로 처리하는 과정을 보여줍니다.

이 코드를 단번에 이해하기는 힘들겠지만 이러한 과정을 거쳐 우리가 사용하는 웹 서비스가 동작하고 있습니다. 아래 코드를 `about:blank` 콘솔 창에 붙여넣고 실행해보세요. 다른 페이지면 제대로 작동하지 않을 수 있으니 `about:blank` 페이지에서 실행해주세요.

```javascript
fetch('http://test.api.weniv.co.kr/mall')
  .then((productData) => productData.json())
  .then((productData) => console.log(productData));
```

이렇게 실행하면 콘솔에서 서버로부터 받아온 데이터를 확인할 수 있습니다. 이제 이 데이터를 화면에 출력해보겠습니다. 앞서 배운 `DOM`을 이용하여 받아온 JSON을 화면에 뿌려주면 됩니다. 아래코드를 그대로 복사하여 `about:blank` 콘솔 창에 붙여넣고 실행해보세요.

```javascript
fetch('http://test.api.weniv.co.kr/mall')
  .then((productData) => productData.json())
  .then((productData) => productData)
  .then((productData) => {
    console.log(productData.map((item) => item.productName));
    return productData;
  })
  .then((productData) => {
    const main = document.createElement('main');
    productData.forEach((item) => {
      const ProductCard = document.createElement('article');
      const productName = document.createElement('h2');
      const productPrice = document.createElement('p');

      productName.textContent = `상품명 : ${item.productName}`;
      productPrice.textContent = `가격 : ${item.price}`;

      ProductCard.appendChild(productName);
      ProductCard.appendChild(productPrice);

      main.appendChild(ProductCard);
    });
    document.body.appendChild(main);
  })
  .catch((error) => {
    alert('에러!');
    // error page로 리다이렉트
    console.log(error);
  });
```

페이지에 쇼핑몰 데이터가 출력된 것을 확인할 수 있습니다. 이처럼 fetch를 사용하면 서버로부터 데이터를 받아와 화면에 출력할 수 있습니다. 이를 통해 웹 서비스에서 서버와의 통신을 구현할 수 있습니다.

그런데 왜 이 코드가 Promise를 사용하는지 궁금하실 수 있습니다. 서버로부터 데이터를 받아오는 동안 다른 작업을 수행할 수 있어야 하기 때문입니다. 만약 그렇지 못하면 페이지 로딩은 한 참 후가 될 수도 있습니다. 이때 Promise를 사용하면 데이터를 받아오는 동안 다른 작업을 수행할 수 있습니다. 예를 들어 페이지의 골격을 먼저 그리고, 데이터를 받아오면 그 데이터를 화면에 출력할 수 있습니다. 그러면 사용자는 마치 홈페이지가 빠르게 로딩된 것처럼 느낄 수 있습니다.

베이스캠프 강의에서는 fetch를 데이터를 받아오는 용도로만 강의를 진행합니다. 하지만 fetch는 데이터를 읽고, 생성하고, 삭제하고, 수정하는 용도로도 사용할 수 있습니다. 이러한 작업을 CRUD(Create, Read, Update, Delete)라고 합니다. 이러한 작업을 수행할 때는 HTTP 메소드를 사용합니다. HTTP 메소드는 GET, POST, PUT, DELETE 등이 있습니다. 이러한 HTTP 메소드를 사용하여 서버와 통신할 수 있습니다. 이러한 내용은 중급자로 가기 위한 필수 개념이니 만약 초급자가 아니시라면 꼭 정리를 해두세요.

# 2. async, await(에이씽크, 어웨잇)

async/await는 비동기 코드를 작성하는 새로운 방법입니다. 이 문법은 ES8(ECMAScript 2017)에서 도입이 되었습니다. 기존의 비동기 처리 방식인 콜백이나 프로미스와는 다르게, 동기 코드처럼 보이게 작성할 수 있어 더 읽기 쉽고 이해하기 쉽습니다.

함수 앞에 `async` 키워드를 붙이면 해당 함수는 항상 프로미스를 반환합니다. 함수 내부에서 `await` 키워드를 사용하면, 프로미스가 처리될 때까지 함수 실행을 일시 중지시키고, 결과 값을 반환합니다.

```javascript
fetch('http://test.api.weniv.co.kr/mall')
  .then((productData) => productData.json())
  .then((productData) => console.log(productData));
```

이 코드를 우선 async/await로 변경해보겠습니다.

```javascript
async function getData() {
  const response = await fetch(`http://test.api.weniv.co.kr/mall`);
  const productData = await response.json();
  console.log(productData);
}

getData();
```

이렇게 async/await를 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어 가독성과 유지보수성이 크게 향상됩니다. 에러 처리도 일반 try/catch문을 사용할 수 있어 더 간편해집니다.

이번에는 DOM을 사용한 코드를 async/await로 변경해보겠습니다.

```javascript
async function getData() {
  const response = await fetch(`http://test.api.weniv.co.kr/mall`);
  const productData = await response.json();
  console.log(productData);
  console.log(productData.map((item) => item.productName));
  console.log(
    productData.map((item) => item.price).filter((item) => item > 10000),
  );

  const main = document.createElement('main');
  productData.forEach((item) => {
    const ProductCard = document.createElement('article');
    const productName = document.createElement('h2');
    const productPrice = document.createElement('p');

    productName.textContent = `상품명 : ${item.productName}`;
    productPrice.textContent = `가격 : ${item.price}`;

    ProductCard.appendChild(productName);
    ProductCard.appendChild(productPrice);

    main.appendChild(ProductCard);
  });
  document.body.appendChild(main);
}

getData();
```

async/await는 fetch 등과 비교했을 때 비교적 최근에 도입된 문법이지만, 많은 개발자들이 사용하여 현대 자바스크립트에서 비동기 프로그래밍의 핵심으로 자리잡았습니다.

---

**참고자료**

::a[8. 비동기(콜백함수, 프로미스, await/async, fetch)]{class="btn-link" href="https://www.notion.so/8-await-async-fetch-835e5806f6be444aa02ccfd38cb7a9b7?pvs=21" target="\_blank"}
::a[알잘딱깔센 JavaScript 비동기 프로그래밍 - 비동기 너 내 동기가 돼라]{class="btn-link" href="https://www.notion.so/JavaScript-e171d97722484860aa5b162afae83cb1?pvs=21" target="\_blank"}
