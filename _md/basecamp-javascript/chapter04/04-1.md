---
chapter: 객체 타입에 관하여
title: 객체타입과 배열
date: 2024-04-03
---

# 1. 객체타입 (Object Types)

객체타입의 특징은

1. 원시 타입은 값을 변경할 수 없는 것이 반하여 객체 타입은 값을 변경될 수 있습니다. 변수 안에 저장되는 것은 원시 타입이나 객체 타입이나 모두 실제 값의 주소값 입니다. (앞에서처럼 화살표를 통해 설명드리도록 하겠습니다.)
2. 다른 책이나 강의에서 call by reference나 call by value로 구분하여 참조타입과 원시타입을 설명하는 경우도 있는데 이렇게 말하는 것은 적당치 않습니다. JavaScript는 call by value만 존재하기 때문입니다. (잘 정리된 글이 있어 블로그 링크를 하단에 첨부합니다. 초급자 과정에서는 더 깊게 설명하진 않습니다.)
   ::a[[JS] 📚 Call by Value & Call by Reference (+ Call by Sharing)]{class="btn-link" href="https://inpa.tistory.com/entry/JS-📚-Call-by-Value-Call-by-Reference" target="\_blank"}

```jsx
let arr1 = [1, 2, 3];
let arr2 = arr1; // 여기서 arr1과 arr2는 같은 [1, 2, 3]을 가리킵니다.
console.log(arr2);

arr1[0] = 10;
// arr1 = [10, 20];
console.log(arr2);

// 비교해보세요. 화살표가 어떻게 바뀌는지도 그려보세요.
let value1 = 10;
let value2 = value1;
console.log(value2);

value1 = 20;
console.log(value2);
```

# 2. 배열 (Array)

배열(Array)은 데이터를 순서대로 저장하는 객체입니다. 하나의 데이터를 표현하는 원시타입과 달리 여러개의 데이터를 한 변수에 저장할 수 있기 때문에 데이터를 추가하거나, 제거, 정렬, 검색 등 다양한 작업을 수행할 수 있도록 여러가지 메소드를 제공합니다.

## **2.1. 배열의 특징**

1. 배열은 빈 배열로 생성하거나 요소가 포함된 배열로 생성할 수 있습니다.

   ```jsx
   const arr = [];
   const arr = [1, 2, 3];
   const arr2 = new Array(4, 5, 6);
   const arr2 = new Array(3);
   ```

2. 배열은 숫자를 사용하여 값에 접근할 수 있습니다. 이때 숫자는 값의 순서를 의미하며, 이 순서를 인덱스(index), 그리고 배열안에 존재하는 값을 원소(elements)라고 부릅니다. 심지어 존재하지 않는 원소에도 접근이 가능합니다.

   ```jsx
   const arr = [1, 2, 3];
   // 배열 안의 원소에 접근하기 위해서는 인덱스 번호를 이용합니다.
   console.log(arr[0]); // 1
   console.log(arr[1]); // 2
   console.log(arr[2]); // 3
   console.log(arr[3]); // ??
   ```

3. 배열은 가지고 있는 원소의 길이를 나타내는 length 프로퍼티를 가지고 있습니다. (문자열에서도 사용했었죠?)

   ```jsx
   const myArray = [1, 2, 3, 4, 5];
   console.log(myArray.length); // 5
   ```

4. 배열은 배열 안에 다른 배열을 포함할 수 있습니다. 이러한 배열을 다차원 배열이라고 합니다.

   ```jsx
   const arr2 = [
     [1, 2],
     [3, 4],
     [5, 6],
   ];
   console.log(arr2[0][0]);
   console.log(arr2[2][1]);
   ```

   2차원 배열은 행렬 즉, 매트릭스라고 불립니다.  
   arr2 배열은 배열안에 세개의 배열을 원소로 가지고 있습니다. 이러한 배열을 3차원 배열이라고 합니다.

   ```jsx
   const arr3 = [
     [
       [1, 2],
       [3, 4],
     ],
     [
       [5, 6],
       [7, 8],
     ],
   ];
   console.log(arr[0][1][0]);
   console.log(arr[1][0][1]);
   ```

   위와 같은 코드로 배열안의 배열안의 배열인 4차원 배열도 만들어 볼 수 있습니다.

## **2.2. 배열의 메소드**

1. push()와 pop()

   push() 메소드는 배열의 끝에 요소를 추가하고 길이를 반환합니다, pop() 메소드는 배열의 마지막 요소를 꺼내어 반환합니다. 꺼낸 요소는 배열에서 제외됩니다.

   ```jsx
   const arr = [1, 2, 3];
   arr.push(4);
   console.log(arr); // [1, 2, 3, 4]
   arr.pop();
   console.log(arr); // [1, 2, 3]
   ```

1. shift()와 unshift()

   shift() 메소드는 배열에서 첫 번째 요소를 꺼내고 반환합니다, unshift() 메소드는 배열의 첫 번째 요소로 새로운 요소를 추가합니다

   ```jsx
   const myArray = ['사과', '바나나', '수박'];
   myArray.shift();
   console.log(myArray);
   myArray.unshift('오이', '배');
   console.log(myArray);
   ```

1. splice()

   splice() 메소드는 배열의 요소를 추가, 제거 또는 교체합니다.

   메소드는 3개의 전달인자를 받습니다. 첫 번째 인자는 삭제나 추가를 시작할 인덱스입니다. 두 번째 인자는 삭제할 요소의 개수입니다. 세 번째 인자 부터는 추가할 요소들입니다. 추가할 요소가 없다면 생략할 수 있으며 이때는 요소를 삭제만 하게됩니다.

   ```jsx
   const arr = [1, 2, 3];
   arr.splice(1, 0, 4);
   console.log(arr); // [1, 4, 2, 3]
   arr.splice(2, 1, 5);
   console.log(arr); // [1, 4, 5, 3]
   ```

1. slice()

   slice() 메소드는 배열에서 요소들을 추출하여 새로운 배열로 반환하는 메서드입니다.

   메소드는 2개의 전달인자를 받습니다. 첫 번째 인자는 추출을 시작할 인덱스입니다. 두 번째 인자는 추출을 끝낼 인덱스입니다. 추출할 요소는 첫 번째 인자에서 시작하여, 두 번째 인자에서 바로 이전 요소까지입니다. 두 번째 인자는 생략 가능하며, 생략하거나 배열의 길이보다 큰 값을 전달하면 배열의 끝까지 추출합니다.

   ```jsx
   const myArray = ['apple', 'banana', 'cherry', 'durian', 'elderberry'];
   console.log(myArray.slice(1, 4));
   console.log(myArray.slice());
   console.log(myArray.slice(0, 10));
   ```

1. sort()

   sort() 메소드는 배열의 요소를 정렬하는데 사용됩니다. 메소드를 호출하면 배열을 변경하며, 정렬된 배열을 반환합니다.

   ```jsx
   const avengers = ['아이언맨', '스파이더맨', '헐크', '토르'];
   console.log(avengers.sort());
   ```

   잘 작동하고 있습니다! 그럼 원소의 값을 숫자형으로 바꾸면 어떨까요??

   ```jsx
   const nums = [3, 1, 8, 6];
   console.log(nums.sort());

   const nums2 = [23, 5, 1000, 42];
   console.log(nums2.sort());
   ```

   숫자를 정렬하려고 하면 의도와는 다르게 정렬이 되는데요,
   이때 정렬 방식은 원소를 문자열로 전환한 후에 [유니코드 포인트](https://en.wikipedia.org/wiki/List_of_Unicode_characters)의 순서대로 변환하기 때문입니다.(포인트 : 문자에 부여한 고유한 16진수 숫자값)

   숫자형 데이터 정렬의 이러한 단점을 해결하기 위해 비교 함수(compareFunction)를 사용할 수 있습니다.

   비교 함수가 제공되면 원소의 순서는 비교 함수의 반환 값에 따라 정렬됩니다.

   비교 함수의 두 인자 a, b를 비교해서(즉, 빼서) 0보다 작은 수 즉, 음수가 나오면 a를 앞으로 위치하고, 두 인자를 뺐는데 0보다 큰 양수가 나오면  b를 앞으로 위치합니다. 0이 나오면 위치를 변경하지 않습니다.

   정상 작동되는 코드로 살펴보겠습니다.

   ```jsx
   let numbers = [4, 2, 5, 1, 3];
   numbers.sort((a, b) => a - b);
   console.log(numbers);
   ```

1. forEach()

   forEach() 메소드는 배열의 각 요소에 대해 주어진 함수를 실행합니다. 이 때, 함수는 인자로 배열 요소, 인덱스를 받습니다. forEach() 메소드는 배열의 요소를 순환하면서 해당 요소를 함수로 전달하고, 이 함수가 각 요소에 대해 실행됩니다.

   ```jsx
   const arr = ['참외', '키위', '감귤'];
   arr.forEach(function (item, index) {
     console.log(item, index);
     arr[index] = index;
   });

   // 결과
   // 참외 0
   // 키위 1
   // 감귤 2
   ```

   forEach() 메소드는 배열의 각 요소에 대해 특정 작업을 수행할 때 사용됩니다. 예를 들어, 배열의 각 요소를 이용하여 다른 배열을 만들거나, 요소를 삭제하거나, 값을 변경하는 등의 작업을 수행할 수 있습니다.

   ```jsx
   const avengers = ['spiderman', 'ironman', 'hulk', 'thor'];

   const newAvengers = [];
   avengers.forEach(function (item) {
     newAvengers.push('💖' + item + '💖');
   });
   ```

1. map()

   map() 메소드는 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 결과를 새로운 배열로 반환합니다.

   ```jsx
   const arr = [1, 2, 3];
   const newArr = arr.map(function (item, index) {
     return item * index;
   });

   console.log(newArr);
   ```

   map() 메소드의 첫 번째 인자로는 배열의 각 요소를 처리할 함수를, 두번째는 요소의 인덱스를 전달합니다. 이 함수는 배열의 각 요소를 매개변수로 받아 처리한 후, 그 결과를 반환합니다.

   아래처럼 배열 안에 객체에서 데이터를 뽑는 형태로도 사용합니다.

   ```jsx
   const data = [
     {
       _id: '642ba3980785cecff3f39a8d',
       index: 0,
       age: 28,
       eyeColor: 'green',
       name: 'Annette Middleton',
       gender: 'female',
       company: 'KINETICA',
     },
     {
       _id: '642ba398d0fed6e17f2f50c9',
       index: 1,
       age: 37,
       eyeColor: 'green',
       name: 'Kidd Roman',
       gender: 'male',
       company: 'AUSTECH',
     },
     {
       _id: '642ba39827d809511d00dd8d',
       index: 2,
       age: 39,
       eyeColor: 'brown',
       name: 'Best Ratliff',
       gender: 'male',
       company: 'PRISMATIC',
     },
   ];

   // const ages = data.map(item => item.age);
   const ages = data.map((item) => item['age']);
   ```

1. includes

   요소가 포함이 되어 있으면 true 아니면 false를 반환합니다.

   ```jsx
   const arr1 = ['hello', 'world', 'hojun'];
   arr1.includes('world');

   const arr1 = ['hello', 'world', 'hojun'];
   arr1.includes('leehojun');

   const arr1 = ['hello', 'world', 'hojun'];
   arr1.includes('jun');
   ```

1. join

   문자열로 연결할 때 사용합니다.

   ```jsx
   const arr1 = ['hello', 'world', 'hojun'];
   arr1.join('!'); // hello!world!hojun

   const arr2 = ['010', '1034', '1100'];
   arr2.join('-'); // 010-1034-1100

   const arr3 = [010, 1034, 1100];
   arr3.join('-'); // 이렇게 하시면 안됩니다. 0으로 시작하면 진수로 생각합니다.

   // 0b100 // b는 바이너리의 첫글자입니다.
   // 0o100 // o는 옥타의 첫글자입니다.
   // 0x100 // x는 헥사를 표현합니다.
   ```
