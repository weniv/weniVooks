---
chapter: Pandas :네 번째 걸음
title: Pandas Series
date: 2024-07-12
---
::img{width="500" alt="DALLE" src="/images/essentials-numpy-pandas/chapter04/pandas.png"}

# 1. Series 객체
![피그잼](/images/essentials-numpy-pandas/chapter04/series.png )

Pandas의 Series는 데이터 분석에서 중요한 역할을 하는 1차원 데이터 구조입니다. 이는 단일 데이터 타입을 가진 요소들의 순서 있는 집합으로, 각 요소마다 고유한 식별자인 인덱스가 부여됩니다. Series는 주로 단일 열 또는 행의 데이터를 다룰 때 사용되며, 시계열 데이터 분석이나 범주형 데이터 처리에 특히 유용합니다.

Series의 주요 특징으로는 크기가 고정되어 있어 생성 후 변경이 불가능하다는 점과 인덱스를 통해 데이터에 빠르게 접근할 수 있다는 점이 있습니다. 또한, NumPy 배열과 유사하지만 레이블된 인덱스를 사용한다는 점에서 차이가 있으며, 이로 인해 더 풍부한 기능을 제공합니다.

각 데이터 포인트에 레이블이 부여되어 있어 직관적인 데이터 접근이 가능하며, 이는 데이터 검색과 조작을 용이하게 합니다. Series는 그 유연성과 효율성 때문에 데이터 과학자와 분석가들 사이에서 널리 사용되는 도구입니다. 특히 단일 변수에 대한 통계 계산이나 데이터 시각화 작업에서 큰 강점을 발휘합니다.

자, 이제 Series에 대해 기본적인 이해를 하셨을 거예요. 혹시 Series를 직접 만들어보고 싶으신가요? 아니면 Series로 할 수 있는 재미있는 작업들에 대해 더 알아볼까요?

# 2. Series 생성
Series를 생성하는 네 가지 방법에 대해 알아보겠습니다. 첫 번째 방법은 리스트를 사용하여 Series를 생성하는 것입니다. 이 방법은 기본 인덱스, 즉 0부터 시작하는 정수를 가진 Series를 만들어냅니다. 예를 들어, pd.Series([1, 3, 5, 7, 9])와 같이 작성하면 리스트 [1, 3, 5, 7, 9]를 Series로 변환할 수 있습니다.

두 번째 방법은 NumPy 배열을 사용하여 Series를 생성하는 것입니다. 이 방법 역시 기본 인덱스를 사용하며, pd.Series(np.array([2, 4, 6, 8, 10]))와 같이 작성하면 NumPy 배열 [2, 4, 6, 8, 10]을 Series로 변환할 수 있습니다.

세 번째 방법은 사용자가 직접 정의한 인덱스로 Series를 생성하는 것입니다. 이 방법은 리스트와 함께 사용자가 지정한 인덱스를 사용하여 Series를 만듭니다. 예를 들어, pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])와 같이 작성하면 리스트 [1, 3, 5, 7, 9]를 인덱스 ['a', 'b', 'c', 'd', 'e']와 함께 Series로 변환할 수 있습니다.

마지막 방법은 딕셔너리를 사용하여 Series를 생성하는 것입니다. 이 경우 딕셔너리의 키가 Series의 인덱스가 됩니다. 예를 들어, pd.Series({'a': 1, 'b': 3, 'c': 5, 'd': 7, 'e': 9})와 같이 작성하면 딕셔너리 {'a': 1, 'b': 3, 'c': 5, 'd': 7, 'e': 9}를 Series로 변환할 수 있습니다.

이렇게 네 가지 방법을 통해 다양한 형태의 데이터를 Series로 만들 수 있습니다. 각 방법은 상황에 따라 유용하게 사용될 수 있으며, 데이터의 형태와 원하는 인덱스 구조에 따라 적절한 방법을 선택하면 됩니다.
```python-exec
import pandas as pd
import numpy as np

# 리스트로부터 Series 생성
s1 = pd.Series([1, 3, 5, 7, 9])
print("리스트로 생성한 Series:")
print(s1)

# NumPy 배열로부터 Series 생성
s2 = pd.Series(np.array([2, 4, 6, 8, 10]))
print("NumPy 배열로 생성한 Series:")
print(s2)

# 사용자 정의 인덱스로 Series 생성
s3 = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("사용자 정의 인덱스를 가진 Series:")
print(s3)

# 딕셔너리로부터 Series 생성
d = {'a': 1, 'b': 3, 'c': 5, 'd': 7, 'e': 9}
s4 = pd.Series(d)
print("딕셔너리로 생성한 Series:")
print(s4)
```



:::div{.callout}

**Tip !**
| 방법 | 예시 코드 | 결과 |
|------|-----------|------|
| 리스트 사용 | `pd.Series([1, 3, 5, 7, 9])` | 0    1<br>1    3<br>2    5<br>3    7<br>4    9 |
| NumPy 배열 사용 | `pd.Series(np.array([2, 4, 6, 8, 10]))` | 0     2<br>1     4<br>2     6<br>3     8<br>4    10 |
| 사용자 정의 인덱스 | `pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])` | a    1<br>b    3<br>c    5<br>d    7<br>e    9 |
| 딕셔너리 사용 | `pd.Series({'a': 1, 'b': 3, 'c': 5, 'd': 7, 'e': 9})` | a    1<br>b    3<br>c    5<br>d    7<br>e    9 |

이 표를 보면 각 방법이 어떻게 다른 결과를 만들어내는지 쉽게 이해할 수 있습니다. 리스트와 NumPy 배열을 사용할 때는 기본 정수 인덱스가 자동으로 생성되고, 사용자 정의 인덱스나 딕셔너리를 사용할 때는 지정한 레이블이 인덱스가 됩니다. 이러한 다양한 방법을 통해 우리는 여러 형태의 데이터를 손쉽게 Series로 변환하고 활용할 수 있습니다.
:::

# 3. 인덱스와 값 접근

## 3.1 인덱스와 값 반환
![피그잼](/images/essentials-numpy-pandas/chapter04/value.png )

Series 객체의 주요 속성에는 인덱스와 값을 반환하는 두 가지가 있습니다. 첫 번째로, `'s.index'`를 사용하면 해당 Series의 인덱스를 얻을 수 있습니다. 이는 Series의 각 요소에 대응하는 레이블이나 식별자를 확인할 때 유용합니다. 두 번째로, `'s.values'`를 사용하면 Series에 저장된 실제 데이터 값들을 NumPy 배열 형태로 얻을 수 있습니다. 이 속성은 Series의 데이터를 다른 NumPy 연산이나 함수에 사용하고자 할 때 특히 유용합니다.

```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("인덱스:", s.index)
print("값:", s.values)
```


:::div{.callout}

**Tip !**

's.index'는 Series의 '이름표'를 보여줍니다. 이 이름표는 각 데이터 조각을 구별하는 데 사용됩니다. 마치 책장의 책들에 붙인 스티커와 같아요. 이 이름표를 통해 우리는 특정 데이터를 쉽게 찾을 수 있습니다.
다음으로, 's.values'는 Series의 '내용물'을 보여줍니다. 이는 실제로 Series에 담긴 데이터를 의미합니다. 책장 비유를 계속 사용하자면, 이는 책장에 있는 책들의 내용과 같습니다
:::

## 3.2 요소 접근
![피그잼](/images/essentials-numpy-pandas/chapter04/loc_iloc.png )

Series에서 특정 데이터를 찾는 방법에는 두 가지가 있습니다. 첫 번째는 `'s.iloc[]'`를 사용하는 방법입니다. 이는 마치 배열에서 순서대로 데이터를 찾는 것과 비슷합니다. 예를 들어, 's.iloc[1]'이라고 하면 Series의 두 번째 데이터를 가져옵니다. 여기서 주의할 점은 컴퓨터는 0부터 세기 시작하므로, 1은 실제로 두 번째 위치를 의미한다는 것입니다.
두 번째 방법은 `'s.loc[]'`를 사용하는 것입니다. 이 방법은 우리가 데이터에 붙인 이름표를 이용해 데이터를 찾습니다. 예를 들어, 's.loc['c']'라고 하면 'c'라는 이름표가 붙은 데이터를 가져옵니다. 이는 마치 책장에서 책 제목을 보고 책을 찾는 것과 비슷합니다.

```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("두 번째 요소 (iloc):", s.iloc[1])
print("인덱스 'c'의 값 (loc):", s.loc['c'])
```

## 3.3 Slicing
![피그잼](/images/essentials-numpy-pandas/chapter04/slicing_label_nonlabel.png )

Series에서 슬라이싱은 데이터의 특정 부분을 선택하여 추출하는 기능입니다. 기본 형식은 's[시작:끝]'입니다. Series의 라벨 인덱싱을 사용한 슬라이싱에서는 시작점과 끝점 모두가 결과에 포함되는 특별한 규칙이 적용됩니다.
그러나 이는 라벨 인덱싱에만 해당합니다. Series에서 정수 위치 인덱스를 사용한 슬라이싱이나 일반적인 파이썬 슬라이싱에서는 시작점은 포함되지만, 끝점은 포함되지 않습니다. 이러한 차이점을 이해하고 적절히 활용하는 것이 중요합니다.

```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("슬라이싱 (a부터 c까지):", s['a':'c'])

```


:::div{.callout}

**Tip !**

예를 들어, 우리가 과일 가게에 있다고 상상해 봅시다. 과일들이 알파벳 순서로 진열되어 있고, 우리는 'a'부터 'c'까지의 과일을 골라야 합니다.
일반적인 슬라이싱: "a에서 시작해서 c 직전까지" (c는 포함되지 않음)
Series의 라벨 슬라이싱: "a에서 시작해서 c까지" (c도 포함됨)
:::

## 3.4 Boolean Indexing
![피그잼](/images/essentials-numpy-pandas/chapter04/s.Boolean_Indexing.png )

Boolean Indexing은 Series에서 특정 조건을 만족하는 데이터만 선택하는 강력한 기능입니다. 이는 마치 우리가 원하는 특성을 가진 항목들만 골라내는 것과 비슷합니다.
이 방법을 사용하면, 우리가 설정한 조건에 맞는 데이터만 골라낼 수 있습니다. 예를 들어, 5보다 큰 값만 선택하거나, 짝수인 값만 선택하는 등의 작업을 쉽게 할 수 있습니다.
```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("5보다 큰 값:", s[s > 5])
```

## 3.5 Fancy Indexing (at, iat)
Fancy Indexing은 Series에서 특정 데이터에 빠르고 효율적으로 접근하는 방법입니다. 이 방법에는 'at'과 'iat'이라는 두 가지 주요 도구가 있습니다.
먼저, 'at'은 라벨을 사용해 데이터에 접근합니다. 이는 마치 책장에서 책 제목을 알고 있어 그 제목으로 바로 책을 찾는 것과 비슷합니다. 예를 들어, s.at['c']는 인덱스가 'c'인 데이터를 바로 가져옵니다.
반면, 'iat'은 위치(숫자)를 사용해 데이터에 접근합니다. 이는 책장에서 "세 번째 책"처럼 위치로 책을 찾는 것과 유사합니다. 예를 들어, s.iat[2]는 Series의 세 번째 데이터를 가져옵니다. (기억하세요, 컴퓨터는 0부터 세기 시작합니다!)
```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("at을 사용한 값 접근:", s.at['c'])
print("iat을 사용한 값 접근:", s.iat[2])
```

:::div{.callout}

**기본 인덱싱 vs 펜시 인데싱**

| 특성 | 기본 인덱싱 (s[...]) | at | iat |
|------|---------------------|----|----|
| 사용 방법 | s['c'] 또는 s[2] | s.at['c'] | s.iat[2] |
| 접근 기준 | 라벨 또는 정수 위치 | 라벨 | 정수 위치 |
| 다중 요소 선택 | 가능 | 불가능 | 불가능 |
| 슬라이싱 | 가능 | 불가능 | 불가능 |
| 불리언 인덱싱 | 가능 | 불가능 | 불가능 |
| 단일 요소 접근 속도 | 상대적으로 느림 | 빠름 | 가장 빠름 |
| 대규모 데이터 처리 | 다양한 작업에 적합 | 단일 요소 접근에 최적화 | 단일 요소 접근에 최적화 |
| 유연성 | 높음 | 제한적 | 제한적 |
| 존재하지 않는 인덱스 처리 | 상황에 따라 다름 | 즉시 에러 발생 | 즉시 에러 발생 |
:::

## 3.5 Fancy Indexing (get)
![피그잼](/images/essentials-numpy-pandas/chapter04/s.get.png )

```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
print("get을 사용한 값 접근:", s.get('c'))
```

:::div{.callout}

**Tip !**
s.get('c')라고 하면 인덱스 'c'에 해당하는 값을 가져옵니다. 만약 'c'라는 인덱스가 없다면, 아무 문제 없이 None을 반환합니다. 이런 특성 때문에 'get' 메서드는 데이터의 존재 여부가 불확실한 상황에서 특히 유용합니다.
:::

# 4. Series 정보 및 속성

## 4.1 데이터타입

먼저,`'s.dtype'`은 Series에 저장된 데이터의 타입을 알려줍니다. 이는 Series가 어떤 종류의 데이터를 담고 있는지 파악하는 데 유용합니다. 예를 들어, 숫자 데이터인지, 문자열 데이터인지, 또는 다른 특별한 타입의 데이터인지 알 수 있습니다.
다음으로, `'s.shape'`는 Series의 형태를 보여줍니다. Series는 1차원 데이터 구조이기 때문에, 이 속성은 주로 Series의 길이를 나타냅니다. 이를 통해 Series에 몇 개의 요소가 있는지 빠르게 확인할 수 있습니다.
마지막으로, `'s.size'`는 Series에 포함된 요소의 총 개수를 반환합니다. 이는 's.shape'와 유사하지만, 더 직접적으로 요소의 개수를 알려줍니다.

```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])

print("데이터 타입:", s.dtype)
print("Series 형태:", s.shape)
print("요소 개수:", s.size)
```


## 4.3 items
![피그잼](/images/essentials-numpy-pandas/chapter04/s.items.png )

Series의 `'items()'` 메서드는 데이터를 살펴보는 유용한 도구입니다. 이 메서드는 Series의 각 요소에 대해 인덱스와 값의 쌍을 제공합니다.
'items()' 메서드를 사용하면 Series의 모든 요소를 순회하면서 각 요소의 인덱스와 값을 동시에 얻을 수 있습니다. 이는 마치 책의 목차를 보면서 각 장의 제목과 페이지 번호를 함께 확인하는 것과 비슷합니다.
```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])
for index, value in s.items():
    print(f"인덱스: {index}, 값: {value}")
```

:::div{.callout}

**Tip !**

`items()` 메서드는 인덱스와 값을 튜플 형태로 반환합니다. 루프를 통해 각 요소에 쉽게 접근할 수 있습니다.
:::

# 5. Series 연산 및 통계

## 5.1 기본 통계
Series 객체는 데이터 분석에 필수적인 여러 가지 기본 통계 기능을 제공합니다. 이러한 기능들은 데이터의 전반적인 특성을 빠르게 파악하는 데 매우 유용합니다.
먼저, `'s.mean()'`은 Series의 모든 값들의 평균을 계산합니다. 이는 데이터의 중심 경향을 나타내는 중요한 지표입니다. 예를 들어, 학급의 평균 점수를 계산할 때 사용할 수 있습니다.
`'s.median()'`은 Series의 중앙값을 계산합니다. 중앙값은 데이터를 크기 순으로 나열했을 때 가운데 위치한 값을 말합니다. 이는 특히 극단값의 영향을 덜 받기 때문에, 데이터에 극단값이 있을 때 유용합니다.
`'s.min()'`과 `'s.max()'`는 각각 Series의 최소값과 최대값을 반환합니다. 이 두 함수는 데이터의 범위를 파악하는 데 도움이 됩니다. 예를 들어, 온도 데이터에서 가장 낮은 온도와 가장 높은 온도를 찾을 때 사용할 수 있습니다.
```python-exec
import pandas as pd

s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])

print("평균:", s.mean())
print("중앙값:", s.median())
print("최소값:", s.min())
print("최대값:", s.max())
```


## 5.2 집계 함수
's.sum()'은 Series의 모든 값을 더한 합계를 계산합니다. 이는 데이터의 총량을 알고 싶을 때 유용합니다. 예를 들어, 한 달 동안의 총 매출액을 계산할 때 사용할 수 있습니다.
's.median()'은 Series의 중앙값을 찾습니다. 중앙값은 데이터를 정렬했을 때 가운데 있는 값으로, 극단적인 값들의 영향을 덜 받기 때문에 평균과 함께 자주 사용됩니다. 예를 들어, 주택 가격의 중앙값은 몇몇 매우 비싼 주택의 영향을 덜 받으므로 전체적인 주택 시장의 상황을 더 잘 반영할 수 있습니다.
's.std()'는 표준편차를 계산합니다. 표준편차는 데이터가 평균으로부터 얼마나 퍼져있는지를 나타내는 지표입니다. 이는 데이터의 변동성을 이해하는 데 중요합니다. 예를 들어, 학생들의 시험 점수의 표준편차가 크다면 점수의 편차가 크다는 것을 의미합니다.

```python-exec
import pandas as pd

s = pd.Series([1, 2, 3, 4, 5])
print("합계:", s.sum())
print("중앙값:", s.median())
print("표준편차:", s.std())
```

## 5.3 연산 함수
's.mean()' 함수는 Series의 평균을 계산합니다. 이 함수는 기본적으로 결측치(NaN)를 무시하고 계산을 수행합니다. 이는 'skipna=True'가 기본 설정이기 때문입니다.
예를 들어, 제시된 코드에서 s = pd.Series([1, 2, np.nan, 4, 5])와 같이 결측치가 포함된 Series가 있을 때, s.mean()은 결측치를 제외한 나머지 값들의 평균을 계산합니다. 이 경우, (1 + 2 + 4 + 5) / 4 = 3이 됩니다.
```python-exec
import pandas as pd
import numpy as np

s = pd.Series([1, 2, np.nan, 4, 5])
print("결측치가 있는 Series의 평균:", s.mean())
print("결측치를 제외한 평균:", s.mean(skipna=True))
```

:::div{.callout}

**Tip !**

`mean()` 함수는 기본적으로 결측치를 제외하고 계산합니다. `skipna=False`로 설정하면 결측치가 있을 경우 결과도 NaN이 됩니다.
:::

## 5.4 Series 간 산술 연산
![피그잼](/images/essentials-numpy-pandas/chapter04/s.add.png )

pandas에서는 Series 객체 간에 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/) 등의 기본적인 산술 연산을 직접 수행할 수 있습니다. 이러한 연산은 각 Series의 동일한 인덱스를 가진 요소들 사이에서 이루어집니다.
예를 들어, s1 + s2를 하면 s1의 'a' 인덱스 값과 s2의 'a' 인덱스 값이 더해지고, 'b' 인덱스 값끼리, 'c' 인덱스 값끼리 더해집니다. 다른 연산들도 마찬가지로 동작합니다.

```python-exec
import pandas as pd

s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
s2 = pd.Series([4, 5, 6], index=['a', 'b', 'c'])

print("Series 덧셈:", s1 + s2)
print("Series 뺄셈:", s1 - s2)
print("Series 곱셈:", s1 * s2)
print("Series 나눗셈:", s1 / s2)
```

:::div{.callout}

**Tip !**

Series 간의 연산은 인덱스가 같은 요소끼리 수행됩니다. 인덱스가 다르면 NaN이 결과로 나타날 수 있습니다.
:::

# 6. 결측치 처리

## 6.1 결측치 확인, 제거, 채우기
![피그잼](/images/essentials-numpy-pandas/chapter04/s.insull_dropna_fillna.png )

's.isnull()' 메서드는 Series의 각 요소가 결측치인지 여부를 확인합니다. 이 메서드는 각 요소에 대해 결측치면 True, 아니면 False를 반환하는 새로운 Series를 생성합니다. 이를 통해 데이터셋에서 결측치의 위치와 개수를 쉽게 파악할 수 있습니다.
's.dropna()' 메서드는 결측치를 포함한 모든 행을 제거한 새로운 Series를 반환합니다. 이 방법은 결측치가 적고 데이터의 손실이 크지 않을 때 유용합니다. 하지만 너무 많은 데이터가 제거될 수 있으므로 신중하게 사용해야 합니다.
's.fillna()' 메서드는 결측치를 지정된 값으로 대체합니다. 예를 들어, 's.fillna(0)'은 모든 결측치를 0으로 채웁니다. 이 방법은 결측치를 특정 값(평균, 중앙값, 최빈값 등)으로 대체하고 싶을 때 유용합니다.
결측치 처리는 데이터 분석의 결과에 큰 영향을 미칠 수 있으므로 신중하게 접근해야 합니다. 어떤 방법을 선택할지는 데이터의 특성과 분석의 목적에 따라 달라집니다. 예를 들어, 센서 데이터에서 결측치는 0으로 채우는 

```python-exec
import pandas as pd
import numpy as np

s_with_na = pd.Series([1, 3, np.nan, 7, 9])
print("결측치 여부:", s_with_na.isnull())
print("결측치 제거:", s_with_na.dropna())
print("결측치 0으로 채우기:", s_with_na.fillna(0))
```

:::div{.callout}

**Tip !**

데이터 분석을 할 때 결측치를 처리하는 것은 매우 중요합니다. `isnull`로 결측치를 확인하고, `dropna`로 결측치를 제거하거나 `fillna`로 특정 값으로 대체할 수 있습니다.
:::

## 6.2 NaN
![피그잼](/images/essentials-numpy-pandas/chapter04/s.Nan_None.png )

NaN(Not a Number)은 데이터셋에서 결측치를 나타내는 대표적인 값이며, Python의 None 값도 Pandas에서는 결측치로 처리됩니다. NaN은 데이터 분석에서 중요한 개념으로, 주로 결측치나 정의되지 않은 값을 나타내는 데 사용됩니다. pandas에서는 이를 효과적으로 다루기 위한 여러 기능을 제공합니다.
NaN은 특히 수치형 데이터에서 자주 사용됩니다. 이는 데이터가 없거나, 계산할 수 없는 경우를 표현합니다. 예를 들어, 0으로 나누기를 시도하거나, 로그의 음수를 계산하려 할 때 NaN이 발생할 수 있습니다.
pandas에서는 Python의 None 값도 NaN으로 취급합니다. 이는 데이터 처리의 일관성을 위한 것으로, 결측치를 다룰 때 유용합니다.
```python-exec
import pandas as pd
import numpy as np

s_with_nan = pd.Series([1, 2, np.nan, 4, 5])
print("NaN이 포함된 Series:")
print(s_with_nan)
print("isnull() 결과:")
print(s_with_nan.isnull())
```
:::div{.callout}

**Tip !**

NaN 값을 다룰 때는 주의가 필요합니다. NaN은 수학적 연산에서 특별하게 취급됩니다. 예를 들어, NaN과의 어떤 연산 결과도 NaN이 됩니다. 이는 데이터 분석 시 예상치 못한 결과를 낳을 수 있으므로, NaN 값의 존재와 그 영향을 항상 인지하고 있어야 합니다.
:::

## 6.3 None

Pandas에서 None 값은 자동으로 NaN(Not a Number)으로 변환됩니다. 이는 데이터 처리의 일관성을 위한 것으로, 수치형 데이터와 비수치형 데이터를 모두 포함하는 Series나 DataFrame에서 결측치를 uniform하게 다룰 수 있게 해줍니다.
예시 코드에서 볼 수 있듯이, None을 포함한 Series를 생성하면 Pandas는 이를 자동으로 처리합니다. 's.isnull()' 메서드를 사용하면 None이 포함된 위치를 True로 표시하는 Boolean Series를 얻을 수 있습니다.

```python-exec
import pandas as pd

s = pd.Series([1, 2, None, 4, 5])
print("None이 포함된 Series:")
print(s)
print("isnull() 결과:")
print(s.isnull())
```



# 7. 데이터 변환 및 조작

## 7.1 Series 정렬
![피그잼](/images/essentials-numpy-pandas/chapter04/s.sort.png )

`'s.sort_values()'` 메서드는 Series의 `값`을 기준으로 정렬합니다. 기본적으로 오름차순으로 정렬하지만, 'ascending=False' 매개변수를 사용하여 내림차순 정렬도 가능합니다. 이 메서드는 데이터의 크기나 빈도를 기준으로 정렬하고 싶을 때 유용합니다. 예를 들어, 판매량이 가장 많은 제품부터 정렬하거나, 점수가 가장 높은 학생부터 정렬할 때 사용할 수 있습니다. 
`'s.sort_index()'` 메서드는 Series의 `인덱스`를 기준으로 정렬합니다. 이 역시 기본적으로 오름차순이며, 'ascending=False'로 내림차순 정렬이 가능합니다. 이 메서드는 특히 시계열 데이터를 다룰 때 유용합니다. 예를 들어, 날짜별로 정렬된 주가 데이터나 시간순으로 정렬된 센서 데이터를 얻을 수 있습니다.

```python-exec
import pandas as pd
import numpy as np

s_random = pd.Series(np.random.randn(5), index=['b', 'a', 'c', 'e', 'd'])
print("값 기준 정렬:", s_random.sort_values())
print("인덱스 기준 정렬:", s_random.sort_index())
```


## 7.2 함수 적용
![피그잼](/images/essentials-numpy-pandas/chapter04/s,,apply_map.png )

`'s.apply()'` 메서드는 Series의 각 요소에 지정된 함수를 적용합니다. 이 함수는 단일 값을 인수로 받아 새로운 값을 반환해야 합니다. 'apply()'는 복잡한 연산이나 조건부 로직을 적용할 때 특히 유용합니다. 예시 코드에서는 lambda 함수를 사용해 각 요소를 제곱하고 있습니다. 이 방법으로 데이터 정규화, 로그 변환, 조건부 값 변경 등 다양한 작업을 수행할 수 있습니다.
`'s.map()'` 메서드는 각 요소를 다른 값으로 매핑합니다. 이는 주로 딕셔너리나 함수를 사용하여 수행됩니다. 예시 코드에서는 딕셔너리를 사용해 인덱스 값을 대문자로 매핑하고 있습니다. 'map()'은 범주형 데이터를 숫자로 인코딩하거나, 코드를 실제 값으로 변환하는 등의 작업에 유용합니다.

```python-exec
import pandas as pd

# Series 생성
s = pd.Series([1, 3, 5, 7, 9], index=['a', 'b', 'c', 'd', 'e'])

# 제곱 적용
print("제곱 적용:", s.apply(lambda x: x**2))

# 값에 대한 매핑 딕셔너리 생성
mapping = {1: 'A', 3: 'B', 5: 'C', 7: 'D', 9: 'E'}

# map() 함수를 사용하여 값 매핑
print("값 매핑:", s.map(mapping))
```
:::div{.callout}

**Tip !**

람다 함수는 이름 없는 작은 일회용 함수입니다. 간단한 계산을 빠르게 수행하고자 할 때 사용하는 편리한 도구입니다.
:::

# 8. 고급 기능

## 8.1 MultiIndex 
![피그잼](/images/essentials-numpy-pandas/chapter04/s.multiindex.png )

다중 인덱스를 생성하는 방법 중 하나는 'MultiIndex.from_tuples' 메서드를 사용하는 것입니다. 이 메서드는 튜플 리스트를 입력받아 각 튜플의 요소들을 인덱스의 각 레벨로 사용합니다. 또한, 'names' 매개변수를 통해 각 레벨에 이름을 부여할 수 있어, 데이터의 의미를 더 명확하게 표현할 수 있습니다.
```python-exec
import pandas as pd

multi_index = pd.MultiIndex.from_tuples([('A', 1), ('A', 2), ('B', 1), ('B', 2)], names=['letter', 'number'])
s = pd.Series([1, 2, 3, 4], index=multi_index)
print("다중 인덱스 Series:")
print(s)
```


## 8.2 데이터 결합 
![피그잼](/images/essentials-numpy-pandas/chapter04/s.combined.png )

'pd.concat()' 함수는 기본적으로 행 방향(위아래)으로 데이터를 결합합니다. 이는 'axis=0' 매개변수로 지정되며, 기본값입니다. 예시 코드의 첫 번째 결합에서 s1과 s2가 이러한 방식으로 결합되었습니다. 이 경우, 두 Series의 인덱스가 서로 다르기 때문에 새로운 Series가 생성되며, 원래의 인덱스가 그대로 유지됩니다.
열 방향(좌우)으로 데이터를 결합하려면 'axis=1'을 지정합니다. 두 번째 예시에서 s1과 s3가 이 방식으로 결합되었습니다. 이 경우, 결과는 DataFrame이 되며, 두 Series의 인덱스가 새로운 DataFrame의 행 인덱스가 됩니다. 공통된 인덱스('a'와 'c')는 양쪽 데이터가 모두 표시되고, 한쪽에만 있는 인덱스('b'와 'e')는 다른 쪽에 NaN 값이 채워집니다.

```python-exec
import pandas as pd

s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
s2 = pd.Series([4, 5, 6], index=['d', 'e', 'f'])
s_combined = pd.concat([s1, s2])
print("결합된 Series:")
print(s_combined)

s3 = pd.Series([7, 8, 9], index=['a', 'c', 'e'])
s_merged = pd.concat([s1, s3], axis=1)
print("열 방향으로 결합된 Series:")
print(s_merged)
```

:::div{.callout}

**Tip !**

`pd.concat()`은 Series나 DataFrame을 결합하는 강력한 함수입니다. `axis=0`(기본값)은 행 방향, `axis=1`은 열 방향 결합을 수행합니다.
:::

이번 장에서는 Pandas의 Series 객체에 대해 학습했습니다. Series의 기본 개념, 생성 방법, 데이터 접근 및 조작, 기본 통계 계산, 결측치 처리, 정렬, 그리고 데이터 변환 등 주요 기능을 살펴보았습니다. 이러한 Series의 다양한 기능들은 데이터 분석 작업을 효율적으로 수행하는 데 큰 도움이 됩니다.