---
chapter: Pandas :네 번째 걸음
title: Pandas DataFrame 2 
date: 2024-07-17
---

# 1. 결측치 처리

결측치(missing values)는 데이터셋에서 값이 없는 부분을 말합니다. 이는 데이터 수집 과정에서의 오류, 응답 거부, 센서 고장 등 다양한 이유로 발생할 수 있습니다. 결측치를 적절히 처리하는 것은 데이터 분석의 정확성과 신뢰성을 위해 중요합니다.

## 1.1 결측치 확인

데이터프레임에서 결측치를 확인하는 방법에는 여러 가지가 있습니다.

```python-exec
import pandas as pd
import numpy as np

df = pd.DataFrame({
    'A': [1, 2, np.nan, 4],
    'B': [5, np.nan, np.nan, 8],
    'C': [9, 10, 11, 12]
})

print("데이터프레임:")
print(df)

print("결측치 확인 (True가 결측치):")
print(df.isnull())

print("결측치 개수:")
print(df.isnull().sum())

print("결측치가 있는 행 확인:")
print(df[df.isnull().any(axis=1)])

print("결측치 비율:")
print(df.isnull().mean())
```


:::div{.callout}

**Tip !**

 isnull()로 어디에 결측치가 있는지 확인해보세요.
 :::


## 1.2 결측치 제거

`dropna()` 메서드를 사용하여 결측치가 있는 행이나 열을 제거할 수 있습니다.

```python-exec
df_dropna = df.dropna()
print("결측치가 있는 모든 행 제거 후 데이터프레임:")
print(df_dropna)

df_dropna_thresh = df.dropna(thresh=2)  # 최소 2개 이상의 비결측치가 있는 행만 유지
print("최소 2개 이상의 비결측치가 있는 행만 유지:")
print(df_dropna_thresh)
```


:::div{.callout}

**Tip !**

dropna()로 결측치가 있는 행이나 열을 지울 수 있어요.
 :::


## 1.3 결측치 대체

`fillna()` 메서드를 사용하여 결측치를 다른 값으로 대체할 수 있습니다.

```python-exec
df_fillna = df.fillna(0)
print("결측치를 0으로 대체한 데이터프레임:")
print(df_fillna)

df_fillna_method = df.fillna(method='ffill')  # 앞의 값으로 채우기
print("결측치를 앞의 값으로 대체한 데이터프레임:")
print(df_fillna_method)

df_fillna_mean = df.fillna(df.mean())  # 평균값으로 채우기
print("결측치를 평균값으로 대체한 데이터프레임:")
print(df_fillna_mean)
```


:::div{.callout}

**Tip !**

fillna()로 결측치를 다른 값으로 채울 수 있어요.
 :::


# 2. 데이터 변환 및 조작

데이터 변환 및 조작은 원본 데이터를 분석에 적합한 형태로 가공하는 과정입니다. 이는 데이터 전처리 단계에서 매우 중요한 부분을 차지합니다.

## 2.1 데이터 타입 변환

데이터프레임의 열의 데이터 타입을 변환하는 것은 메모리 사용 최적화나 특정 연산을 위해 필요할 수 있습니다.

```python-exec
df = pd.DataFrame({
    'A': ['1', '2', '3', '4'],
    'B': [1.0, 2.0, 3.0, 4.0],
    'C': [1, 2, 3, 4]
})

print("원본 데이터프레임 타입:")
print(df.dtypes)

df['A'] = df['A'].astype('int')
df['B'] = df['B'].astype('float32')
df['C'] = df['C'].astype('str')

print("변환 후 데이터프레임 타입:")
print(df.dtypes)
```


:::div{.callout}

**Tip !**

astype()으로 데이터 타입을 바꿀 수 있어요. 숫자, 문자열 등으로 변환해보세요.
 :::


## 2.2 값 기준 정렬

```python-exec
df = pd.DataFrame({
    'A': [3, 1, 4, 2],
    'B': ['b', 'a', 'd', 'c']
})

print("원본 데이터프레임:")
print(df)

df_sorted = df.sort_values(by='A')
print("A 열 기준 오름차순 정렬:")
print(df_sorted)

df_sorted_multi = df.sort_values(by=['B', 'A'], ascending=[False, True])
print("B 열 기준 내림차순, A 열 기준 오름차순 정렬:")
print(df_sorted_multi)
```


:::div{.callout}

**Tip !**

sort_values()로 원하는 열 기준으로 데이터를 정렬할 수 있어요.
:::


## 2.3 인덱스 기준 정렬

```python-exec
df.index = ['d', 'b', 'a', 'c']
print("인덱스가 있는 데이터프레임:")
print(df)

df_sorted_index = df.sort_index()
print("인덱스 기준 오름차순 정렬:")
print(df_sorted_index)
```



:::div{.callout}

**Tip !**

sort_index()로 인덱스 기준으로 정렬할 수 있어요.
:::


# 3. 데이터 결합 및 병합

데이터 결합 및 병합은 여러 데이터셋을 하나로 합치는 과정입니다. 이는 다양한 소스에서 얻은 데이터를 통합하여 분석할 때 매우 유용합니다.

## 3.1 concat 함수

`concat` 함수는 데이터프레임을 단순히 연결합니다. 주로 동일한 열을 가진 데이터프레임을 위아래로 연결하거나, 동일한 인덱스를 가진 데이터프레임을 옆으로 연결할 때 사용합니다.

```python-exec
df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

df_concat_vertical = pd.concat([df1, df2])
print("수직으로 연결한 데이터프레임:")
print(df_concat_vertical)

df3 = pd.DataFrame({'C': [9, 10], 'D': [11, 12]})
df_concat_horizontal = pd.concat([df1, df3], axis=1)
print("수평으로 연결한 데이터프레임:")
print(df_concat_horizontal)
```

:::div{.callout}

**Tip !**

concat()은 레고 블록 붙이기 같아요. 비슷한 형태의 데이터를 이어붙일 때 써요.
:::


## 3.2 merge 함수

`merge` 함수는 두 데이터프레임을 특정 키를 기준으로 병합합니다. SQL의 JOIN과 유사한 기능을 제공합니다.

```python-exec
df1 = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})
df2 = pd.DataFrame({'key': ['A', 'B', 'D'], 'value2': [4, 5, 6]})

df_merged = pd.merge(df1, df2, on='key', how='inner')
print("내부 병합 (inner join):")
print(df_merged)

df_merged_outer = pd.merge(df1, df2, on='key', how='outer')
print("외부 병합 (outer join):")
print(df_merged_outer)

df_merged_left = pd.merge(df1, df2, on='key', how='left')
print("왼쪽 병합 (left join):")
print(df_merged_left)
```


:::div{.callout}

**Tip !**

merge()는 퍼즐 맞추기 같아요. 공통된 열을 기준으로 데이터를 합쳐요.
:::

## 3.3 join 함수

`join` 함수는 인덱스를 기준으로 데이터프레임을 병합합니다.

```python-exec
df1 = pd.DataFrame({'value1': [1, 2, 3]}, index=['A', 'B', 'C'])
df2 = pd.DataFrame({'value2': [4, 5, 6]}, index=['A', 'B', 'D'])

df_joined = df1.join(df2, how='inner')
print("내부 조인:")
print(df_joined)

df_joined_outer = df1.join(df2, how='outer')
print("외부 조인:")
print(df_joined_outer)
```


:::div{.callout}

**Tip !**

join()은 인덱스를 기준으로 데이터를 합쳐요.
:::
# 4. 데이터 결합 시 발생할 수 있는 문제와 해결 방법

```python-exec
import pandas as pd

df = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.1, 4.2, 5.9, 2.8, 3.3, 5.4],
    '선호_종류': ['에스프레소', '아메리카노', '카푸치노', '카페라떼', '드립커피', '카페오레'],
    '카페_수': [25000, 32000, 18000, 12000, 22000, 15000],
    '평균_가격': [2.5, 3.8, 1.5, 4.2, 3.5, 2.8]
})

print("원본 커피 소비 데이터프레임:")
print(df)
print("")
```

## 4.1 키 불일치

```python-exec
# GDP 데이터를 담은 새로운 데이터프레임
df_gdp = pd.DataFrame({
    'Country': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    'GDP': [1830, 21400, 1900, 1630, 5150, 2700]
})

print("GDP 데이터:")
print(df_gdp)
print("단순 병합 시도 (실패):")
print(pd.merge(df, df_gdp))
```

해결 방법:

```python-exec
print("해결 방법 (left_on, right_on 사용):")
result = pd.merge(df, df_gdp, left_on='국가', right_on='Country')
result = result.drop('Country', axis=1)  # 중복 열 제거
print(result)
```

## 4.2 중복 열

```python-exec
# 다른 연도의 연간 소비량 데이터
df_new_consumption = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.3, 4.4, 6.1, 3.0, 3.5, 5.6]
})

print("새로운 연간 소비량 데이터:")
print(df_new_consumption)
print("단순 병합 (열 이름 중복):")
print(pd.merge(df, df_new_consumption))
```

해결 방법:

```python-exec
print("해결 방법 (suffixes 사용):")
result = pd.merge(df, df_new_consumption, on='국가', suffixes=('_2022', '_2023'))
print(result)
```

## 4.3 데이터 유실

```python-exec
# 일부 국가만 포함된 수출량 데이터
df_partial = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '독일'],
    '수출량': [1500, 2000, 1000, 1200]
})

print("부분적인 수출량 데이터:")
print(df_partial)
print("내부 조인 결과 (데이터 유실):")
print(pd.merge(df, df_partial, on='국가'))
```

해결 방법:

```python-exec
print("해결 방법 (외부 조인 사용):")
result = pd.merge(df, df_partial, on='국가', how='outer')
print(result)
```

## 4.4 데이터 타입 불일치

```python-exec
# 문자열로 된 카페 수 데이터
df_str_cafes = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '카페_수_문자열': ['25,000', '32,000', '18,000', '12,000', '22,000', '15,000']
})

print("문자열 형식의 카페 수 데이터:")
print(df_str_cafes)
print("데이터 타입 확인:")
print(df['카페_수'].dtype)
print(df_str_cafes['카페_수_문자열'].dtype)
```

해결 방법:

```python-exec
print("해결 방법 (데이터 타입 변환):")
df_str_cafes['카페_수_문자열'] = df_str_cafes['카페_수_문자열'].str.replace(',', '').astype(int)
result = pd.merge(df, df_str_cafes, on='국가')
print(result)
```
이렇게 "커피 소비" 데이터프레임을 기반으로 각 문제 상황을 구체적으로 보여주고, 그에 대한 해결 방법을 제시했습니다. 이를 통해 데이터 결합 시 발생할 수 있는 다양한 문제들과 그 해결 방법을 더 명확하게 이해할 수 있을 것입니다.
