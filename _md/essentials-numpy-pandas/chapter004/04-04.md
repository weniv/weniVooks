---
chapter: Pandas :네 번째 걸음
title: Pandas DataFrame 2 
date: 2024-07-17
---

# 1. 결측치 처리

결측치는 데이터 분석에서 중요하게 다뤄야 할 문제로, 데이터의 품질과 분석 결과의 신뢰성에 직접적인 영향을 미칩니다. 이는 설문조사에서의 무응답, 센서 오작동, 데이터 전송 오류, 또는 단순히 정보 누락 등 다양한 원인으로 발생할 수 있습니다. pandas에서는 결측치를 NaN(Not a Number)으로 표현하며, 이를 식별하고 처리하는 여러 방법을 제공합니다.

## 1.1 결측치 확인

isnull() 메서드는 데이터셋 내의 결측치를 식별하는 데 사용됩니다. 이 메서드는 데이터프레임이나 시리즈의 각 요소를 검사하여 해당 값이 결측치인지 아닌지를 판단합니다. 결과로 반환되는 불리언 마스크는 원본 데이터와 동일한 구조를 가지며, 각 위치에 True 또는 False 값을 할당하여 결측치 여부를 나타냅니다. 이를 통해 데이터 분석가는 결측치의 분포와 패턴을 쉽게 파악할 수 있으며, 이는 데이터 전처리 단계에서 결측치 처리 전략을 수립하는 데 필수적인 정보를 제공합니다. isnull() 메서드는 NaN, None, NaT 등 다양한 형태의 결측치를 인식할 수 있어, 복잡한 데이터셋에서도 신뢰성 있는 결측치 탐지가 가능합니다. 

```python-exec
import pandas as pd
import numpy as np

df = pd.DataFrame({
    'A': [1, 2, np.nan, 4],
    'B': [5, np.nan, np.nan, 8],
    'C': [9, 10, 11, 12]
})

print("데이터프레임:")
print(df)

print("결측치 확인 (True가 결측치):")
print(df.isnull())

print("결측치 개수:")
print(df.isnull().sum())

print("결측치가 있는 행 확인:")
print(df[df.isnull().any(axis=1)])

print("결측치 비율:")
print(df.isnull().mean())
```


## 1.2 결측치 제거

dropna() 메서드는 데이터프레임에서 결측치를 포함한 행이나 열을 제거하는 데 사용됩니다. 이 메서드는 데이터 전처리 과정에서 결측치를 처리하는 가장 간단하고 직접적인 방법 중 하나입니다. dropna()는 다양한 매개변수를 통해 사용자가 결측치 제거 방식을 세밀하게 제어할 수 있게 해줍니다. 예를 들어, axis 매개변수를 사용하여 행을 제거할지 열을 제거할지 선택할 수 있으며, how 매개변수로 모든 값이 결측치인 경우에만 제거할지, 하나라도 결측치가 있으면 제거할지 결정할 수 있습니다. 

```python-exec
df_dropna = df.dropna()
print("결측치가 있는 모든 행 제거 후 데이터프레임:")
print(df_dropna)

df_dropna_thresh = df.dropna(thresh=2)  # 최소 2개 이상의 비결측치가 있는 행만 유지
print("최소 2개 이상의 비결측치가 있는 행만 유지:")
print(df_dropna_thresh)
```

## 1.3 결측치 대체

fillna() 메서드는 데이터프레임의 결측치를 사용자가 지정한 값이나 방법으로 대체할 수 있게 해줍니다. 이 메서드는 데이터의 완전성을 유지하면서 결측치를 처리하고자 할 때 널리 사용됩니다. fillna()는 다양한 옵션을 제공하여 결측치 대체 방식을 세밀하게 조정할 수 있습니다. 예를 들어, 특정 값으로 모든 결측치를 채우거나, 각 열의 평균, 중앙값, 최빈값 등 통계량으로 대체할 수 있습니다. 또한 'ffill' 또는 'bfill' 메서드를 사용하여 이전 값이나 다음 값으로 결측치를 채울 수도 있습니다. limit 매개변수를 통해 연속된 결측치 중 일부만 채우도록 제한할 수 있으며, inplace 매개변수로 원본 데이터를 직접 수정할지 새로운 복사본을 반환할지 선택할 수 있습니다.

```python-exec
df_fillna = df.fillna(0)
print("결측치를 0으로 대체한 데이터프레임:")
print(df_fillna)

df_fillna_method = df.fillna(method='ffill')  # 앞의 값으로 채우기
print("결측치를 앞의 값으로 대체한 데이터프레임:")
print(df_fillna_method)

df_fillna_mean = df.fillna(df.mean())  # 평균값으로 채우기
print("결측치를 평균값으로 대체한 데이터프레임:")
print(df_fillna_mean)
```

# 2. 데이터 변환 및 정렬
데이터 변환 및 조작은 데이터 분석의 핵심 단계로, 원시 데이터를 분석에 적합한 형태로 가공하고 정제하는 과정입니다. 이는 데이터 품질 향상과 분석의 정확성, 효율성 증대에 필수적입니다. 주요 작업으로는 데이터 타입 변경, 스케일 조정, 범주형 변수 인코딩, 이상치 처리 등이 있습니다. 또한 데이터 정렬은 특정 기준에 따라 데이터를 순서대로 배열하는 중요한 조작 기법입니다. 정렬을 통해 데이터의 패턴을 시각적으로 파악하거나 특정 조건에 맞는 데이터를 쉽게 찾을 수 있습니다. 예를 들어, 시계열 데이터의 날짜순 정렬이나 판매 데이터의 금액순 정렬 등이 이에 해당합니다. 이러한 과정들은 데이터에서 의미 있는 정보를 추출하고 효과적인 분석을 수행하는 데 중요한 역할을 합니다.
## 2.1 데이터 타입 변환

데이터프레임의 열 데이터 타입을 변환하는 작업은 데이터 분석과 처리 과정에서 중요한 역할을 합니다. 이는 메모리 사용을 최적화하고, 특정 연산이나 분석 기법을 적용하기 위해 필요할 수 있습니다. 또한, 데이터의 일관성과 정확성을 유지하거나, 특정 라이브러리와의 호환성을 위해서도 타입 변환이 요구될 수 있습니다. pandas 라이브러리에서는 astype() 메서드나 to_numeric(), to_datetime() 등의 함수를 사용하여 간편하게 데이터 타입을 변환할 수 있습니다. 그러나 데이터 손실이나 왜곡을 방지하기 위해 변환 시에는 주의가 필요하며, 변환 전후로 데이터의 특성을 꼼꼼히 확인하는 것이 중요합니다. 

```python-exec
df = pd.DataFrame({
    'A': ['1', '2', '3', '4'],
    'B': [1.0, 2.0, 3.0, 4.0],
    'C': [1, 2, 3, 4]
})

print("원본 데이터프레임 타입:")
print(df.dtypes)

df['A'] = df['A'].astype('int')
df['B'] = df['B'].astype('float32')
df['C'] = df['C'].astype('str')

print("변환 후 데이터프레임 타입:")
print(df.dtypes)
```


:::div{.callout}

**Tip ! 데이터 타입**
| 데이터 타입 | 설명 | 예시 |
|-------------|------|------|
| int64 | 64비트 정수 | 1, -10, 1000 |
| float64 | 64비트 부동소수점 | 3.14, -0.01, 2.0e-3 |
| object | 문자열 또는 혼합 타입 | "Hello", [1, 2, 3] |
| bool | 불리언 값 | True, False |
| datetime64 | 날짜와 시간 | 2023-06-15 14:30:00 |
| timedelta64 | 시간 간격 | 2 days 3 hours |
| category | 범주형 데이터 | "Red", "Green", "Blue" |
 :::


## 2.2 값 기준 정렬
값 기준 정렬은 데이터프레임이나 시리즈의 데이터를 특정 열이나 행의 값을 기준으로 오름차순 또는 내림차순으로 재배열하는 과정입니다. pandas에서는 sort_values() 메서드를 사용하여 이를 수행할 수 있습니다.
오름차순 정렬은 값이 작은 것부터 큰 순서로 배열하는 것으로, sort_values() 메서드의 기본 설정입니다. 내림차순 정렬은 값이 큰 것부터 작은 순서로 배열하며, ascending=False 매개변수를 사용하여 지정할 수 있습니다.
```python-exec
df = pd.DataFrame({
    'A': [3, 1, 4, 2],
    'B': ['b', 'a', 'd', 'c']
})

print("원본 데이터프레임:")
print(df)

df_sorted = df.sort_values(by='A')
print("A 열 기준 오름차순 정렬:")
print(df_sorted)

df_sorted_multi = df.sort_values(by=['B', 'A'], ascending=[False, True])
print("B 열 기준 내림차순, A 열 기준 오름차순 정렬:")
print(df_sorted_multi)
```

## 2.3 인덱스 기준 정렬
pandas에서는 sort_index() 메서드를 사용하여 인덱스를 기준으로 정렬할 수 있습니다. 이 메서드는 기본적으로 인덱스를 오름차순으로 정렬하지만, ascending=False 매개변수를 사용하여 내림차순 정렬도 가능합니다.
예를 들어, df.sort_index()는 데이터프레임을 인덱스 기준으로 오름차순 정렬하고, df.sort_index(ascending=False)는 내림차순으로 정렬합니다. 다중 인덱스의 경우, level 매개변수를 사용하여 특정 레벨의 인덱스를 기준으로 정렬할 수 있습니다.

```python-exec
df.index = ['d', 'b', 'a', 'c']
print("인덱스가 있는 데이터프레임:")
print(df)

df_sorted_index = df.sort_index()
print("인덱스 기준 오름차순 정렬:")
print(df_sorted_index)
```



# 3. 데이터 결합 및 병합

데이터 결합 및 병합은 데이터 분석과 처리에서 핵심적인 작업으로, 여러 데이터셋을 의미 있는 방식으로 통합하는 과정입니다. 이는 다양한 소스에서 얻은 데이터를 하나의 통합된 데이터셋으로 만들어 더 포괄적이고 종합적인 분석을 가능하게 합니다. 이 과정을 통해 개별 데이터셋에서는 얻기 어려운 깊이 있는 인사이트를 도출할 수 있으며, 데이터 간의 복잡한 관계와 패턴을 파악할 수 있습니다. 결과적으로, 데이터 결합은 더 정확하고 신뢰성 있는 의사결정을 지원하는 중요한 도구로 활용됩니다.

## 3.1 concat 함수

concat 함수는 pandas에서 데이터프레임이나 시리즈를 연결하는 데 사용되는 유용한 도구입니다. 이 함수는 주로 유사한 구조를 가진 데이터를 단순히 붙이는 데 적합하며, 기본적으로 데이터를 위아래로 연결하지만 옵션을 변경하여 좌우로도 연결할 수 있습니다. concat은 인덱스 처리, 누락된 데이터 처리, 중복 열 처리 등 다양한 옵션을 제공하여 유연한 데이터 결합이 가능합니다. 

```python-exec
df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

df_concat_vertical = pd.concat([df1, df2])
print("수직으로 연결한 데이터프레임:")
print(df_concat_vertical)

df3 = pd.DataFrame({'C': [9, 10], 'D': [11, 12]})
df_concat_horizontal = pd.concat([df1, df3], axis=1)
print("수평으로 연결한 데이터프레임:")
print(df_concat_horizontal)
```

## 3.2 merge 함수
![피그마](/images/essentials-numpy-pandas/chapter04/join.png )
merge 함수는 마치 퍼즐을 맞추듯 두 개 이상의 데이터프레임을 특정 열을 기준으로 정교하게 결합합니다. 다양한 결합 방식(내부, 외부, 왼쪽, 오른쪽 조인)을 지원하여 복잡한 데이터 구조도 유연하게 다룰 수 있습니다. merge는 여러 열을 기준으로 결합하거나 서로 다른 이름의 열을 매칭할 수 있어, 마치 다기능 공구처럼 다양한 데이터 결합 상황에 대응할 수 있습니다
```python-exec
df1 = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})
df2 = pd.DataFrame({'key': ['A', 'B', 'D'], 'value2': [4, 5, 6]})

df_merged = pd.merge(df1, df2, on='key', how='inner')
print("내부 병합 (inner join):")
print(df_merged)

df_merged_outer = pd.merge(df1, df2, on='key', how='outer')
print("외부 병합 (outer join):")
print(df_merged_outer)

df_merged_left = pd.merge(df1, df2, on='key', how='left')
print("왼쪽 병합 (left join):")
print(df_merged_left)
```

## 3.3 join 함수

join 함수는 주로 인덱스를 기준으로 데이터프레임을 병합하는 데 사용되는 pandas의 메서드입니다. 이는 마치 책의 색인을 사용해 관련 페이지를 찾아가는 것과 유사합니다. join은 기본적으로 간단하고 직관적인 방식으로 작동하여, 특히 시계열 데이터나 이미 잘 정렬된 데이터를 결합할 때 효과적입니다. 인덱스 기반 결합에서는 merge보다 더 빠른 성능을 보일 수 있어, 대규모 데이터셋을 다룰 때 유리할 수 있습니다.

```python-exec
df1 = pd.DataFrame({'value1': [1, 2, 3]}, index=['A', 'B', 'C'])
df2 = pd.DataFrame({'value2': [4, 5, 6]}, index=['A', 'B', 'D'])

df_joined = df1.join(df2, how='inner')
print("내부 조인:")
print(df_joined)

df_joined_outer = df1.join(df2, how='outer')
print("외부 조인:")
print(df_joined_outer)
```

:::div{.callout}

**Tip ! merge 함수 vs join 함수 vs concat 함수**
| 특성 | merge 함수 | join 함수 | concat 함수 |
|------|------------|-----------|-------------|
| 결합 기준 | 열(column) | 인덱스(index) | 축(axis) |
| 사용 방식 | pd.merge(df1, df2) | df1.join(df2) | pd.concat([df1, df2]) |
| 유연성 | 높음 | 중간 | 높음 |
| 복잡한 결합 | 적합 | 덜 적합 | 덜 적합 |
| 성능 (인덱스 기반) | 느림 | 빠름 | 빠름 |
| 주요 용도 | 복잡한 데이터 통합 | 간단한 데이터 결합, 시계열 데이터 | 데이터 연결(스택킹) |
| 키 기반 결합 | 가능 | 가능 (인덱스 기준) | 불가능 |
| 다중 데이터프레임 결합 | 두 개씩 결합 | 두 개씩 결합 | 여러 개 동시 결합 가능 |
:::

이 표는 merge, join, concat 함수의 주요 특징을 비교하여 보여줍니다. concat 함수는 주로 데이터를 단순히 연결(스택킹)할 때 사용되며, 키 기반 결합은 지원하지 않지만 여러 데이터프레임을 한 번에 연결할 수 있다는 특징이 있습니다.

# 4. 데이터 결합 시 발생할 수 있는 문제와 해결 방법

```python-exec
import pandas as pd

df = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.1, 4.2, 5.9, 2.8, 3.3, 5.4],
    '선호_종류': ['에스프레소', '아메리카노', '카푸치노', '카페라떼', '드립커피', '카페오레'],
    '카페_수': [25000, 32000, 18000, 12000, 22000, 15000],
    '평균_가격': [2.5, 3.8, 1.5, 4.2, 3.5, 2.8]
})

print("원본 커피 소비 데이터프레임:")
print(df)
print("")
```

## 4.1 키 불일치

우리는 두 개의 데이터프레임을 가지고 있습니다. 하나는 커피 관련 정보(df)를 담고 있고, 다른 하나는 국가별 GDP 정보(df_gdp)를 담고 있습니다. 이 두 데이터프레임을 국가를 기준으로 병합하려고 합니다. 그러나 각 데이터프레임에서 국가명을 나타내는 열의 이름이 서로 다릅니다 (df에서는 '국가', df_gdp에서는 'Country').
이로 인해 단순히 pd.merge(df, df_gdp)를 실행하면 결과가 빈 데이터프레임이 됩니다. 왜냐하면 merge 함수가 기본적으로 같은 이름의 열을 기준으로 데이터를 병합하려고 시도하기 때문입니다.

```python-exec
# GDP 데이터를 담은 새로운 데이터프레임
df_gdp = pd.DataFrame({
    'Country': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    'GDP': [1830, 21400, 1900, 1630, 5150, 2700]
})

print("GDP 데이터:")
print(df_gdp)
print("단순 병합 시도 (실패):")
print(pd.merge(df, df_gdp))    
```

이 문제를 해결하기 위해 merge 함수의 'left_on'과 'right_on' 매개변수를 사용합니다. 이를 통해 각 데이터프레임에서 서로 다른 이름을 가진 열을 기준으로 병합할 수 있습니다. 그 후, 중복된 열을 제거하여 최종 결과를 얻습니다

```python-exec
print("해결 방법 (left_on, right_on 사용):")
result = pd.merge(df, df_gdp, left_on='국가', right_on='Country')
result = result.drop('Country', axis=1)  # 중복 열 제거
print(result)
```

## 4.2 중복 열
데이터 병합 시 중복 열 문제는 두 데이터프레임에 같은 이름의 열이 존재할 때 발생합니다. 이 경우, 단순 병합을 하면 pandas가 자동으로 '_x'와 '_y' 접미사를 붙여 구분하지만, 이는 명확성이 떨어질 수 있습니다.
```python-exec
# 다른 연도의 연간 소비량 데이터
df_new_consumption = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.3, 4.4, 6.1, 3.0, 3.5, 5.6]
})

print("새로운 연간 소비량 데이터:")
print(df_new_consumption)
print("단순 병합 (열 이름 중복):")
print(pd.merge(df, df_new_consumption))
```

이 문제를 해결하기 위해 merge 함수의 'suffixes' 매개변수를 사용합니다. 이 매개변수를 통해 중복되는 열 이름에 붙일 접미사를 지정할 수 있습니다. 예를 들어, 하나는 '2022년 소비량', 다른 하나는 '2023년 소비량'이라고 이름을 붙여줍니다.

```python-exec
print("해결 방법 (suffixes 사용):")
result = pd.merge(df, df_new_consumption, on='국가', suffixes=('_2022', '_2023'))
print(result)
```

## 4.3 데이터 유실
우리에게는 두 개의 데이터프레임이 있습니다. 하나는 모든 국가의 커피 관련 정보(df)이고, 다른 하나는 일부 국가의 수출량 데이터(df_partial)입니다. 이 두 데이터프레임을 '국가'를 기준으로 병합하려고 합니다.
기본적인 내부 조인(inner join)을 사용하면, 두 데이터프레임에 모두 존재하는 국가의 데이터만 결과에 포함됩니다. 이로 인해 수출량 데이터가 없는 국가들(예: 한국, 일본, 프랑스)의 정보가 완전히 사라지게 됩니다. 이는 중요한 데이터의 손실을 의미합니다.
```python-exec
# 일부 국가만 포함된 수출량 데이터
df_partial = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '독일'],
    '수출량': [1500, 2000, 1000, 1200]
})

print("부분적인 수출량 데이터:")
print(df_partial)
print("내부 조인 결과 (데이터 유실):")
print(pd.merge(df, df_partial, on='국가'))
```

데이터 유실 문제를 해결하기 위해 외부 조인(outer join)을 사용합니다. merge 함수의 'how' 매개변수를 'outer'로 설정하면, 두 데이터프레임의 모든 국가 정보를 유지하면서 병합할 수 있습니다. 이 방법을 통해 수출량 데이터가 없는 국가들의 정보도 결과에 포함되며, 누락된 데이터는 NaN(결측치)으로 표시됩니다. 이로써 데이터의 완전성을 유지하면서도 부분적으로 누락된 정보를 명확히 식별할 수 있어, 더 포괄적이고 정확한 분석이 가능해집니다. 

```python-exec
print("해결 방법 (외부 조인 사용):")
result = pd.merge(df, df_partial, on='국가', how='outer')
print(result)
```

## 4.4 데이터 타입 불일치
데이터 타입 불일치 문제는 두 데이터프레임에서 같은 정보가 서로 다른 형식으로 저장되어 있을 때 발생합니다. 이 경우, '카페_수' 정보가 한 데이터프레임에서는 숫자(정수)로, 다른 데이터프레임에서는 쉼표가 포함된 문자열로 저장되어 있습니다. 이러한 불일치로 인해 데이터를 직접 병합하거나 비교하는 것이 불가능하며, 연산 시 오류가 발생할 수 있습니다.
```python-exec
# 문자열로 된 카페 수 데이터
df_str_cafes = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '카페_수_문자열': ['25,000', '32,000', '18,000', '12,000', '22,000', '15,000']
})

print("문자열 형식의 카페 수 데이터:")
print(df_str_cafes)
print("데이터 타입 확인:")
print(df['카페_수'].dtype)
print(df_str_cafes['카페_수_문자열'].dtype)
```

 문제를 해결하기 위해서는 데이터 타입을 일치시키는 변환 과정이 필요합니다. 문자열로 된 데이터에서 쉼표를 제거하고 정수형으로 변환하는 과정을 거칩니다. df_str_cafes['카페_수_문자열'].str.replace(',', '').astype(int) 코드를 사용하여 쉼표를 제거하고 정수로 변환합니다. 이렇게 데이터 타입을 통일한 후에 merge 함수를 사용하면, 정확한 데이터 병합이 가능해지고 추후 분석 과정에서 발생할 수 있는 오류를 예방할 수 있습니다.
```python-exec
print("해결 방법 (데이터 타입 변환):")
df_str_cafes['카페_수_문자열'] = df_str_cafes['카페_수_문자열'].str.replace(',', '').astype(int)
result = pd.merge(df, df_str_cafes, on='국가')
print(result)
```

