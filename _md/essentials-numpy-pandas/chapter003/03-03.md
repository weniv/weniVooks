---
chapter: NumPy :세 번째 걸음
title: NumPy 라이브러리 활용
date: 2024-07-10
---

# 1.  Matplotlib이란?

Matplotlib은 Python에서 가장 널리 사용되는 데이터 시각화 라이브러리입니다. 이 라이브러리는 다양한 종류의 그래프와 차트를 생성할 수 있게 해주며, 과학적 컴퓨팅에서 특히 유용합니다.
![피그잼](/images/basecamp-numpy-pandas/chapter03/matplot.png 'matplotlib')

```python
# matplotlib을 사용하기 위한 라이브러리 호출
import matplotlib.pyplot as plt 
```

## 1.1 Matplotlib 기능

| 요소/함수 | 설명 |
|-----------|------|
| `pyplot` | Matplotlib의 상태-기반 인터페이스. MATLAB과 유사한 플로팅 함수들을 제공하는 모듈. 그림을 그리는 데 필요한 모든 도구가 들어있는 도구상자와 같음. |
| `Figure` | 전체 그래프 창을 나타내는 최상위 컨테이너. 그림을 그릴 큰 종이와 같음. |
| `Axes` | 데이터 공간을 포함하는 플롯의 영역. Figure 안에 실제로 그래프를 그리는 작은 영역. |
| `plot()` | x와 y 좌표 데이터를 사용하여 선 그래프를 생성하는 함수. 점과 점을 선으로 이어 그래프를 그림. |
| `scatter()` | x와 y 좌표 데이터를 사용하여 산점도를 생성하는 함수. 데이터를 개별 점으로 표시하는 그래프를 그림. |
| `hist()` | 주어진 데이터의 히스토그램을 생성하는 함수. 데이터의 분포를 보여주는 막대 그래프를 그림. |
| `bar()` | 범주형 데이터에 대한 막대 그래프를 생성하는 함수. 각 항목의 크기를 비교할 수 있는 막대 그래프를 그림. |
| `title()`, `xlabel()`, `ylabel()` | 각각 그래프의 제목, x축 레이블, y축 레이블을 설정하는 함수들. 그래프에 제목을 붙이고, 가로축과 세로축에 이름을 붙임. |

pyplot은 전반적인 그래프 작업을 위한 도구를 제공하며, Figure와 Axes는 그래프의 기본 구조를 형성합니다. plot(), scatter(), hist(), bar() 함수들은 각각 선 그래프, 산점도, 히스토그램, 막대 그래프 등 다양한 유형의 그래프를 생성하는 데 사용됩니다. title(), xlabel(), ylabel() 함수들은 그래프에 제목과 축 레이블을 추가하여 그래프의 내용을 명확히 합니다. 이러한 요소들을 조합하여 사용자는 데이터를 효과적으로 시각화할 수 있습니다.


## 1.2 Matplotlib 예제

```python
import numpy as np
import matplotlib.pyplot as plt


x = np.linspace(0, 10, 100)
y = np.sin(x)


plt.plot(x, y) # x와 y 값을 사용하여 선 그래프를 그립니다
plt.title('Sin 함수 그래프') # 그래프의 제목을 설정합니다
plt.xlabel('x') # x축의 레이블을 설정합니다
plt.ylabel('sin(x)') # y축의 레이블을 설정합니다
plt.show() # 그래프를 화면에 표시합니다

```
## 1.3 Matplotlib 결과

![Sin 함수 그래프: colab](/images/basecamp-numpy-pandas/chapter03/sin_graph.png 'Sin 함수 그래프')
::img{width="100", height="200" alt="" src="/images/basecamp-numpy-pandas/chapter03/sin_graph.png"}

이 그래프는 사인 함수를 보여주며, x가 0에서 10까지 변할 때 y값이 -1과 1 사이에서 파동을 그리는 모습을 나타냅니다. 그래프는 두 개의 완전한 주기를 보여주고 있으며, 이는 주기적으로 반복되는 현상을 표현하는 데 유용합니다.




# 2. NumPy 이미지 실습

다음 실습을 통해 디지털 이미지의 기본 구조, NumPy 배열을 사용한 이미지 데이터 조작, 간단한 이미지 처리 알고리즘의 구현, 그리고 Matplotlib을 사용한 결과 시각화 방법을 이해할 수 있습니다.

```python
import numpy as np
import matplotlib.pyplot as plt

# 가상의 이미지 데이터 생성 (0-255 사이의 랜덤한 값)
image = np.random.randint(0, 256, size=(50, 50), dtype=np.uint8)

# 이미지 표시
plt.figure(figsize=(10, 5))
plt.subplot(131)
plt.imshow(image, cmap='gray')
plt.title('Original Image')

# 이미지 밝기 조정 (모든 픽셀 값에 50을 더함)
brightened_image = np.clip(image.astype(np.int16) + 50, 0, 255).astype(np.uint8)
plt.subplot(132)
plt.imshow(brightened_image, cmap='gray')
plt.title('Brightened Image')

# 이미지 블러링 (3x3 평균 필터 적용)
kernel = np.ones((3,3)) / 9
blurred_image = np.zeros_like(image)
for i in range(1, image.shape[0]-1):
    for j in range(1, image.shape[1]-1):
        blurred_image[i,j] = np.sum(image[i-1:i+2, j-1:j+2] * kernel)

plt.subplot(133)
plt.imshow(blurred_image, cmap='gray')
plt.title('Blurred Image')

plt.tight_layout()
plt.show()

print("이미지 처리가 완료되었습니다.")
```

## 2.1 Matplotlib 결과
![위니브 홈페이지: colab](/images/basecamp-numpy-pandas/chapter03/combined_images.png '원본이미지 /밝게 처리된 이미지/블러 처리된 이미지')

이 이미지는 NumPy와 Matplotlib을 사용한 기본적인 이미지 처리 기법을 보여줍니다. 왼쪽부터 원본 이미지, 밝기가 증가된 이미지, 그리고 블러 처리된 이미지를 순서대로 나타냅니다. 이를 통해 간단한 이미지 처리 알고리즘이 시각적으로 어떤 효과를 만들어내는지 직접 확인할 수 있습니다.

# 3. NumPy 데이터 분석 실습

```python
import numpy as np
import matplotlib.pyplot as plt

# 1. 데이터 생성 (가상의 온라인 상점 판매 데이터)
np.random.seed(0)
n_days = 30
products = ['A', 'B', 'C', 'D']
sales_data = np.random.randint(10, 100, size=(n_days, len(products)))

# 2. 데이터 분석
total_sales = np.sum(sales_data, axis=0)
daily_total = np.sum(sales_data, axis=1)

# 3. 데이터 시각화
plt.figure(figsize=(12, 4))

# 3.1 제품별 총 판매량
plt.subplot(121)
plt.bar(products, total_sales)
plt.title('Total Sales by Product')
plt.ylabel('Total Sales')

# 3.2 일별 총 판매량 추이
plt.subplot(122)
plt.plot(range(1, n_days+1), daily_total)
plt.title('Daily Total Sales Trend')
plt.xlabel('Day')
plt.ylabel('Total Sales')

plt.tight_layout()
plt.show()

# 4. 결과 출력
print("데이터 분석 결과:")
print(f"제품별 총 판매량: {total_sales}")
print(f"가장 많이 팔린 제품: {products[np.argmax(total_sales)]}")
print(f"가장 적게 팔린 제품: {products[np.argmin(total_sales)]}")
print(f"전체 기간 총 판매량: {np.sum(total_sales)}")
```
## 3.1 matplotlib 결과

![colab](/images/basecamp-numpy-pandas/chapter03/sales_analysis1.png '데이터 분석 결과')

이 그래프는 NumPy를 사용한 데이터 분석 실습 결과를 보여줍니다. 왼쪽 그래프는 제품별 총 판매량을 막대 그래프로 나타내며, 오른쪽 그래프는 30일 동안의 일별 총 판매량 추이를 선 그래프로 보여줍니다. 이를 통해 제품 간 판매 성과 비교와 일별 판매 패턴을 한눈에 파악할 수 있어, 데이터 기반의 의사결정에 도움을 줄 수 있습니다.

# 4. Seaborn이란?

Seaborn은 통계적 데이터 시각화를 위한 Python 라이브러리입니다. Matplotlib을 기반으로 하며, 더 높은 수준의 인터페이스를 제공하여 복잡한 통계 그래프를 쉽게 만들 수 있습니다.

![피그잼](/images/basecamp-numpy-pandas/chapter03/seaborn.png 'seaborn')

## 4.1 Seaborn의 주요 특징

Seaborn은 `통계적 관계`를 시각화하는 데 탁월합니다. scatterplot() 함수를 사용하면 두 변수 간의 관계를 점으로 나타낼 수 있으며, regplot() 함수를 통해 회귀선까지 함께 그릴 수 있습니다. 이를 통해 변수 간의 상관관계나 트렌드를 쉽게 파악할 수 있습니다.

`범주형 데이터`의 시각화에도 Seaborn은 강점을 가지고 있습니다. barplot() 함수로 각 범주의 평균값을 막대 그래프로 표현할 수 있고, boxplot()이나 violinplot() 함수를 사용하면 범주별 데이터의 분포를 더 자세히 살펴볼 수 있습니다. 이러한 그래프들은 범주 간의 차이를 직관적으로 비교하는 데 매우 유용합니다.

`복잡한 데이터셋`을 탐색할 때도 Seaborn은 강력한 도구가 됩니다. pairplot() 함수를 사용하면 데이터셋의 모든 변수 쌍에 대한 산점도를 한 번에 그릴 수 있어, 변수 간의 관계를 전체적으로 파악할 수 있습니다. heatmap() 함수는 상관관계 행렬이나 다른 2D 데이터를 색상으로 표현하여 패턴을 쉽게 인식할 수 있게 해줍니다.

Seaborn의 또 다른 강점은 `테마` 기능입니다. 간단한 함수 호출만으로 그래프의 전체적인 스타일을 변경할 수 있어, 데이터의 특성이나 발표 상황에 맞는 시각적 스타일을 쉽게 적용할 수 있습니다.
또한, Seaborn은 다양한 색상 팔레트를 제공합니다. 데이터의 특성에 따라 적절한 색상 scheme을 선택할 수 있어, 시각적으로 더 효과적인 그래프를 만들 수 있습니다.

## 4.2 Seaborn 예제

```python
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# 데이터 생성
np.random.seed(0)
dates = pd.date_range(start='2024-01-01', end='2024-06-30', freq='D')
companies = ['TechCorp', 'EcoGreen', 'FinanceHub', 'HealthCare']

data = pd.DataFrame({
    'Date': dates.repeat(len(companies)),
    'Company': np.tile(companies, len(dates)),
    'Stock Price': np.random.randn(len(dates) * len(companies)).cumsum() + 100
})

# Seaborn 스타일 설정
sns.set_style("darkgrid")
sns.set_palette("husl")

# 라인 플롯 생성
plt.figure(figsize=(12, 6))
sns.lineplot(x='Date', y='Stock Price', hue='Company', data=data)

# 그래프 꾸미기
plt.title('Stock Price Trends Over Time', fontsize=16)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Stock Price ($)', fontsize=12)
plt.legend(title='Companies', title_fontsize='12', fontsize='10')
plt.xticks(rotation=45)

# 그래프 표시
plt.tight_layout()
plt.show()

print("주식 시장 추세 그래프가 생성되었습니다. 시간이 지남에 따라 다른 회사의 주가가 어떻게 변하는지 관찰하세요!")
```


## 4.4 Seaborn 결과

![colab](/images/basecamp-numpy-pandas/chapter03/stock.png '주식 분석 결과')

이 그래프는 Seaborn을 사용하여 생성된 주식 가격 추세를 보여줍니다. 2024년 1월부터 6월까지 4개 회사(TechCorp, EcoGreen, FinanceHub, HealthCare)의 일별 주가 변동을 나타냅니다. 각 회사는 서로 다른 색상의 선으로 표시되어 있어 쉽게 구분할 수 있습니다. 그래프는 전반적으로 하락 추세를 보이며, 회사들 간의 주가 변동 패턴이 유사한 것을 관찰할 수 있습니다. 이 시각화를 통해 여러 회사의 주가 동향을 한눈에 비교하고 분석할 수 있습니다.

# 5. scikit-learn이란?

사이킷런(scikit-learn)은 파이썬용 오픈소스 `머신러닝 라이브러리`입니다. `데이터 분석`을 위한 다양한 도구를 제공하며, `분류`, `회귀`, `클러스터링` 등의 알고리즘을 포함합니다. `모델 선택`, `평가`, `데이터 전처리` 기능도 제공하여, 데이터 분석 작업을 쉽고 효율적으로 수행할 수 있게 해줍니다.

`sklearn.preprocessing` 모듈은 데이터 전처리를 위한 도구들을 제공합니다. 머신러닝 알고리즘은 대부분 숫자 데이터를 다루기 때문에, 범주형 데이터를 숫자로 변환하거나 숫자 데이터의 스케일을 조정하는 작업이 필요합니다. 예를 들어, StandardScaler는 데이터를 평균 0, 표준편차 1로 변환하여 모든 특성의 스케일을 동일하게 만듭니다. OneHotEncoder는 범주형 변수를 이진 벡터로 변환하여 머신러닝 모델이 이해할 수 있는 형태로 바꿔줍니다.

`sklearn.model_selection` 모듈은 모델 선택과 평가를 위한 기능을 제공합니다. 모델의 성능을 정확히 평가하기 위해서는 훈련 데이터와 테스트 데이터를 분리하는 것이 중요합니다. train_test_split 함수를 사용하면 데이터를 쉽게 훈련셋과 테스트셋으로 나눌 수 있습니다. 또한, cross_val_score 함수를 통해 교차 검증을 수행할 수 있어, 모델의 일반화 성능을 더 정확하게 평가할 수 있습니다.

`sklearn.linear_model` 모듈은 선형 모델과 관련된 알고리즘을 제공합니다. 선형 모델은 간단하면서도 강력한 도구로, 많은 실제 문제에 적용할 수 있습니다. LinearRegression 클래스를 사용하면 연속적인 타겟 변수를 예측하는 회귀 모델을 만들 수 있고, LogisticRegression 클래스를 통해 범주형 타겟 변수를 예측하는 분류 모델을 생성할 수 있습니다.

`sklearn.ensemble` 모듈은 여러 개의 모델을 결합하여 더 강력한 모델을 만드는 앙상블 학습 방법을 제공합니다. RandomForestClassifier는 여러 개의 결정 트리를 생성하고 그 결과를 종합하여 예측하는 방식으로, 높은 정확도와 과적합에 대한 저항성을 가집니다. GradientBoostingRegressor는 이전 모델의 오차를 보완하는 방식으로 순차적으로 모델을 생성하여 높은 성능을 달성합니다.

마지막으로, sklearn.metrics 모듈은 모델의 성능을 평가하기 위한 다양한 지표를 제공합니다. 분류 문제에서는 accuracy_score 함수로 정확도를, 회귀 문제에서는 mean_squared_error 함수로 평균 제곱 오차를 계산할 수 있습니다. 이러한 평가 지표들을 통해 모델의 성능을 객관적으로 측정하고 개선할 점을 파악할 수 있습니다.
## 5.2 scikit-learn 실습

```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score

# MNIST 데이터셋 불러오기
print("데이터를 불러오는 중...")
mnist = fetch_openml('mnist_784', version=1, as_frame=False)
# 픽셀 값을 0-1 사이로 정규화하고, 레이블을 정수형으로 변환
X, y = mnist.data / 255.0, mnist.target.astype(int)

# 데이터를 학습용과 테스트용으로 분할 (80% 학습, 20% 테스트)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 모델 학습
print("모델을 학습하는 중...")
# 50개의 뉴런을 가진 은닉층 1개를 가진 신경망 모델 생성
model = MLPClassifier(hidden_layer_sizes=(50,), max_iter=10, random_state=42)
# 모델 학습 실행
model.fit(X_train, y_train)

# 테스트 데이터에 대한 예측 수행
y_pred = model.predict(X_test)
# 모델의 정확도 계산
accuracy = accuracy_score(y_test, y_pred)
print(f"모델 정확도: {accuracy:.2f}")

# 예측 결과 시각화
fig, axes = plt.subplots(2, 5, figsize=(12, 5))
for i, ax in enumerate(axes.flat):
    # 테스트 이미지를 28x28 크기로 재구성하여 표시
    []
    ax.imshow(X_test[i].reshape(28, 28), cmap='gray')
    # 예측값과 실제값을 제목으로 표시
    ax.set_title(f"예측: {y_pred[i]}, 실제: {y_test[i]}")
    ax.axis('off')  # 축 눈금 제거

# 그래프 레이아웃 조정 및 출력
plt.tight_layout()
plt.show()

print("분류 결과가 시각화되었습니다. 예측된 숫자와 실제 숫자를 비교해보세요!")
```

## 5.3 scikit-learn 결과

![colab](/images/basecamp-numpy-pandas/chapter03/미니스트.png '글씨체 분석 결과')

이 이미지는 MNIST 데이터셋을 사용한 숫자 분류 모델의 결과를 보여줍니다. 각 이미지는 손글씨로 쓴 숫자를 나타내며, 이미지 위의 텍스트는 모델의 예측값(Pred)과 실제 정답(True)을 표시합니다. 모든 예측이 정확하게 이루어졌음을 볼 수 있으며, 이는 모델이 다양한 필기체 숫자를 성공적으로 인식할 수 있음을 보여줍니다. 이 시각화는 머신러닝 모델의 성능을 직관적으로 이해하는 데 도움을 줍니다.

# 6. 마무리

이 실습을 통해 우리는 데이터 과학의 핵심 도구인 `NumPy`, `Matplotlib`, `Seaborn`, 그리고 `scikit-learn`의 기본적인 활용법을 익혔습니다. 우리는 다양한 `그래프 생성`, `이미지 처리`, `실제 데이터 분석 시나리오`, 그리고 `간단한 머신러닝 모델 구현`까지 폭넓게 다뤘습니다. 

이러한 도구들은 데이터 분석과 머신러닝 프로젝트의 기초를 형성하며, 앞으로 배울 `Pandas`와도 긴밀히 연계됩니다. 더 나아가 `TensorFlow`나 `PyTorch`와 같은 고급 딥러닝 라이브러리와도 함께 사용되어 더 복잡한 모델을 구현하는 데 활용됩니다.