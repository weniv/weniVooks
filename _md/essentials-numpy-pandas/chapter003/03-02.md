---
chapter: NumPy :세 번째 걸음
title: NumPy를 이용한 선형대수학
date: 2024-07-10
---
# 행렬 연산 심화
![피그잼](/images/essentials-numpy-pandas/chapter01/행렬.png )

## 1.1 행렬 곱셈
행렬 곱셈은 두 행렬의 원소들을 특정 규칙에 따라 곱하고 더하는 연산입니다. 이 연산에서 결과 행렬의 크기는 첫 번째 행렬의 행 수와 두 번째 행렬의 열 수로 결정됩니다. 곱셈이 가능하려면 첫 번째 행렬의 열 수와 두 번째 행렬의 행 수가 같아야 합니다. 주목할 점은 행렬 곱셈이 일반적으로 교환법칙이 성립하지 않아 AB와 BA의 결과가 다를 수 있다는 것입니다. 행렬 곱셈은 각 행과 열이 만나는 지점마다 특별한 '조리법'을 적용하는 것과 같으며, 이는 두 행렬의 정보를 결합하여 새로운 정보를 생성하는 과정입니다. 이 연산은 데이터 변환과 특징 추출 등 다양한 응용 분야에서 중요하게 사용됩니다.

![피그잼](/images/essentials-numpy-pandas/chapter01/행렬의곱.png )

```python-exec
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

C = np.dot(A, B)
print("행렬 A:")
print(A)
print("\n행렬 B:")
print(B)
print("\n행렬 곱셈 결과 (A * B):")
print(C)
```

## 1.2 역행렬
역행렬은 원래 행렬과 곱했을 때 단위행렬이 되는 특별한 행렬입니다. 이는 정방행렬(n x n)에서만 존재할 수 있으며, 행렬식(determinant)이 0이 아닐 때만 구할 수 있습니다. 역행렬의 중요한 특성은 원래 행렬과 곱하면 그 행렬의 효과를 '취소'할 수 있다는 점입니다. 이는 마치 행렬이 나타내는 변환을 정확히 되돌리는 '실행 취소' 버튼과 같은 역할을 합니다. 역행렬은 선형 방정식 해결, 데이터 복원, 암호화 등 다양한 분야에서 활용됩니다.

![피그잼](/images/essentials-numpy-pandas/chapter01/역행렬.png )

```python-exec
A = np.array([[1, 2], [3, 4]])
print("A의 역행렬:")
print(A)
```

## 1.3 의사역행렬
![피그잼](/images/essentials-numpy-pandas/chapter01/의사역행렬.png )

의사역행렬은 일반적인 역행렬의 개념을 확장한 것입니다. 이는 모든 행렬에 대해 정의될 수 있어 정방행렬에 국한되지 않습니다. 의사역행렬은 최소제곱법 문제 해결에 유용하게 사용되며, 완벽한 역행렬이 존재하지 않는 상황에서 '최선의 근사'를 제공합니다. 이는 마치 원래 변환을 가능한 한 가장 가깝게 되돌리는 역할을 하며, 데이터 압축, 신호 처리, 최적화 문제 등 다양한 분야에서 중요하게 사용됩니다.

```python-exec
A = np.array([[1, 2, 3], [4, 5, 6]])
A_pinv = np.linalg.pinv(A)
print("행렬 A:")
print(A)
print("A의 의사역행렬:")
print( A_pinv)
```
# 2. 벡터 연산 심화

## 2.1 고유값 (Eigenvalues)

고유값은 행렬 변환에서 중요한 특성을 나타내는 스칼라 값입니다. 이는 행렬을 특정 스칼라 값으로 곱했을 때 방향이 변하지 않는 벡터(고유벡터)에 대응하는 값입니다. 고유값은 정방행렬에 대해서만 계산 가능하며, 그 개수는 행렬의 차원과 같습니다. 고유값은 행렬 변환의 '강도 조절 다이얼'과 같은 역할을 하며, 변환의 세기를 나타냅니다. 양수의 고유값은 확대를, 음수의 고유값은 축소와 방향 전환을 의미합니다. 이러한 특성 때문에 고유값은 시스템의 안정성 분석, 주성분 분석(PCA) 등 다양한 응용 분야에서 중요하게 사용됩니다.

```python-exec
A = np.array([[1, 2], [2, 3]])
eigenvalues = np.linalg.eigvals(A)

print("행렬 A:")
print(A)
print("고유값:", eigenvalues)
```
:::div{.callout}

**Tip !**

"예를 들어, -0.23606798이라는 고유값은 해당 방향으로 변환이 약 0.24배로 축소되고 방향이 반대가 됨을 나타내죠."
:::

## 2.2 고유벡터 (Eigenvectors)

![피그잼](/images/essentials-numpy-pandas/chapter01/고유벡터.png )

고유벡터는 행렬에 의해 변환될 때 방향이 변하지 않고 오직 크기만 변하는 0이 아닌 벡터입니다. 각 고유값에 대응하는 고유벡터가 존재하며, 서로 다른 고유값에 대응하는 고유벡터들은 선형독립입니다. 고유벡터는 행렬 변환의 '비밀 통로'와 같은 역할을 합니다. 이 벡터들은 변환 후에도 방향이 변하지 않고, 오직 크기만 변합니다. 이러한 특성 때문에 고유벡터는 데이터 압축, 진동 분석, 양자역학 등 다양한 분야에서 중요한 역할을 합니다.

```python-exec
A = np.array([[1, 2], [2, 3]])
eigenvalues, eigenvectors = np.linalg.eig(A)

print("행렬 A:")
print(A)
print("고유벡터:", eigenvectors)
```

## 3. 선형 방정식

선형 방정식은 Ax = b 형태의 방정식에서 x를 찾는 과정입니다. 여기서 A는 계수 행렬, b는 상수 벡터, x는 우리가 찾고자 하는 해입니다. 이 방정식의 해는 존재하지 않거나, 유일하거나, 무한히 많을 수 있습니다. 선형 방정식은 가우스 소거법, LU 분해 등 다양한 방법으로 해결 가능합니다. 선형 방정식을 푸는 과정은 마치 복잡한 퍼즐을 푸는 것과 같습니다. 주어진 정보(A와 b)를 이용해 숨겨진 답(x)을 찾아내는 과정입니다.

![피그잼](/images/essentials-numpy-pandas/chapter01/선형방정식.png )

```python-exec
# 선형 방정식 Ax = b 설정
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# 방정식 풀기
x = np.linalg.solve(A, b)

print("행렬 A:")
print(A)
print("벡터 b:", b)
print("해 x:", x)

# 해의 검증
print("검증 (Ax == b):", np.allclose(np.dot(A, x), b))
```