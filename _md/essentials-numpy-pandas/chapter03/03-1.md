---
chapter: NumPy 활용
title: NumPy를 이용한 배열 심화
date: 2024-07-09
---
# 1.복잡한 인덱싱 기법

## 1.1 불리언 인덱싱 활용

불리언 인덱싱은 True/False 마스크를 사용해 NumPy 배열에서 조건을 만족하는 요소를 선택하는 방법입니다. 예를 들어, 짝수만 선택하거나 특정 범위의 값을 추출할 때 사용됩니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
mask = (arr % 2 == 0)  # 짝수인 요소만 True
even_numbers = arr[mask]
print(even_numbers) 
```

```python-exec
import numpy as np

# 복합 조건도 사용 가능
complex_mask = (arr > 3) & (arr < 8)
result = arr[complex_mask]
print(result) 
```
:::div{.callout}

**Tip !**

"불리언 인덱싱은 마치 체에 거르듯이 원하는 조건에 맞는 요소만 골라내는 거예요. 여기서는 먼저 짝수만 골라냈고, 그 다음에는 3보다 크고 8보다 작은 숫자들을 골라냈어요. 이런 방식은 데이터에서 특정 조건을 만족하는 값들만 빠르게 추출하고 싶을 때 매우 유용해요."
:::

## 1.2 정수 배열을 이용한 팬시 인덱싱

팬시 인덱싱은 NumPy 배열에서 고급 데이터 접근 기법으로, 정수 배열이나 리스트를 인덱스로 사용하여 비연속적이거나 특정 패턴을 가진 요소들을 선택적으로 추출하는 방법입니다. 이 기법은 다차원 배열에서도 적용 가능하며, 원본 배열의 구조를 유지하면서 복잡한 데이터 선택 작업을 단일 연산으로 수행할 수 있게 해줍니다.
```python-exec
import numpy as np

arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
indices = [0, 2, -1]  # 첫 번째, 세 번째, 마지막 요소 선택
selected = arr[indices]
print(selected) 
```

```python-exec
import numpy as np

# 2D 배열에서의 팬시 인덱싱
arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
row_indices = [0, 2]
col_indices = [1, 2]
selected_2d = arr_2d[row_indices][:, col_indices]
print(selected_2d)
```
:::div{.callout}

**Tip !**

"팬시 인덱싱은 마치 보물 지도에서 특정 위치만 표시해 놓고 그 위치의 보물만 찾아가는 것과 비슷해요. 여기서는 첫 번째, 세 번째, 그리고 마지막 위치의 숫자들을 골라냈어요. 2차원 배열에서는 특정 행과 열의 교차점에 있는 값들을 한 번에 선택할 수 있어요. 이는 복잡한 데이터에서 원하는 부분만 빠르게 추출할 때 매우 유용합니다."
:::

:::div{.callout}

**불리언 인데싱 vs 팬시 인덱싱**

| 특성 | 펜시 인덱싱 (Fancy Indexing) | 불리언 인덱싱 (Boolean Indexing) |
|------|---------------------------|--------------------------------|
| 정의 | 정수 배열로 데이터 선택 | 불리언 마스크로 데이터 선택 |
| 사용 방법 | `arr[[0, 2, 1]]` | `arr[arr > 5]` |
| 주요 용도 | 특정 인덱스의 요소 선택 | 조건에 맞는 요소 필터링 |
| 반환 형태 | 선택된 인덱스의 요소들 | 조건을 만족하는 요소들 |
| 순서 변경 | 가능 | 불가능 |
| 중복 선택 | 가능 | 불가능 |
| 다차원 예시 | `arr[[0,1], [1,0]]` | `arr[arr > 5]` |
:::

# 2. 배열 재구조화 심화

## 2.1 np.newaxis를 이용한 차원 확장

`np.newaxis`는 NumPy 배열에 새로운 차원을 추가하는 특별한 객체로, `None`과 동일합니다. 이는 기존 배열에 `새로운 축(axis)`을 추가하고, 배열의 `인덱싱`을 통해 차원을 확장합니다. 데이터 복사 없이 `뷰(view)`를 생성하므로 `메모리 효율적`입니다. 이를 통해 배열의 `shape`를 변경하여 차원을 효과적으로 확장할 수 있습니다.

![피그잼](/images/basecamp-numpy-pandas/chapter03/newxis.png 'np.newaxis')

```python-exec
import numpy as np

# 1차원 배열 생성
arr_1d = np.array([1, 2, 3, 4])

# 1차원 배열을 2차원 열 벡터로 변환
arr_2d_column = arr_1d[:, np.newaxis]
print("2D 열 벡터:")
print(arr_2d_column)
print("Shape:", arr_2d_column.shape)
```

```python-exec
import numpy as np

# 1차원 배열 생성
arr_1d = np.array([1, 2, 3, 4]) # 1차원 배열을 2차원 행 벡터로 변환
arr_2d_row = arr_1d[np.newaxis, :]
print("2D 행 벡터:", arr_2d_row)
print("Shape:", arr_2d_row.shape)
```
:::div{.callout}

**Tip !**

"np.newaxis를 사용하는 것은 마치 평면 위의 점들을 공중으로 들어올려 새로운 차원을 만드는 것과 같아요. 1차원 배열을 세로로 세우면 열 벡터가 되고, 가로로 늘리면 행 벡터가 됩니다. 이는 마치 종이 위의 선을 들어올려 벽에 세우거나, 바닥에 눕히는 것과 비슷합니다. 이렇게 차원을 추가하면 데이터를 다른 관점에서 볼 수 있게 되죠."
:::

## 2.2  배열 전치(transpose)의 다양한 방법

배열 전치는 NumPy 배열의 `축(axis)`을 서로 교환하는 연산으로, 배열의 형태를 변경하거나 데이터를 다른 관점에서 볼 수 있게 합니다. 주요 방법으로는 2차원 배열의 행과 열을 교환하는 `T` 속성, 다차원 배열의 축을 재배열하는 `transpose()` 함수, 그리고 두 개의 지정된 축을 교환하는 `swapaxes()` 함수가 있습니다. 이러한 방법들을 통해 데이터를 효과적으로 재구성할 수 있습니다.
![피그잼](/images/basecamp-numpy-pandas/chapter03/transpose.png 'np.newaxis')

```python-exec
import numpy as np

# 기본 전치 (T 속성 사용)
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_transposed = arr_2d.T
print("원본 2D 배열:")
print(arr_2d)
print("\n전치된 2D 배열:")
print(arr_transposed)
```

```python-exec
import numpy as np

# 3차원 배열 전치 (transpose 함수 사용)
arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
arr_3d_transposed = np.transpose(arr_3d, (1, 0, 2))
print("\n전치된 3D 배열:")
print(arr_3d_transposed)
print("\n전치된 배열 shape:", arr_3d_transposed.shape)
```
:::div{.callout}

**Tip !**

"배열 전치는 마치 루빅 큐브를 회전시키는 것과 비슷해요. 2차원에서는 행과 열을 바꾸는 간단한 작업이지만, 3차원 이상에서는 축을 원하는 대로 재배열할 수 있어 데이터를 다양한 각도에서 볼 수 있게 해줍니다. 이는 마치 3D 물체를 다른 방향에서 관찰하는 것과 같아요. 같은 데이터지만 다른 시각으로 볼 수 있게 되는 거죠."
:::


## 2.3 배열 전치 활용

배열 전치는 다양한 분야에서 실용적으로 활용됩니다. `행렬 곱셈 최적화`를 위해 데이터를 효율적인 형태로 재구성하거나, `이미지 처리` 시 RGB 채널 순서 변경 및 배치 구조 조정에 사용됩니다. `시계열 데이터 분석`에서는 시간축과 특성축을 교환하여 새로운 관점의 분석을 가능케 하며, 딥러닝의 `텐서 연산`에서는 모델 요구사항에 맞춰 텐서 형태를 조정하는 데 활용됩니다.

# 3. 효율적인 연산 기법

## 3.1 브로드캐스팅

브로드캐스팅(Broadcasting)은  `shape가 다른 배열 간의 산술 연산을 가능`하게 합니다. 이 기능은 작은 배열을 자동으로 더 큰 배열의 `shape에 맞게 확장`하여 `요소별 연산`을 수행합니다. 이를 통해 복잡한 반복문 없이도 배열 간 연산을 `간결하게 표현`할 수 있습니다. 

```python-exec
#**예시: 온도 데이터 변환**

import numpy as np

# 5개 도시의 7일간 섭씨 온도 데이터
temp_c = np.array([
    [20, 19, 21, 22, 23, 21, 20],  # 도시 1
    [18, 17, 19, 20, 21, 20, 19],  # 도시 2
    [25, 26, 27, 28, 27, 26, 25],  # 도시 3
    [15, 14, 16, 17, 18, 17, 16],  # 도시 4
    [22, 23, 24, 25, 24, 23, 22]   # 도시 5
])

# 섭씨를 화씨로 변환 (브로드캐스팅 사용)
temp_f = (temp_c * 9/5) + 32

# 각 도시의 평균 기온 계산 (axis=1은 행 방향, 즉 각 도시별로 평균 계산)
city_mean_f = np.mean(temp_f, axis=1, keepdims=True)

# 일별 기온과 도시 평균의 차이 계산 (브로드캐스팅 사용)
temp_diff = temp_f - city_mean_f

print("화씨 온도:")
print(temp_f)
```
:::div{.callout}

**Tip !**

"브로드캐스팅은 마치 요리 레시피를 여러 명의 손님에게 맞춰 확장하는 것과 비슷해요. 예를 들어, 1인분 레시피를 4인분으로 늘릴 때 모든 재료의 양을 4배로 늘리는 것처럼, NumPy는 작은 배열을 자동으로 확장하여 큰 배열과의 연산을 가능하게 합니다."
:::



## 3.2 유니버설 함수(ufunc)

유니버설 함수(ufuncs)는 NumPy의 강력한 기능으로, `배열의 요소별로 연산을 수행하는 벡터화된 함수`입니다. `C로 구현`되어 매우 빠르며, 큰 배열에 대해 `효율적인 연산`을 제공합니다. 이 함수들은 배열의 모든 요소에 대해 `동일한 연산을 병렬적으로 수행`하고, `브로드캐스팅`을 지원하여 다양한 shape의 배열에 적용할 수 있습니다. 입출력 모두 `NumPy 배열`을 사용하며, `reduce`와 `accumulate` 같은 메서드로 집계 연산도 수행할 수 있습니다.

```python-exec
import numpy as np

# 학생들의 점수 데이터 (5명의 학생, 3개 과목)
scores = np.array([
    [80, 75, 85],  # 학생 1
    [90, 85, 95],  # 학생 2
    [70, 80, 75],  # 학생 3
    [85, 90, 80],  # 학생 4
    [95, 70, 90]   # 학생 5
])

# 1. 각 학생의 총점 계산 (reduce 사용)
student_totals = np.add.reduce(scores, axis=1)
print("각 학생의 총점 (reduce 사용):")
for i, total in enumerate(student_totals, 1):
    print(f"학생 {i}: {total}")
```

```python-exec
# 2. 각 과목의 최고 점수 
import numpy as np

# 학생들의 점수 데이터 (5명의 학생, 3개 과목)
scores = np.array([
    [80, 75, 85],  # 학생 1
    [90, 85, 95],  # 학생 2
    [70, 80, 75],  # 학생 3
    [85, 90, 80],  # 학생 4
    [95, 70, 90]   # 학생 5
])

subjects = ['국어', '영어', '수학']

# 각 과목의 최고 점수 계산 (reduce: 축적 연산 사용)
subject_max = np.maximum.reduce(scores, axis=0)

print("과목별 최고 점수 (reduce 사용):")
for subject, max_score in zip(subjects, subject_max):
    print(f"{subject}: {max_score}")
```

```python-exec
import numpy as np

# 학생들의 점수 데이터 (5명의 학생, 3개 과목)
scores = np.array([
    [80, 75, 85],  # 학생 1
    [90, 85, 95],  # 학생 2
    [70, 80, 75],  # 학생 3
    [85, 90, 80],  # 학생 4
    [95, 70, 90]   # 학생 5
])
# 4. 각 학생의 누적 총점 (accumulate 사용)
cumulative_totals = np.add.accumulate(scores, axis=1)
print("각 학생의 누적 총점 (accumulate 사용):")
for i, totals in enumerate(cumulative_totals, 1):
    print(f"학생 {i}: {totals}")
```
:::div{.callout}

**Tip !**

"유니버설 함수는 마치 공장의 조립 라인과 같아요. 각 작업자(함수)가 컨베이어 벨트 위의 모든 부품(배열 요소)에 대해 동일한 작업을 수행하는 거죠. reduce는 이 부품들을 모두 조립해 하나의 결과물로 만드는 것이고, accumulate는 조립 과정의 각 단계를 기록하는 것과 비슷합니다."
:::
.