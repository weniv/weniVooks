---
chapter: NumPy :두 번째 걸음
title: NumPy 배열 활용
date: 2024-07-09
---
# 배열활용

# 1. 인덱싱과 슬라이싱

### 1.1 기본 인덱싱과 슬라이싱
![피그잼](/images/basecamp-numpy-pandas/chapter02/index_2.png '인덱스')

인덱싱은 배열의 특정 위치에 있는 요소에 접근하는 방법입니다. arr[index] 형태로 사용합니다. NumPy에서는 이 기능들을 사용하여 배열의 특정 요소나 부분집합을 효율적으로 선택할 수 있습니다. 인덱싱은 배열의 특정 칸을 골라내는 것과 같습니다. 예를 들어, arr[2]는 3번째 숫자를 선택합니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr[2])        # 인덱싱
```


### 1.2 슬라이싱

슬라이싱은 배열의 일부분을 추출하는 기술입니다. arr[start:end:step] 형태로 사용합니다. 예를 들어, arr[1:4]는 2번째부터 4번째까지의 숫자들을 선택합니다. 시작 인덱스, 끝 인덱스, 그리고 건너뛰기 값을 지정할 수 있어 매우 유연한 선택이 가능합니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr[1:4])      # 기본 슬라이싱
print(arr[:3])       # 처음부터 3번째 요소까지
print(arr[2:])       # 3번째 요소부터 끝까지
print(arr[::2])      # 2칸씩 건너뛰며 선택
```


### 1.3 고급 인덱싱 : boolean

Boolean 인덱싱은 조건에 맞는 요소만 선택하는 방법입니다. arr[condition] 형태로 사용합니다.  마치 체에 거르듯이 원하는 데이터만 골라내는 것과 같습니다. 예를 들어, 2보다 큰 값만 선택하는 경우, 조건에 맞는 학생들의 점수만 따로 모을 수 있고, 이를 통해 합격한 학생 수나 최고 점수 같은 정보도 쉽게 얻을 수 있습니다.
![피그잼](/images/basecamp-numpy-pandas/chapter02/booln_index2.png '인덱스')

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr[arr > 2])       # Boolean 인덱싱
```


### 1.4 고급 인덱싱 : fancy

팬시 인덱싱은 정수 배열을 사용하여 여러 인덱스의 요소를 동시에 선택하는 방법입니다. arr[[index1, index2, ...]] 형태로 사용합니다. 팬시 인덱싱은 '이 위치에 있는 것들만 줘'라고 하는 것과 같습니다. 예를 들어, 두 번째, 네 번째, 다섯 번째 숫자만을 선택적으로 골라낼 수 있습니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr[[1, 3, 4]])     # 팬시 인덱싱
```


## 2. 배열 연결

### 2.1 concatnate 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/concatnate_2.png 'np.concatenate')

배열 연결은 두 개 이상의 배열을 하나로 합치는 과정입니다. np.concatenate() 함수는 튜플이나 배열의 리스트를 받아 지정된 축을 따라 배열들을 연결합니다. concatenate는 배열들을 끝과 끝을 이어 붙이는 것과 같습니다. 마치 기차를 연결하는 것처럼, 첫 번째 배열 뒤에 두 번째 배열이 이어집니다.

```python-exec
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.concatenate((a, b)))
```
:::div{.callout}

**Tip !**

np.concatenate() 함수에서 axis 매개변수는 배열을 연결할 축을 지정합니다. 기본값은 axis=0입니다. axis=0을 사용하면 첫 번째 축을 따라 연결되는데, 2차원 배열에서는 이것이 행(row)을 따라 연결되는 것을 의미합니다. 이는 마치 배열을 위아래로 쌓는 것과 같습니다. 반면 axis=1을 사용하면 두 번째 축을 따라 연결되며, 2차원 배열에서는 열(column)을 따라 연결됩니다. 이는 배열을 좌우로 붙이는 것과 같은 효과를 냅니다. 1차원 배열에서는 axis=0만 사용 가능하며, 3차원 이상의 배열에서도 같은 원리가 적용되어 axis 값이 증가할수록 더 안쪽의 차원을 따라 연결됩니다.
:::



### 2.2 vstack 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/vstack_2.png 'np.vstack')

np.vstack() 함수는 수직(vertical)으로 배열들을 쌓아 연결합니다. 이는 2D 배열에서 행을 추가하는 것과 같습니다. vstack은 배열들을 수직으로 쌓는 것과 같습니다. 마치 책을 쌓는 것처럼, 첫 번째 배열 위에 두 번째 배열이 올라갑니다.

```python-exec
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.vstack((a, b)))
```

### 2.3 hstack 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/hstack_2.png 'np.vstack')

np.hstack() 함수는 수평(horizontal)으로 배열들을 옆으로 연결합니다. 이는 2D 배열에서 열을 추가하는 것과 같습니다. hstack은 배열들을 수평으로 연결하는 것과 같습니다. 마치 기차를 옆으로 연결하는 것처럼, 첫 번째 배열 옆에 두 번째 배열이 붙습니다.

```python-exec
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.hstack((a, b)))
```

### 2.4 dstack 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/dstack_3.png 'np.dstack')

np.dstack() 함수는 배열들을 깊이 방향(depth-wise)으로 쌓습니다. 이는 3D 배열에서 새로운 축을 추가하는 것과 같습니다. 마치 여러 장의 종이를 겹쳐 놓는 것처럼, 새로운 차원으로 배열들을 결합합니다. 이는 색상 채널을 가진 이미지 데이터를 다룰 때 특히 유용합니다.

```python-exec
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.dstack((a, b)))
```

### 2.5 column_stack 함수

![피그잼](/images/essentials-numpy-pandas/chapter01column_stack.png 'np.column_stack')

np.column_stack() 함수는 1차원 배열들을 받아 2차원 배열의 열로 쌓습니다. 이는 각 입력 배열을 새로운 열로 취급합니다. 마치 엑셀 시트에 새로운 열을 추가하는 것처럼, 각 입력 배열이 새로운 열이 됩니다. 이는 데이터를 표 형식으로 구성할 때 매우 유용합니다.

```python-exec
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(np.column_stack((a, b)))
```

## 3. 배열 분할

### 3.1 split 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/split_2.png 'np.split')

np.split() 함수는 배열을 여러 개의 하위 배열로 균등하게 나눕니다. 분할 지점이나 분할할 배열의 수를 지정할 수 있습니다. 예를 들어, 6개의 요소를 3등분하면 각각 2개씩 들어있는 3개의 배열이 만들어집니다. 이는 마치 케이크를 똑같은 크기로 자르는 것과 비슷합니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
print(np.split(arr, 3))
```

### 3.2 array split 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/array_split_2.png 'np.array_split')

np.array_split() 함수는 split 함수와 유사하지만, 균등하게 나눌 수 없는 경우에도 사용할 수 있습니다. 이 경우 일부 하위 배열은 다른 배열보다 하나 더 적은 요소를 가질 수 있습니다. 예를 들어, 6개의 요소를 4등분하면 처음 두 배열은 2개씩, 나머지 두 배열은 1개씩 들어있게 됩니다. 이는 마치 케이크를 비슷한 크기로 나누되, 완벽히 같지 않아도 괜찮은 상황과 비슷합니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
print(np.array_split(arr, 4))
```

### 3.3 hsplit 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/hsplit_2.png 'np.hsplit')

np.hsplit() 함수는 배열을 수평(horizontal)으로 분할합니다. 이는 마치 초콜릿을 세로로 자르는 것과 같습니다. 예를 들어, 넓은 직사각형 모양의 초콜릿 바를 여러 개의 작은 초콜릿 조각으로 나누는 것을 상상해보세요. 각 조각은 원래 초콜릿 바의 높이는 그대로 유지하지만, 너비는 줄어듭니다.


```python-exec
import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
result = np.hsplit(arr, 2)
for sub_array in result:
    print(sub_array)
```
:::div{.callout}

### 3.4 vsplit 함수
![피그잼](/images/basecamp-numpy-pandas/chapter02/vsplit_2.png 'np.vsplit')

np.vsplit() 함수는 배열을 수직(vertical)으로 분할합니다. 예를 들어, 긴 막대 과자를 여러 개의 작은 조각으로 나누는 것을 상상해보세요. 각 조각은 원래 과자의 너비는 그대로 유지하지만, 높이는 줄어듭니다.


```python-exec
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
result = np.vsplit(arr, 2)
for sub_array in result:
    print(sub_array)
```
