---
chapter: NumPy :두 번째 걸음
title: NumPy 배열 생성
date: 2024-07-08
---
# 1. 배열(ndarray) 생성하기

## 1.1 np.array
![피그잼](/images/basecamp-numpy-pandas/chapter02/np.array_2.png '배열')

np.array 함수는 리스트나 튜플로부터 NumPy 배열을 생성합니다. 이 함수는 파이썬의 기본 데이터 구조를 NumPy의 효율적인 배열 형태로 변환해줍니다. 다차원 배열도 생성할 수 있어 복잡한 데이터 구조를 쉽게 만들 수 있습니다. np.array를 사용하는 것은 마치 우리가 원하는 숫자들로 상자를 채우는 것과 같습니다. 숫자들을 줄 세워 놓는 것처럼, 데이터를 정돈된 형태로 저장할 수 있습니다.

```python-exec
import numpy as np

arr1 = np.array([1, 2, 3, 4, 5])
print("np.array:", arr1)
```

## 1.2 np.zeros
![피그잼](/images/basecamp-numpy-pandas/chapter02/np.zeros_2.png 'np.zeros')

np.zeros 함수는 모든 요소가 0인 배열을 생성합니다. 이 함수는 배열의 크기와 데이터 타입을 지정할 수 있어, 초기화된 배열이 필요할 때 유용합니다. 특히 대규모 계산에서 결과를 저장할 공간을 미리 할당할 때 자주 사용됩니다. np.zeros를 사용하는 것은 0으로 가득 찬 상자를 만드는 것과 같습니다. 마치 빈 계란판을 준비하는 것처럼, 데이터를 채울 준비가 된 빈 공간을 만들어냅니다.


```python-exec
import numpy as np

arr2 = np.zeros(5)
print("np.zeros:", arr2)
```

## 1.3 np.ones
![피그잼](/images/basecamp-numpy-pandas/chapter02/np.ones_2.png 'np.ones')

np.ones 함수는 모든 요소가 1인 배열을 생성합니다. np.zeros와 유사하지만 1로 초기화된 배열을 만듭니다. 이 함수는 행렬 연산에서 단위 행렬을 만들거나, 데이터 정규화 과정에서 기준값을 설정할 때 유용하게 사용됩니다. np.ones를 사용하는 것은 1로 가득 찬 상자를 만드는 것과 같습니다. 마치 모든 칸에 동전을 하나씩 넣어둔 것처럼, 모든 요소가 동일한 시작점을 가진 배열을 만들 수 있습니다.


```python-exec
import numpy as np

arr3 = np.ones((2, 2))
print("np.ones:")
print(arr3)
```

## 1.4 np.arange

![피그잼](/images/basecamp-numpy-pandas/chapter02/no.arange_2.png 'np.arange')

np.arange 함수는 지정된 범위와 간격으로 균일하게 나누어진 값들로 배열을 생성합니다. 파이썬의 range 함수와 유사하지만, 실수 간격도 지정할 수 있어 더 유연합니다. 이 함수는 시퀀스 데이터를 생성하거나 그래프의 x축 값을 만들 때 자주 사용됩니다. np.arange를 사용하는 것은 일정한 간격으로 늘어나는 숫자들로 상자를 채우는 것과 같습니다. 마치 계단을 오르는 것처럼 숫자가 차례대로 커지는 배열을 만들 수 있습니다.

```python-exec
import numpy as np

arr4 = np.arange(0, 10, 2)
print("np.arange:", arr4)
```



## 1.5 np.linspace

![피그잼](/images/basecamp-numpy-pandas/chapter02/np.linespace_2.png 'np.linspace')

np.linspace 함수는 지정된 범위 내에서 균일한 간격으로 나누어진 값들로 배열을 생성합니다. 시작점, 끝점, 그리고 생성할 요소의 개수를 지정하면, 그 사이를 균등하게 나눈 값들을 만들어냅니다. 이 함수는 특히 수학적 함수의 도메인을 생성하거나 데이터 보간에 유용합니다. np.linspace를 사용하는 것은 시작과 끝 사이를 똑같은 간격으로 나눈 숫자들로 상자를 채우는 것과 같습니다. 마치 케이크를 똑같은 크기로 나누는 것처럼, 주어진 범위를 균등하게 분할한 값들을 생성할 수 있습니다.

```python-exec
import numpy as np

arr5 = np.linspace(0, 1, 5)
print("np.linspace:", arr5)
```
:::div{.callout}
**np.arange vs np.linspace **

| 특징                | `np.arange`                      | `np.linspace`                       |
|---------------------|----------------------------------|-------------------------------------|
| **기능**            | 일정 간격으로 숫자 시퀀스 생성   | 지정된 범위에서 동일한 간격으로 숫자 생성 |
| **파라미터**        | `start`, `stop`, `step`          | `start`, `stop`, `num`, `endpoint` |
| **간격 지정 방법**  | `step` 값을 통해 간격 지정       | `num` 값을 통해 개수 지정           |
| **종료 값 포함 여부**| 포함하지 않음 (`stop` 미포함)    | 기본적으로 포함 (`endpoint=True` 시)|
| **주요 용도**       | 정수 또는 간격이 일정한 실수 배열 | 특정 범위에서 균등한 간격의 실수 배열 생성 |
| **출력 예시**       | `np.arange(0, 10, 2)` => `[0, 2, 4, 6, 8]` | `np.linspace(0, 10, 5)` => `[0.0, 2.5, 5.0, 7.5, 10.0]` |

:::
# 2. 기본적인 배열 조작

## 2.1 reshape
![피그잼](/images/basecamp-numpy-pandas/chapter02/reshape_2.png 'arr.reshape')

reshape 함수는 배열의 형태를 변경합니다. 이 함수는 배열의 차원과 각 차원의 크기를 새롭게 지정할 수 있게 해주며, 요소의 총 개수는 변하지 않습니다. 다차원 데이터를 다룰 때 매우 유용하며, 예를 들어 1차원 데이터를 2차원 행렬로 변환하거나 그 반대의 경우에 사용됩니다. reshape를 사용하는 것은 블록들을 새로운 모양으로 쌓는 것과 같습니다. 예를 들어, 한 줄로 된 블록들을 두 줄로 바꾸는 것처럼, 데이터의 구조를 변경할 수 있습니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
reshaped = arr.reshape((2, 3))
print("Reshaped:")
print(reshaped)
```


## 2.2 astype
![피그잼](/images/basecamp-numpy-pandas/chapter02/dtype2_3.png 'astype()')

astype 함수는 배열의 데이터 타입을 변경합니다. 이 함수를 사용하면 정수형에서 실수형으로, 또는 그 반대로 데이터 타입을 쉽게 변환할 수 있습니다. 데이터 처리 과정에서 타입 변환이 필요할 때 유용하며, 특히 메모리 사용을 최적화하거나 특정 연산에 적합한 데이터 타입으로 변경할 때 사용됩니다. astype을 사용하는 것은 블록의 종류를 바꾸는 것과 같습니다. 예를 들어, 정수 블록을 소수점이 있는 블록으로 바꾸는 것처럼, 데이터의 표현 방식을 변경할 수 있습니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
float_arr = arr.astype(float)
print("Float type:", float_arr)
```

## 2.3 ravel

![피그잼](/images/basecamp-numpy-pandas/chapter02/reval_2.png 'ravel()')

ravel 함수는 다차원 배열을 1차원 배열로 평탄화합니다. 이 함수는 원본 배열의 뷰(view)를 반환하므로 메모리 효율적입니다. 복잡한 다차원 데이터를 선형으로 처리해야 할 때 유용하며, 예를 들어 다차원 이미지 데이터를 1차원으로 변환하여 기계학습 모델에 입력할 때 사용할 수 있습니다. ravel 함수를 사용하는 것은 여러 층으로 쌓인 블록들을 모두 한 줄로 늘어놓는 것과 같습니다. 원본 블록 탑을 그대로 유지하면서, 그 블록들을 한 줄로 보이게 만드는 것처럼, 원본 배열을 유지하면서도 새로운 1차원 배열을 메모리 효율적으로 만들 수 있습니다.

```python-exec
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])
raveled = reshaped.ravel()
print("Raveled:", raveled)
```
:::div{.callout}

**뷰(view)란?**

뷰(View)는 NumPy에서 원본 배열을 복사하지 않고, 원본 배열의 데이터를 다른 방식으로 볼 수 있게 해주는 기능입니다. 쉽게 말해, 원본 배열을 새로운 형태로 보여주는 창과 같은 역할을 합니다.

예를 들어, 책을 다시 복사하지 않고, 목차를 통해 책의 다른 부분을 보는 것과 같습니다. 뷰는 원본 데이터를 그대로 사용하기 때문에, 새로운 메모리를 차지하지 않습니다. 그래서 뷰에서 데이터를 변경하면 원본 배열도 함께 변경됩니다.
:::

## 2.4 flatten
![피그잼](/images/basecamp-numpy-pandas/chapter02/flatten_2.png 'flatten()')

flatten 함수도 다차원 배열을 1차원 배열로 평탄화하지만, ravel과 달리 항상 배열의 복사본을 반환합니다. 이는 원본 데이터를 유지하면서 평탄화된 버전이 필요할 때 유용합니다. 데이터 분석 과정에서 원본 구조를 보존하면서 1차원 배열로 변화가 필요한 경우에 적합합니다. 즉, flatten을 사용하는 것은 여러 층으로 쌓인 블록들을 모두 한 줄로 늘어놓되, 원래 블록 탑은 그대로 두고 새로운 한 줄 배열을 만드는 것과 같습니다. 마치 블록 탑의 사진을 찍어서 그 사진 속의 블록들을 일렬로 늘어놓는 것처럼, 원본 데이터는 그대로 두고 새로운 1차원 배열을 생성합니다.

```python-exec
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
flattened = arr.flatten()
print("Flattened:", flattened)
print("Oiginal array:")
print(arr)
```

## 2.5 transpose
![피그잼](/images/basecamp-numpy-pandas/chapter02/transpose_2.png 'transpose()')
transpose 함수는 배열의 축을 바꿉니다. 2차원 배열의 경우, 행과 열을 서로 바꾸는 효과가 있습니다. 이 함수는 행렬 연산에서 매우 중요하며, 데이터의 구조를 변경하여 다른 관점에서 분석하거나 처리할 때 유용합니다. 예를 들어, 시계열 데이터에서 특성과 시간 축을 바꿀 때 사용할 수 있습니다. transpose를 사용하는 것은 마치 표를 옆으로 눕히는 것과 같습니다. 세로로 되어있던 것을 가로로, 가로로 되어있던 것을 세로로 바꾸는 것입니다. 예를 들어, 학생들의 과목별 점수표가 있다면, 학생 이름이 행이고 과목이 열이었던 표를 뒤집어서 과목이 행이고 학생 이름이 열이 되게 만드는 것과 같습니다.


```python-exec
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])
transposed = arr.transpose()
print("Original array:")
print(arr)
print("Transposed array:")
print(transposed)
```


# 3. 간단한 수학 연산

## 3.1 배열 간 연산

![피그잼](/images/basecamp-numpy-pandas/chapter02/arr_mul_2.png '더하기')

+, -, *, / 등의 연산자를 사용하여 NumPy 배열 간의 기본적인 산술 연산을 수행합니다. 이러한 연산은 요소별로 이루어지며, 같은 크기의 배열 간에 덧셈, 뺄셈, 곱셈, 나눗셈 등을 수행할 수 있습니다. 배열끼리 더하거나 곱하는 것은 각 자리의 숫자들끼리 연산이 되는 것과 같습니다. 마치 두 줄로 서 있는 친구들이 서로 마주보고 더하기나 곱하기를 하는 것처럼, 각 위치의 요소들끼리 연산이 수행됩니다.

```python-exec
import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
print("덧셈:", arr1 + arr2)
print("곱셈:", arr1 * arr2)
```

## 3.2 브로드캐스팅
![피그잼](/images/basecamp-numpy-pandas/chapter02/boardcasting_2.png '브로드캐스팅')

브로드캐스팅은 크기가 다른 배열 간에 연산을 수행할 수 있게 해주는 NumPy의 강력한 기능입니다. 이를 통해 작은 배열이나 스칼라 값을 큰 배열과 연산할 수 있으며, NumPy가 자동으로 작은 배열을 확장하여 연산을 수행합니다. 이는 코드를 간결하게 만들고 메모리 사용을 최적화하는 데 도움이 됩니다. 브로드캐스팅은 작은 배열이나 숫자 하나를 가지고 큰 배열과 연산할 수 있게 해줍니다. 마치 작은 도장을 가지고 큰 종이에 찍는 것처럼, 작은 배열의 패턴이 큰 배열에 반복해서 적용되는 것과 같습니다.

```python-exec
import numpy as np

arr1 = np.array([1, 2, 3])
scalar = 2
print("스칼라 곱셈:", arr1 * scalar)
```

```python-exec
import numpy as np

arr3 = np.array([[1, 2, 3], [4, 5, 6]])
arr4 = np.array([1, 2, 3])
print("2D + 1D 배열:")
print(arr3 + arr4)
