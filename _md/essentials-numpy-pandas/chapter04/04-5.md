---
chapter: Pandas :네 번째 걸음
title: Pandas 시각화와 데이터 결합
date: 2024-08-02
---


# 1. 판다스 시각화

Pandas는 데이터 분석용 Python 라이브러리로,  DataFrame이나 Series 객체에서 직접 plot() 메서드를 호출하여 다양한 유형의 그래프를 쉽게 생성할 수 있습니다. DataFrame의 컬럼명을 자동으로 레이블로 사용하여 편리합니다. Matplotlib을 기반으로 하여 유연성이 높고, 특히 시계열 데이터 시각화에 강점이 있습니다. 

## 1.1 국가별 커피 생산 및 소비 현황

```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 재현 가능한 결과를 위해 시드 설정
np.random.seed(42)

# 데이터프레임 생성
df = pd.DataFrame({
    'Country': ['Brazil', 'USA', 'Italy', 'South Korea', 'Japan', 'France', 'Germany', 'Canada', 'Australia', 'Spain'],
    'Annual_Consumption_kg': np.random.uniform(2.0, 8.0, 10).round(1),
    'Preferred_Type': ['Espresso', 'Americano', 'Cappuccino', 'Latte', 'Drip', 'Café au lait', 'Mocha', 'Flat White', 'Cold Brew', 'Macchiato'],
    'Cafe_Count': np.random.randint(10000, 50000, 10),
    'Avg_Price_USD': np.random.uniform(1.5, 5.0, 10).round(2),
    'Coffee_Import_Tons': np.random.randint(100000, 1000000, 10),
    'Roastery_Count': np.random.randint(50, 500, 10),
    'Coffee_Farm_Area_Hectares': [1500000, 0, 500000, 0, 0, 0, 0, 0, 0, 100000],
    'Barista_Population': np.random.randint(5000, 100000, 10),
    'Annual_Caffeine_Intake_mg': np.random.randint(100000, 300000, 10)
})

# 그래프 스타일 설정
plt.style.use('seaborn')
fig, ax1 = plt.subplots(figsize=(14, 8))

# 막대 그래프: 커피 농장 면적
bars = ax1.bar(df['Country'], df['Coffee_Farm_Area_Hectares'], color='skyblue', alpha=0.7)
ax1.set_xlabel('Country', fontsize=12)
ax1.set_ylabel('Coffee Farm Area (Hectares)', fontsize=12)
ax1.tick_params(axis='y', labelcolor='skyblue')

# 두 번째 y축 생성
ax2 = ax1.twinx()

# 선 그래프: 연간 커피 소비량
line = ax2.plot(df['Country'], df['Annual_Consumption_kg'], color='red', marker='o', linewidth=2, markersize=8)
ax2.set_ylabel('Annual Coffee Consumption (kg per capita)', fontsize=12)
ax2.tick_params(axis='y', labelcolor='red')

# 제목 설정
plt.title('Coffee Farm Area and Annual Consumption by Country', fontsize=16)

# 막대 위에 값 표시
for bar in bars:
    height = bar.get_height()
    ax1.text(bar.get_x() + bar.get_width()/2., height, f'{height:,.0f}', ha='center', va='bottom', fontsize=10)

# 선 그래프 포인트에 값 표시
for i, v in enumerate(df['Annual_Consumption_kg']):
    ax2.text(i, v, f'{v:.1f}', ha='center', va='bottom', fontsize=10, color='red')

plt.tight_layout()

plt.show()
```
![colab](/images/essentials-numpy-pandas/chapter04/coffe_Farm_area_and.png)

이 시각화는 막대 그래프와 선 그래프를 결합하여 국가별 커피 산업의 두 가지 주요 측면을 보여줍니다. 하늘색 막대는 각 국가의 커피 농장 면적(헥타르)을 나타내며, 빨간색 선은 연간 커피 소비량(kg/인)을 표시합니다. X축에는 커피 농장이 있는 국가들이 농장 면적을 기준으로 내림차순 정렬되어 있습니다. 왼쪽 Y축은 커피 농장 면적을, 오른쪽 Y축은 연간 커피 소비량을 측정합니다. 각 막대와 선 그래프의 포인트 위에는 정확한 수치가 데이터 라벨로 표시되어 있습니다. 

## 1.2 국가별 카페 수와 바리스타 수

```python
import matplotlib.pyplot as plt
import numpy as np

# 재현 가능한 결과를 위해 랜덤 시드 설정
np.random.seed(42)

# 샘플 데이터 생성
countries = ['브라질', '미국', '이탈리아', '한국', '일본']
colors = ['red', 'orange', 'green', 'blue', 'purple']
data = []

for country in countries:
    # 각 국가마다 50개의 데이터 포인트 생성
    cafes = np.random.normal(loc=np.random.randint(1000, 5000), scale=500, size=50)
    baristas = cafes * np.random.uniform(3, 7, 50)  # 각 카페마다 3-7명의 바리스타 가정
    avg_price = np.random.uniform(2, 6)  # 평균 커피 가격 (달러)
    data.append((country, cafes, baristas, avg_price))

# 산점도 생성
plt.figure(figsize=(12, 8))

for i, (country, cafes, baristas, avg_price) in enumerate(data):
    plt.scatter(cafes, baristas, c=colors[i], label=country, alpha=0.6, s=avg_price*20)

# 그래프 커스터마이징
plt.title('국가별 카페 수와 바리스타 수', fontsize=16)
plt.xlabel('카페 수', fontsize=12)
plt.ylabel('바리스타 수', fontsize=12)

plt.legend(title="국가")

# 각 국가에 대한 텍스트 주석 추가
for i, (country, cafes, baristas, avg_price) in enumerate(data):
    plt.annotate(f"{country}\n(${avg_price:.2f})", 
                 (np.mean(cafes), np.mean(baristas)),
                 xytext=(5, 5), 
                 textcoords='offset points',
                 fontsize=10,
                 fontweight='bold')

plt.tight_layout()

# 버블 크기에 대한 설명 추가
plt.text(0.95, 0.05, "버블 크기는\n평균 커피 가격을 나타냄", 
         horizontalalignment='right',
         verticalalignment='bottom',
         transform=plt.gca().transAxes,
         fontsize=10,
         alpha=0.7)

plt.show()
```
![colab](/images/essentials-numpy-pandas/chapter04/number_of_cafes.png)

이 시각화는 산점도를 사용하여 국가별 카페 산업의 여러 측면을 동시에 보여줍니다. X축은 카페 수를, Y축은 바리스타 수를 나타냅니다. 각 점은 국가의 도시 또는 지역을 대표하며, 점의 크기는 평균 커피 가격을 의미합니다 (큰 점일수록 높은 가격). 점들은 국가별로 다른 색상(빨강, 주황, 초록, 파랑, 보라)으로 구분되어 있습니다. 각 국가 데이터의 중심에는 해당 국가의 이름이 표시되어 있으며, 국가명 옆에는 달러 기호와 함께 평균 커피 가격이 표시되어 있습니다.

## 3.커피 소비량과 행복 지수의 관계

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# 재현 가능한 결과를 위해 시드 설정
np.random.seed(42)
# 기존 데이터에 가상의 행복 지수 추가 (약간의 노이즈 추가)
df['Happiness_Score'] = np.random.uniform(5.0, 8.0, len(df)) + np.random.normal(0, 0.5, len(df))
df['Happiness_Score'] = df['Happiness_Score'].clip(0, 10).round(2)  # 0-10 사이로 제한

# 시각화
plt.figure(figsize=(12, 8))
sns.scatterplot(data=df, x='Annual_Consumption_kg', y='Happiness_Score', 
                size='Cafe_Count', sizes=(100, 1000), 
                hue='Avg_Price_USD', palette='viridis', legend='brief')

# LOWESS를 사용한 회귀선 추가
lowess_result = lowess(df['Happiness_Score'], df['Annual_Consumption_kg'], frac=0.6)
plt.plot(lowess_result[:, 0], lowess_result[:, 1], color='red', linewidth=2)

# 국가 이름 표시
for i, row in df.iterrows():
    plt.annotate(row['Country'], (row['Annual_Consumption_kg'], row['Happiness_Score']), 
                 xytext=(5, 5), textcoords='offset points')

plt.title('Relationship between Coffee Consumption and Happiness Index', fontsize=16)
plt.xlabel('Annual Coffee Consumption (kg)', fontsize=12)
plt.ylabel('Happiness Index', fontsize=12)

# 범례 조정
plt.legend(title='Avg Coffee Price ($)', bbox_to_anchor=(1.05, 1), loc='upper left')

# 크기 범례 추가
size_legend = plt.scatter([], [], s=100, c='gray', label='10,000')
plt.scatter([], [], s=1000, c='gray', label='50,000')
plt.legend(title='Number of Cafes', handles=[size_legend], labelspacing=2, 
           bbox_to_anchor=(1.05, 0.5), loc='center left')

plt.tight_layout()
plt.show()
```
![colab](/images/essentials-numpy-pandas/chapter04/happiness.png)

이 시각화는 연간 커피 소비량과 행복 지수의 관계를 탐구하는 산점도입니다. X축은 연간 커피 소비량을, Y축은 행복 지수를 나타냅니다. 각 점은 하나의 국가를 대표하며, 점의 크기는 해당 국가의 카페 수를 의미합니다. 점의 색상은 평균 커피 가격을 나타내어, 가격 변화에 따른 색상 변화를 통해 추가적인 정보를 제공합니다. 그래프에 포함된 빨간 선은 LOWESS(Locally Weighted Scatterplot Smoothing) 회귀선으로, 커피 소비량과 행복 지수 사이의 전반적인 관계 추세를 보여줍니다. 이 시각화를 통해 커피 소비, 행복 지수, 카페의 보급 정도, 그리고 커피 가격 사이의 복잡한 관계를 한 눈에 파악할 수 있습니다.

# 2. 데이터 결합 문제와 해결책

```python
import pandas as pd

df = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.1, 4.2, 5.9, 2.8, 3.3, 5.4],
    '선호_종류': ['에스프레소', '아메리카노', '카푸치노', '카페라떼', '드립커피', '카페오레'],
    '카페_수': [25000, 32000, 18000, 12000, 22000, 15000],
    '평균_가격': [2.5, 3.8, 1.5, 4.2, 3.5, 2.8]
})

print("원본 커피 소비 데이터프레임:")
print(df)
print("")

```

## 2.1 키 불일치

우리는 두 개의 데이터프레임을 가지고 있습니다. 하나는 커피 관련 정보(df)를 담고 있고, 다른 하나는 국가별 GDP 정보(df_gdp)를 담고 있습니다. 이 두 데이터프레임을 국가를 기준으로 병합하려고 합니다. 그러나 각 데이터프레임에서 국가명을 나타내는 열의 이름이 서로 다릅니다 (df에서는 '국가', df_gdp에서는 'Country').
이로 인해 단순히 pd.merge(df, df_gdp)를 실행하면 결과가 빈 데이터프레임이 됩니다. 왜냐하면 merge 함수가 기본적으로 같은 이름의 열을 기준으로 데이터를 병합하려고 시도하기 때문입니다.

```python
# GDP 데이터를 담은 새로운 데이터프레임
df_gdp = pd.DataFrame({
    'Country': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    'GDP': [1830, 21400, 1900, 1630, 5150, 2700]
})

print("GDP 데이터:")
print(df_gdp)
print("단순 병합 시도 (실패):")
print(pd.merge(df, df_gdp))

```

이 문제를 해결하기 위해 merge 함수의 'left_on'과 'right_on' 매개변수를 사용합니다. 이를 통해 각 데이터프레임에서 서로 다른 이름을 가진 열을 기준으로 병합할 수 있습니다. 그 후, 중복된 열을 제거하여 최종 결과를 얻습니다

```python
print("해결 방법 (left_on, right_on 사용):")
result = pd.merge(df, df_gdp, left_on='국가', right_on='Country')
result = result.drop('Country', axis=1)  # 중복 열 제거
print(result)

```

## 2.2 중복 열

데이터 병합 시 중복 열 문제는 두 데이터프레임에 같은 이름의 열이 존재할 때 발생합니다. 이 경우, 단순 병합을 하면 pandas가 자동으로 '_x'와 '_y' 접미사를 붙여 구분하지만, 이는 명확성이 떨어질 수 있습니다.

```python
# 다른 연도의 연간 소비량 데이터
df_new_consumption = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '연간_소비량': [5.3, 4.4, 6.1, 3.0, 3.5, 5.6]
})

print("새로운 연간 소비량 데이터:")
print(df_new_consumption)
print("단순 병합 (열 이름 중복):")
print(pd.merge(df, df_new_consumption))

```

이 문제를 해결하기 위해 merge 함수의 'suffixes' 매개변수를 사용합니다. 이 매개변수를 통해 중복되는 열 이름에 붙일 접미사를 지정할 수 있습니다. 예를 들어, 하나는 '2022년 소비량', 다른 하나는 '2023년 소비량'이라고 이름을 붙여줍니다.

```python
print("해결 방법 (suffixes 사용):")
result = pd.merge(df, df_new_consumption, on='국가', suffixes=('_2022', '_2023'))
print(result)

```

## 2.3 데이터 유실

우리에게는 두 개의 데이터프레임이 있습니다. 하나는 모든 국가의 커피 관련 정보(df)이고, 다른 하나는 일부 국가의 수출량 데이터(df_partial)입니다. 이 두 데이터프레임을 '국가'를 기준으로 병합하려고 합니다.
기본적인 내부 조인(inner join)을 사용하면, 두 데이터프레임에 모두 존재하는 국가의 데이터만 결과에 포함됩니다. 이로 인해 수출량 데이터가 없는 국가들(예: 한국, 일본, 프랑스)의 정보가 완전히 사라지게 됩니다. 이는 중요한 데이터의 손실을 의미합니다.

```python
# 일부 국가만 포함된 수출량 데이터
df_partial = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '독일'],
    '수출량': [1500, 2000, 1000, 1200]
})

print("부분적인 수출량 데이터:")
print(df_partial)
print("내부 조인 결과 (데이터 유실):")
print(pd.merge(df, df_partial, on='국가'))

```

데이터 유실 문제를 해결하기 위해 외부 조인(outer join)을 사용합니다. merge 함수의 'how' 매개변수를 'outer'로 설정하면, 두 데이터프레임의 모든 국가 정보를 유지하면서 병합할 수 있습니다. 이 방법을 통해 수출량 데이터가 없는 국가들의 정보도 결과에 포함되며, 누락된 데이터는 NaN(결측치)으로 표시됩니다. 이로써 데이터의 완전성을 유지하면서도 부분적으로 누락된 정보를 명확히 식별할 수 있어, 더 포괄적이고 정확한 분석이 가능해집니다.

```python
print("해결 방법 (외부 조인 사용):")
result = pd.merge(df, df_partial, on='국가', how='outer')
print(result)

```

## 2.4 데이터 타입 불일치

데이터 타입 불일치 문제는 두 데이터프레임에서 같은 정보가 서로 다른 형식으로 저장되어 있을 때 발생합니다. 이 경우, '카페_수' 정보가 한 데이터프레임에서는 숫자(정수)로, 다른 데이터프레임에서는 쉼표가 포함된 문자열로 저장되어 있습니다. 이러한 불일치로 인해 데이터를 직접 병합하거나 비교하는 것이 불가능하며, 연산 시 오류가 발생할 수 있습니다.

```python
# 문자열로 된 카페 수 데이터
df_str_cafes = pd.DataFrame({
    '국가': ['브라질', '미국', '이탈리아', '한국', '일본', '프랑스'],
    '카페_수_문자열': ['25,000', '32,000', '18,000', '12,000', '22,000', '15,000']
})

print("문자열 형식의 카페 수 데이터:")
print(df_str_cafes)
print("데이터 타입 확인:")
print(df['카페_수'].dtype)
print(df_str_cafes['카페_수_문자열'].dtype)

```

문제를 해결하기 위해서는 데이터 타입을 일치시키는 변환 과정이 필요합니다. 문자열로 된 데이터에서 쉼표를 제거하고 정수형으로 변환하는 과정을 거칩니다. df_str_cafes['카페_수_문자열'].str.replace(',', '').astype(int) 코드를 사용하여 쉼표를 제거하고 정수로 변환합니다. 이렇게 데이터 타입을 통일한 후에 merge 함수를 사용하면, 정확한 데이터 병합이 가능해지고 추후 분석 과정에서 발생할 수 있는 오류를 예방할 수 있습니다.

```python
print("해결 방법 (데이터 타입 변환):")
df_str_cafes['카페_수_문자열'] = df_str_cafes['카페_수_문자열'].str.replace(',', '').astype(int)
result = pd.merge(df, df_str_cafes, on='국가')
print(result)

```