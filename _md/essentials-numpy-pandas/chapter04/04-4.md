---
chapter: Pandas
title: Pandas DataFrame 2 
date: 2024-07-17
---

# 1. 결측치 처리

결측치는 데이터 분석에서 중요하게 다뤄야 할 문제로, 데이터의 품질과 분석 결과의 신뢰성에 직접적인 영향을 미칩니다. 이는 설문조사에서의 무응답, 센서 오작동, 데이터 전송 오류, 또는 단순히 정보 누락 등 다양한 원인으로 발생할 수 있습니다. pandas에서는 결측치를 NaN(Not a Number)으로 표현하며, 이를 식별하고 처리하는 여러 방법을 제공합니다.

## 1.1 결측치 확인

isnull() 메서드는 데이터셋 내의 결측치를 식별하는 데 사용됩니다. 이 메서드는 데이터프레임이나 시리즈의 각 요소를 검사하여 해당 값이 결측치인지 아닌지를 판단합니다. 결과로 반환되는 불리언 마스크는 원본 데이터와 동일한 구조를 가지며, 각 위치에 True 또는 False 값을 할당하여 결측치 여부를 나타냅니다. 이를 통해 데이터 분석가는 결측치의 분포와 패턴을 쉽게 파악할 수 있으며, 이는 데이터 전처리 단계에서 결측치 처리 전략을 수립하는 데 필수적인 정보를 제공합니다. isnull() 메서드는 NaN, None, NaT 등 다양한 형태의 결측치를 인식할 수 있어, 복잡한 데이터셋에서도 신뢰성 있는 결측치 탐지가 가능합니다. 

```python-exec
import pandas as pd
import numpy as np

df = pd.DataFrame({
    'A': [1, 2, np.nan, 4],
    'B': [5, np.nan, np.nan, 8],
    'C': [9, 10, 11, 12]
})

print("데이터프레임:")
print(df)

print("결측치 확인 (True가 결측치):")
print(df.isnull())

print("결측치 개수:")
print(df.isnull().sum())

print("결측치가 있는 행 확인:")
print(df[df.isnull().any(axis=1)])

print("결측치 비율:")
print(df.isnull().mean())
```


## 1.2 결측치 제거

dropna() 메서드는 데이터프레임에서 결측치를 포함한 행이나 열을 제거하는 데 사용됩니다. 이 메서드는 데이터 전처리 과정에서 결측치를 처리하는 가장 간단하고 직접적인 방법 중 하나입니다. dropna()는 다양한 매개변수를 통해 사용자가 결측치 제거 방식을 세밀하게 제어할 수 있게 해줍니다. 예를 들어, axis 매개변수를 사용하여 행을 제거할지 열을 제거할지 선택할 수 있으며, how 매개변수로 모든 값이 결측치인 경우에만 제거할지, 하나라도 결측치가 있으면 제거할지 결정할 수 있습니다. 

```python-exec
df_dropna = df.dropna()
print("결측치가 있는 모든 행 제거 후 데이터프레임:")
print(df_dropna)

df_dropna_thresh = df.dropna(thresh=2)  # 최소 2개 이상의 비결측치가 있는 행만 유지
print("최소 2개 이상의 비결측치가 있는 행만 유지:")
print(df_dropna_thresh)
```

## 1.3 결측치 대체

fillna() 메서드는 데이터프레임의 결측치를 사용자가 지정한 값이나 방법으로 대체할 수 있게 해줍니다. 이 메서드는 데이터의 완전성을 유지하면서 결측치를 처리하고자 할 때 널리 사용됩니다. fillna()는 다양한 옵션을 제공하여 결측치 대체 방식을 세밀하게 조정할 수 있습니다. 예를 들어, 특정 값으로 모든 결측치를 채우거나, 각 열의 평균, 중앙값, 최빈값 등 통계량으로 대체할 수 있습니다. 또한 'ffill' 또는 'bfill' 메서드를 사용하여 이전 값이나 다음 값으로 결측치를 채울 수도 있습니다. limit 매개변수를 통해 연속된 결측치 중 일부만 채우도록 제한할 수 있으며, inplace 매개변수로 원본 데이터를 직접 수정할지 새로운 복사본을 반환할지 선택할 수 있습니다.

```python-exec
df_fillna = df.fillna(0)
print("결측치를 0으로 대체한 데이터프레임:")
print(df_fillna)

df_fillna_method = df.fillna(method='ffill')  # 앞의 값으로 채우기
print("결측치를 앞의 값으로 대체한 데이터프레임:")
print(df_fillna_method)

df_fillna_mean = df.fillna(df.mean())  # 평균값으로 채우기
print("결측치를 평균값으로 대체한 데이터프레임:")
print(df_fillna_mean)
```

# 2. 데이터 변환 및 정렬
데이터 변환 및 조작은 데이터 분석의 핵심 단계로, 원시 데이터를 분석에 적합한 형태로 가공하고 정제하는 과정입니다. 이는 데이터 품질 향상과 분석의 정확성, 효율성 증대에 필수적입니다. 주요 작업으로는 데이터 타입 변경, 스케일 조정, 범주형 변수 인코딩, 이상치 처리 등이 있습니다. 또한 데이터 정렬은 특정 기준에 따라 데이터를 순서대로 배열하는 중요한 조작 기법입니다. 정렬을 통해 데이터의 패턴을 시각적으로 파악하거나 특정 조건에 맞는 데이터를 쉽게 찾을 수 있습니다. 예를 들어, 시계열 데이터의 날짜순 정렬이나 판매 데이터의 금액순 정렬 등이 이에 해당합니다. 이러한 과정들은 데이터에서 의미 있는 정보를 추출하고 효과적인 분석을 수행하는 데 중요한 역할을 합니다.
## 2.1 데이터 타입 변환

데이터프레임의 열 데이터 타입을 변환하는 작업은 데이터 분석과 처리 과정에서 중요한 역할을 합니다. 이는 메모리 사용을 최적화하고, 특정 연산이나 분석 기법을 적용하기 위해 필요할 수 있습니다. 또한, 데이터의 일관성과 정확성을 유지하거나, 특정 라이브러리와의 호환성을 위해서도 타입 변환이 요구될 수 있습니다. pandas 라이브러리에서는 astype() 메서드나 to_numeric(), to_datetime() 등의 함수를 사용하여 간편하게 데이터 타입을 변환할 수 있습니다. 그러나 데이터 손실이나 왜곡을 방지하기 위해 변환 시에는 주의가 필요하며, 변환 전후로 데이터의 특성을 꼼꼼히 확인하는 것이 중요합니다. 

```python-exec
df = pd.DataFrame({
    'A': ['1', '2', '3', '4'],
    'B': [1.0, 2.0, 3.0, 4.0],
    'C': [1, 2, 3, 4]
})

print("원본 데이터프레임 타입:")
print(df.dtypes)

df['A'] = df['A'].astype('int')
df['B'] = df['B'].astype('float32')
df['C'] = df['C'].astype('str')

print("변환 후 데이터프레임 타입:")
print(df.dtypes)
```


:::div{.callout}

**Tip ! 데이터 타입**
| 데이터 타입 | 설명 | 예시 |
|-------------|------|------|
| int64 | 64비트 정수 | 1, -10, 1000 |
| float64 | 64비트 부동소수점 | 3.14, -0.01, 2.0e-3 |
| object | 문자열 또는 혼합 타입 | "Hello", [1, 2, 3] |
| bool | 불리언 값 | True, False |
| datetime64 | 날짜와 시간 | 2023-06-15 14:30:00 |
| timedelta64 | 시간 간격 | 2 days 3 hours |
| category | 범주형 데이터 | "Red", "Green", "Blue" |
 :::


## 2.2 값 기준 정렬
값 기준 정렬은 데이터프레임이나 시리즈의 데이터를 특정 열이나 행의 값을 기준으로 오름차순 또는 내림차순으로 재배열하는 과정입니다. pandas에서는 sort_values() 메서드를 사용하여 이를 수행할 수 있습니다.
오름차순 정렬은 값이 작은 것부터 큰 순서로 배열하는 것으로, sort_values() 메서드의 기본 설정입니다. 내림차순 정렬은 값이 큰 것부터 작은 순서로 배열하며, ascending=False 매개변수를 사용하여 지정할 수 있습니다.
```python-exec
df = pd.DataFrame({
    'A': [3, 1, 4, 2],
    'B': ['b', 'a', 'd', 'c']
})

print("원본 데이터프레임:")
print(df)

df_sorted = df.sort_values(by='A')
print("A 열 기준 오름차순 정렬:")
print(df_sorted)

df_sorted_multi = df.sort_values(by=['B', 'A'], ascending=[False, True])
print("B 열 기준 내림차순, A 열 기준 오름차순 정렬:")
print(df_sorted_multi)
```

## 2.3 인덱스 기준 정렬
pandas에서는 sort_index() 메서드를 사용하여 인덱스를 기준으로 정렬할 수 있습니다. 이 메서드는 기본적으로 인덱스를 오름차순으로 정렬하지만, ascending=False 매개변수를 사용하여 내림차순 정렬도 가능합니다.
예를 들어, df.sort_index()는 데이터프레임을 인덱스 기준으로 오름차순 정렬하고, df.sort_index(ascending=False)는 내림차순으로 정렬합니다. 다중 인덱스의 경우, level 매개변수를 사용하여 특정 레벨의 인덱스를 기준으로 정렬할 수 있습니다.

```python-exec
df.index = ['d', 'b', 'a', 'c']
print("인덱스가 있는 데이터프레임:")
print(df)

df_sorted_index = df.sort_index()
print("인덱스 기준 오름차순 정렬:")
print(df_sorted_index)
```



# 3. 데이터 결합 및 병합

데이터 결합 및 병합은 데이터 분석과 처리에서 핵심적인 작업으로, 여러 데이터셋을 의미 있는 방식으로 통합하는 과정입니다. 이는 다양한 소스에서 얻은 데이터를 하나의 통합된 데이터셋으로 만들어 더 포괄적이고 종합적인 분석을 가능하게 합니다. 이 과정을 통해 개별 데이터셋에서는 얻기 어려운 깊이 있는 인사이트를 도출할 수 있으며, 데이터 간의 복잡한 관계와 패턴을 파악할 수 있습니다. 결과적으로, 데이터 결합은 더 정확하고 신뢰성 있는 의사결정을 지원하는 중요한 도구로 활용됩니다.

## 3.1 concat 함수
![피그마](/images/essentials-numpy-pandas/chapter04/Concatenate.png )

concat 함수는 pandas에서 데이터프레임이나 시리즈를 연결하는 데 사용되는 유용한 도구입니다. 이 함수는 주로 유사한 구조를 가진 데이터를 단순히 붙이는 데 적합하며, 기본적으로 데이터를 위아래로 연결하지만 옵션을 변경하여 좌우로도 연결할 수 있습니다. concat은 인덱스 처리, 누락된 데이터 처리, 중복 열 처리 등 다양한 옵션을 제공하여 유연한 데이터 결합이 가능합니다. 

```python-exec
df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

df_concat_vertical = pd.concat([df1, df2])
print("수직으로 연결한 데이터프레임:")
print(df_concat_vertical)

df3 = pd.DataFrame({'C': [9, 10], 'D': [11, 12]})
df_concat_horizontal = pd.concat([df1, df3], axis=1)
print("수평으로 연결한 데이터프레임:")
print(df_concat_horizontal)
```

## 3.2 merge 함수


pandas의 merge 함수는 데이터 분석에서 핵심적인 도구로, 여러 데이터셋을 하나로 결합합니다. 이 함수는 마치 퍼즐을 맞추듯이 공통된 열을 기준으로 데이터프레임을 연결합니다. 예를 들어, 학생 이름과 성적이 있는 데이터프레임과 학생 이름과 주소가 있는 데이터프레임을 '이름' 열을 기준으로 합칠 수 있습니다.
merge 함수는 내부, 외부, 왼쪽, 오른쪽 조인 등 다양한 결합 방식을 지원하여 분석 목적에 맞게 유연하게 사용할 수 있습니다. 또한 여러 열을 동시에 기준으로 사용하거나 서로 다른 이름의 열도 쉽게 연결할 수 있어, 복잡한 데이터 구조도 효과적으로 다룰 수 있습니다.

![피그마](/images/essentials-numpy-pandas/chapter04/merge_graph.png )

```python-exec
df1 = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})
df2 = pd.DataFrame({'key': ['A', 'B', 'D'], 'value2': [4, 5, 6]})

df_merged = pd.merge(df1, df2, on='key', how='inner')
print("내부 병합 (inner join):")
print(df_merged)

df_merged_outer = pd.merge(df1, df2, on='key', how='outer')
print("외부 병합 (outer join):")
print(df_merged_outer)

df_merged_left = pd.merge(df1, df2, on='key', how='left')
print("왼쪽 병합 (left join):")
print(df_merged_left)
```
![피그마](/images/essentials-numpy-pandas/chapter04/merge_table.png )

## 3.3 join 함수

join 함수는 주로 인덱스를 기준으로 데이터프레임을 병합하는 데 사용되는 pandas의 메서드입니다. 이는 마치 책의 색인을 사용해 관련 페이지를 찾아가는 것과 유사합니다. join은 기본적으로 간단하고 직관적인 방식으로 작동하여, 특히 시계열 데이터나 이미 잘 정렬된 데이터를 결합할 때 효과적입니다. 인덱스 기반 결합에서는 merge보다 더 빠른 성능을 보일 수 있어, 대규모 데이터셋을 다룰 때 유리할 수 있습니다.

![피그마](/images/essentials-numpy-pandas/chapter04/df_join.png )

```python-exec
df1 = pd.DataFrame({'value1': [1, 2, 3]}, index=['A', 'B', 'C'])
df2 = pd.DataFrame({'value2': [4, 5, 6]}, index=['A', 'B', 'D'])

df_joined = df1.join(df2, how='inner')
print("내부 조인:")
print(df_joined)

df_joined_outer = df1.join(df2, how='outer')
print("외부 조인:")
print(df_joined_outer)
```

:::div{.callout}

** merge 함수 vs join 함수 vs concat 함수**
| 특성 | merge 함수 | join 함수 | concat 함수 |
|------|------------|-----------|-------------|
| 결합 기준 | 열(column) | 인덱스(index) | 축(axis) |
| 사용 방식 | pd.merge(df1, df2) | df1.join(df2) | pd.concat([df1, df2]) |
| 유연성 | 높음 | 중간 | 높음 |
| 복잡한 결합 | 적합 | 덜 적합 | 덜 적합 |
| 성능 (인덱스 기반) | 느림 | 빠름 | 빠름 |
| 주요 용도 | 복잡한 데이터 통합 | 간단한 데이터 결합, 시계열 데이터 | 데이터 연결(스택킹) |
| 키 기반 결합 | 가능 | 가능 (인덱스 기준) | 불가능 |
| 다중 데이터프레임 결합 | 두 개씩 결합 | 두 개씩 결합 | 여러 개 동시 결합 가능 |
:::

이 표는 merge, join, concat 함수의 주요 특징을 비교하여 보여줍니다. concat 함수는 주로 데이터를 단순히 연결(스택킹)할 때 사용되며, 키 기반 결합은 지원하지 않지만 여러 데이터프레임을 한 번에 연결할 수 있다는 특징이 있습니다.

