---
chapter: 메서드
title: 재귀 메서드
date: 2024-08-29
---
# 1. 재귀 메서드
재귀 메서드(Recursive Method)는 자기 자신을 호출하는 메서드를 말합니다. 이는 문제를 더 작은 동일한 형태의 하위 문제로 나누어 해결하는 방식입니다.

# 2. 재귀 메서드의 구조
재귀 메서드는 일반적으로 다음과 같은 구조를 가집니다.
```java
public 반환타입 메서드이름(매개변수) {
    if (종료 조건) {
        return 기본 케이스 결과;
    } else {
        return 재귀 호출;
    }
}
```

# 3. 재귀 메서드의 주요 요소
재귀 메서드는 다음 두 가지 주요 요소로 구성됩니다.
```java
public int factorial(int n) {
    if (n == 0 || n == 1) {  // 기본 케이스
        return 1;
    }
    return n * factorial(n - 1);  // 재귀 케이스
}
```
## 3.1 기본 케이스 (Base Case)
- 재귀 호출을 멈추는 조건입니다.
- 더 이상 재귀 호출이 필요 없는 가장 단순한 경우를 처리합니다.

## 3.2 재귀 케이스 (Recursive Case)
- 문제를 더 작은 문제로 나누고 자기 자신을 호출하는 부분입니다.
- 주어진 문제를 해결하기 위해 동일한 메서드를 더 작은 입력값으로 호출합니다.


# 4. 재귀 메서드의 예시
## 4.1 팩토리얼 계산
```java
public static int factorial(int n) {
    if (n == 0 || n == 1) {  // 기본 케이스
        return 1;
    } else {  // 재귀 케이스
        return n * factorial(n - 1);
    }
}
```
- 팩토리얼은 n!으로 표기하며, n부터 1까지의 모든 정수를 곱한 값입니다.
- 기본 케이스: 0!과 1!은 1로 정의됩니다. 이는 재귀 호출의 종료 조건입니다.
- 재귀 케이스: n!은 n * (n-1)!로 계산할 수 있습니다. 이 성질을 이용해 재귀적으로 문제를 해결합니다.
- 예를 들어, factorial(5)는 다음과 같이 계산됩니다.
    ```
    5 * factorial(4)
    5 * (4 * factorial(3))
    5 * (4 * (3 * factorial(2)))
    5 * (4 * (3 * (2 * factorial(1))))
    5 * (4 * (3 * (2 * 1))) = 120
    ```

## 4.2 피보나치 수열
```java
public static int fibonacci(int n) {
    if (n <= 1) {  // 기본 케이스
        return n;
    } else {  // 재귀 케이스
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

# 5. 재귀 메서드의 장단점
## 5.1 장점
- 복잡한 문제를 간단하고 명확하게 표현할 수 있음
- 코드의 가독성이 향상됨
- 일부 알고리즘(예: 트리 순회)에서 매우 효과적

## 5.2 단점
- 메모리 사용량이 증가할 수 있음 (호출 스택 오버플로우 가능성)
- 반복문에 비해 성능이 떨어질 수 있음
- 잘못 설계하면 무한 재귀에 빠질 수 있음

# 6. 재귀 메서드 설계 시 주의사항
- 종료 조건(기본 케이스)을 반드시 포함해야 함
- 각 재귀 호출이 종료 조건에 가까워지도록 설계
- 스택 오버플로우를 방지하기 위해 재귀 깊이에 주의
- 필요한 경우 메모이제이션(memoization) 기법을 사용하여 성능 개선

# 7. 재귀와 반복의 비교
1. 재귀 방식
    ```java
    public static int sum(int n) {
        if (n == 1) {
            return 1;
        } else {
            return n + sum(n - 1);
        }
    }
    ```

2. 반복 방식
    ```java
    public static int sum(int n) {
        int result = 0;
        for (int i = 1; i <= n; i++) {
            result += i;
        }
        return result;
    }
    ```

:::div{.callout}
재귀 메서드는 특정 유형의 문제를 우아하게 해결할 수 있는 강력한 도구입니다. 그러나 메모리 사용과 성능을 고려해야 하며, 항상 종료 조건을 명확히 설정해야 합니다. 재귀와 반복 중 어느 것을 사용할지는 문제의 성격, 가독성, 성능 요구사항 등을 고려하여 결정해야 합니다.
:::