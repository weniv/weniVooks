---
chapter: React 기본 개념
title: Fragments
date: 2024-08-07
---

# 1. Fragments

Fragments는 React에서 여러 요소를 그룹화하는 특별한 기능입니다. React 컴포넌트는 하나의 부모 요소만 반환해야 한다는 제약이 있는데, 이로 인해 불필요한 <div> 태그를 사용해야 하는 경우가 종종 발생합니다. Fragments를 사용하면 이러한 제약을 해결하고, 더 깔끔한 DOM 구조를 만들 수 있습니다.

:::div{.callout}
아래 링크는 Fragment에 대한 공식 문서입니다.

::a[React - Fragments]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/fragments.html" target="\_blank"}

:::

## 1.1. Fragments 사용법

:::div{.box}
Fragment를 사용하면 다음과 같은 이점이 있습니다.

1. DOM에 불필요한 노드를 추가하지 않습니다.
2. 플렉스박스나 CSS 그리드 레이아웃에서 더 유연하게 사용할 수 있습니다.
3. 약간의 메모리 사용량을 줄일 수 있습니다.

:::

Fragments를 사용하는 방법에는 두 가지가 있습니다.

### 1.1.1. 명시적 사용

```jsx
import React from 'react';

function App() {
  return (
    <React.Fragment>
      <h1>제목</h1>
      <p>내용</p>
    </React.Fragment>
  );
}
```

### 1.1.2. 단축 문법

```jsx
function App() {
  return (
    <>
      <h1>제목</h1>
      <p>내용</p>
    </>
  );
}
```

단축 문법을 사용할 때는 React를 별도로 import할 필요가 없어 더 간결한 코드를 작성할 수 있습니다.

## 1.2. Props와 Key

Fragment도 React 엘리먼트이므로 props를 전달할 수 있습니다. 주로 key prop을 사용하여 리스트 렌더링 시 각 항목을 구분합니다. 아래는 Fragment를 활용한 예시입니다.

```jsx
function ItemList({ items }) {
  return (
    <dl>
      {items.map((item) => (
        <React.Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}
```

이 예제에서는 정의 목록(definition list)을 생성하면서 각 항목을 Fragment로 감싸고 있습니다. 이렇게 하면 불필요한 래퍼 요소 없이 dt와 dd 요소를 그룹화할 수 있습니다.

:::div{.callout}
단축 문법 `<>...</>`에서는 key를 포함한 어떤 props도 사용할 수 없습니다.

:::

## 1.3. Fragments 사용 비교

Fragments를 사용하면 불필요한 DOM 노드를 줄일 수 있어 성능과 스타일링 측면에서 이점이 있습니다.

### 1.3.1. `Fragment 미사용`

```jsx
function WithoutFragment() {
  return (
    <div>
      <h1>제목</h1>
      <p>내용</p>
    </div>
  );
}
```

위의 WithoutFragment 컴포넌트는 불필요한 div 태그를 생성합니다.

### 1.3.2. `Fragment 사용`

```jsx
function WithFragment() {
  return (
    <>
      <h1>제목</h1>
      <p>내용</p>
    </>
  );
}
```

WithFragment 컴포넌트는 추가적인 DOM 노드 없이 깔끔한 HTML 구조를 유지합니다. 이렇게 Fragments를 사용하면 코드의 가독성이 높아지고 유지 관리가 쉬워집니다.

# 2. 조건부 렌더링

조건부 렌더링은 특정 조건에 따라 다른 내용을 화면에 표시하는 기법입니다. React에서는 JavaScript의 조건문을 활용하여 구현합니다.

```jsx
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>환영합니다!</h1>;
  }
  return <h1>로그인해 주세요.</h1>;
}

function LoginButton({ isLoggedIn, onClick }) {
  return (
    <button onClick={onClick}>{isLoggedIn ? '로그아웃' : '로그인'}</button>
  );
}

function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const handleLoginClick = () => {
    setIsLoggedIn(!isLoggedIn);
  };

  return (
    <div>
      <Greeting isLoggedIn={isLoggedIn} />
      <LoginButton isLoggedIn={isLoggedIn} onClick={handleLoginClick} />
    </div>
  );
}
```

이 예제에서는 if 문과 삼항 연산자를 사용하여 로그인 상태에 따라 다른 메시지와 버튼 텍스트를 표시합니다. 조건부 렌더링을 통해 사용자의 상태에 따라 적절한 UI를 동적으로 제공할 수 있습니다.

# 3. React에서의 스타일링

React에서는 다양한 방식으로 스타일을 적용할 수 있습니다. 각 방식의 장단점을 이해하고 상황에 맞게 선택하는 것이 중요합니다.

## 3.1. 인라인 스타일

JSX 요소에 직접 스타일을 적용하는 방법입니다.

```jsx
function InlineStyleExample() {
  const styles = {
    color: 'blue',
    fontSize: '20px',
    fontWeight: 'bold',
  };

  return <div style={styles}>인라인 스타일 예시</div>;
}
```

간단하고 빠르게 적용이 가능한 장점이 있지만, 재사용성이 떨어지고, 복잡한 스타일에는 적합하지 않습니다.

## 3.2. CSS 클래스

::img{width="100" alt="CSS" src="/images/basecamp-react/chapter02-6/chapter02-6-1.png"}

별도의 CSS 파일을 만들어 사용하는 전통적인 방식입니다.

```jsx
import './styles.css';

function CssClassExample() {
  return (
    <div className="container">
      <h1 className="title">CSS 클래스 예시</h1>
    </div>
  );
}
```

기존의 CSS 지식을 그대로 활용할 수 있어 익숙하고 사용하기 쉽다는 장점이 있지만, 전역 스코프로 인한 스타일 충돌 가능성이 존재합니다.

## 3.3. CSS 모듈

CSS 파일을 모듈로 불러와 사용하는 방식으로, 스타일의 범위를 컴포넌트로 제한합니다.

```jsx
import styles from './Button.module.css';

function Button() {
  return <button className={styles.button}>CSS 모듈 버튼</button>;
}
```

스타일 충돌 방지와 컴포넌트 단위의 스타일 관리가 가능하다는 장점이 있지만, 약간의 부가적인 설정이 필요할 수 있어 번거롭습니다.

## 3.4. Styled-components

::img{width="200" alt="CSS" src="/images/basecamp-react/chapter02-6/chapter02-6-2.png"}

JavaScript 안에서 CSS를 작성하는 CSS-in-JS 라이브러리입니다.

```jsx
import styled from 'styled-components';

const StyledButton = styled.button`
  background-color: ${(props) => (props.primary ? 'blue' : 'white')};
  color: ${(props) => (props.primary ? 'white' : 'blue')};
  padding: 10px 20px;
  border: 2px solid blue;
  border-radius: 4px;
`;

function StyledComponentExample({ isPrimary }) {
  return <StyledButton primary={isPrimary}>Styled Component 버튼</StyledButton>;
}
```

동적 스타일링이 쉽고 컴포넌트와 스타일을 함께 관리할 수 있다는 장점을 가지지만, 새로운 문법이라 학습이 필요하고 번들 크기가 증가하는 단점이 있습니다.
