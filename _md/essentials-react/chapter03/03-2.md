---
chapter: React 기본 개념
title: JSX
date: 2024-08-07
---

# 1. JSX란?

`JSX(JavaScript XML)`는 React에서 UI를 표현하기 위한 JavaScript의 확장 문법입니다. JavaScript 코드 안에서 HTML과 유사한 마크업을 작성할 수 있게 해주며, 컴파일 시에는 일반 JavaScript 코드로 변환됩니다.

<!-- 아래 글 수정 필요 -->
<!-- 이를 통해 선언적 UI 프로그래밍이 가능해집니다. -->
<!-- JSX를 사용하면 JavaScript 코드와 HTML 태그를 함께 사용하여 UI를 렌더링할 수 있어서, UI 코드의 가독성과 유지보수성이 높아집니다 ☺️ -->

src에 있는 App.js의 내용은 다음과 같습니다.

```jsx
function App() {
  return (
    <div className="App">
      <h2>hello world</h2>
    </div>
  );
}

export default App;
```

# 2. JSX 문법

## 2.1. 최상위 요소 규칙

JSX에서는 여러 요소를 반환할 때 반드시 하나의 부모 요소로 감싸야 합니다. 이는 React가 단일 컴포넌트를 효율적으로 관리하고 렌더링하기 위함입니다.

```jsx
function App() {
  return (
    <div>
      <h1>제목</h1>
      <p>내용</p>
    </div>
  );
}
```

만약 추가적인 div를 사용하고 싶지 않다면, 아래와 같이 React Fragment를 사용할 수 있습니다.

```jsx
function App() {
  return (
    <>
      <h1>제목</h1>
      <p>내용</p>
    </>
  );
}
```

## 2.2 스타일링 방법

JSX에서는 세 가지 주요 스타일링 방법을 사용할 수 있습니다.

### 2.2.1 인라인 스타일

JSX에서 인라인 스타일은 객체 형태로 작성합니다. 속성 이름은 camelCase로 작성해야 합니다.

:::div{.callout}
`camelCase`는 프로그래밍에서 자주 사용되는 명명 규칙(naming convention) 중 하나입니다. 이름을 지을 때 여러 단어를 조합해야 하는 경우, 각 단어의 첫 글자를 대문자로 표기하되 가장 첫 단어의 첫 글자는 소문자로 표기하는 방식입니다. 단, 단어 사이에 공백이나 특수 문자를 사용하지 않습니다. camelCase라는 이름은 단어들이 연결된 모양이 낙타(camel)의 등처럼 보인다고 해서 붙여졌습니다. 예를 들어, firstName 또는 lastName 으로 표현해야 합니다.

:::

```jsx
<div style={{ backgroundColor: 'blue', fontSize: '20px' }}>스타일 적용</div>
```

### 2.2.2 className을 사용한 외부 CSS

```css
/* App.css */
.button {
  background-color: blue;
  color: white;
  padding: 10px 20px;
}
```

```jsx
// App.jsx
import './App.css';

function App() {
  return <button className="button">클릭하세요</button>;
}
```

### 2.2.3 CSS Module 사용

```css
/* Button.module.css */
.button {
  background-color: blue;
  color: white;
}
```

```jsx
// Button.jsx
import styles from './Button.module.css';

function Button() {
  return <button className={styles.button}>클릭하세요</button>;
}
```

## 2.3 JavaScript 표현식

중괄호 `{}` 안에 유효한 모든 JavaScript 표현식을 넣을 수 있습니다. 이를 통해 동적인 값을 쉽게 렌더링할 수 있습니다.

```jsx
const name = '라이캣';
const isLoggedIn = true;

return (
  <div>
    <h1>안녕하세요, {name}님!</h1>
    {isLoggedIn && <p>로그인 상태입니다.</p>}
  </div>
);
```

## 2.4 조건부 렌더링

JSX 내에서 조건부 렌더링을 할 수 있습니다. 삼항 연산자나 && 연산자를 주로 사용합니다.

```jsx
const isLoggedIn = true;

return <div>{isLoggedIn ? <p>환영합니다!</p> : <p>로그인해주세요.</p>}</div>;
```

# 3. 실습

## 3.1 (동적 시계 만들기)

JSX를 사용해 실시간으로 업데이트되는 시계를 만들어 보겠습니다.

```jsx
import React, { useState, useEffect } from 'react';

function Clock() {
  const [time, setTime] = useState(new Date());

  useEffect(() => {
    const timer = setInterval(() => {
      setTime(new Date());
    }, 1000);

    return () => {
      clearInterval(timer);
    };
  }, []);

  return (
    <div>
      <h1>현재 시간</h1>
      <p>{time.toLocaleTimeString()}</p>
    </div>
  );
}

export default Clock;
```

이 예제에서는 useState와 useEffect Hook을 사용하여 1초마다 시간을 업데이트하여 현재 시간을 보여주는 간단한 시계를 만듭니다. JSX의 `new Date()`로 현재 시간을 가져오고, JavaScript의 `toLocaleTimeString()`메서드로 시간을 읽기 쉬운 형태로 포맷팅(변환)합니다.

## 3.2 리스트 렌더링

배열 데이터를 이용해 아래와 같은 컴포넌트를 만들어보세요. visited 값이 true인 지역은 배경색을 지정하도록 스타일을 적용해주세요.

```jsx
const list = [
  { no: 1, area: '대전', visited: false },
  { no: 2, area: '부산', visited: true },
  { no: 3, area: '목포', visited: false },
  { no: 4, area: '제주도', visited: false },
];
```

:::div{.callout}
**key props**

위의 예제를 풀이하다 보면 리스트 아이템에 key 값이 필요하다는 것을 알 수 있습니다.
key props을 사용하면 리스트에 변화가 발생했을 때 React가 엘리먼트의 변경사항을 빠르게 감지하고, 렌더링을 최적화할 수 있습니다. 보통 배열을 순회하면서 각각의 항목을 <li> 엘리먼트로 렌더링할 때, 각 항목에 key prop을 제공합니다. key prop을 제공하지 않으면 React가 렌더링을 최적화하지 못하고, 업데이트 성능이 저하될 수 있습니다.

::a[참고]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/reconciliation.html#recursing-on-children" target="\_blank"}

</aside>
