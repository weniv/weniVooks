---
chapter: React 중급 개념
title: React의 이벤트 처리
date: 2024-07-04
---

# 1. React에서의 이벤트 처리

React에서 이벤트는 사용자 상호작용이나 시스템 이벤트에 대응하는 중요한 메커니즘입니다.

## 1.1. 이벤트의 개념

이벤트란 웹 애플리케이션에서 사용자나 브라우저가 수행하는 특정 동작을 말합니다. 예를 들어, 버튼 클릭, 키보드 입력, 마우스 이동 등이 있습니다.

## 1.2. 이벤트 시스템

React는 자체적인 이벤트 시스템(Synthetic Event)를 사용합니다. 이는 브라우저의 네이티브 이벤트를 감싸고 있어, 크로스 브라우저 호환성을 보장합니다.

```jsx
function handleClick(event) {
  event.preventDefault(); // 기본 동작 방지
  console.log('The link was clicked.');
}
```

## 1.3. 이벤트 처리 기본 문법

React에서는 이벤트 이름을 camelCase로 작성합니다. 예: `onClick`, `onSubmit`

::img{width="400" alt="Click Me" src="/images/basecamp-react/chapter02-7/chapter02-7-1.png"}

```jsx
function Button() {
  const handleClick = () => {
    alert('버튼이 클릭되었습니다!');
  };

  return <button onClick={handleClick}>클릭하세요</button>;
}
```

:::div{.callout}
JSX에서는 문자열 대신 함수를 이벤트 핸들러로 전달합니다. 또한, 이벤트 객체 'event'를 자동으로 전달받을 수 있습니다.

:::

## 1.4. 이벤트 바인딩

클래스 컴포넌트에서는 메서드를 바인딩해야 하지만, 함수형 컴포넌트에서는 이런 문제가 없습니다.

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };
    // 바인딩이 필요합니다
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState((prevState) => ({
      isToggleOn: !prevState.isToggleOn,
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
```

# 2. Lifting State Up (상태 끌어올리기)

여러 컴포넌트가 동일한 상태를 공유해야 할 때 사용하는 패턴입니다.

```jsx
import React, { useState } from 'react';

function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function Count({ value }) {
  return <div>현재 카운트: {value}</div>;
}

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <div>
      <Count value={count} />
      <Button onClick={increment}>증가</Button>
      <Button onClick={decrement}>감소</Button>
    </div>
  );
}
```

여기서 주목해야 할 패턴의 핵심은 다음과 같습니다.

1. 공통 상태를 부모 컴포넌트에서 관리합니다.
2. 상태 변경 로직도 부모 컴포넌트에 위치합니다.
3. 자식 컴포넌트는 props를 통해 데이터와 함수를 전달받습니다.

# 3. React Hook 기초

Hook은 함수형 컴포넌트에서 React의 특징들을 사용할 수 있게 해주는 함수입니다.

## 3.1. useState

상태를 관리하는 가장 기본적인 Hook입니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>현재 카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

`useState`는 현재 상태값과 이를 업데이트하는 함수를 반환합니다. 함수형 업데이트를 사용하면 이전 상태를 기반으로 안전하게 업데이트할 수 있습니다.

## 3.2. useReducer

useReducer는 복잡한 상태 로직을 다룰 때 사용됩니다.

```jsx
import React, { useReducer } from 'react';

function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>현재 카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>증가</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>감소</button>
    </div>
  );
}
```

useReducer는 현재 상태와 dispatch 함수를 반환합니다. 리듀서 함수를 통해 상태 업데이트 로직을 분리할 수 있어 복잡한 상태 관리에 유용합니다.

## 3.3. useEffect

useEffect는 부수 효과를 처리하는 Hook입니다.

```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then((response) => response.json())
      .then((result) => setData(result));
  }, []); // 빈 의존성 배열: 컴포넌트 마운트 시에만 실행

  return <div>{data ? <p>{data}</p> : <p>로딩 중...</p>}</div>;
}
```

useEffect는 컴포넌트가 렌더링된 후에 비동기적으로 실행됩니다. 데이터 페칭, 구독 설정, 수동적인 DOM 조작 등에 사용됩니다.

## 3.4. useLayoutEffect

useLayoutEffect는 DOM 변경 후 동기적으로 실행되는 Hook입니다.

```jsx
import React, { useLayoutEffect, useRef, useState } from 'react';

function Tooltip() {
  const tooltipRef = useRef();
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const height = tooltipRef.current.offsetHeight;
    setTooltipHeight(height);
  }, []);

  return (
    <div style={{ position: 'relative', marginTop: tooltipHeight }}>
      <div
        ref={tooltipRef}
        style={{
          position: 'absolute',
          top: `-${tooltipHeight}px`,
          background: 'black',
          color: 'white',
          padding: '5px',
        }}
      >
        툴팁 내용
      </div>
      <p>본문 내용</p>
    </div>
  );
}
```

useLayoutEffect는 화면에 렌더링되기 전에 동기적으로 실행되어, 레이아웃 계산이 필요한 경우에 유용합니다. 하지만 성능에 영향을 줄 수 있으므로 필요한 경우에만 사용해야 합니다.

# 4. Hook 사용 시 주의사항

개발자들이 흔히 저지르는 실수를 방지하려면 아래 규칙들을 따라야 합니다. 이러한 규칙들을 따르면 Hook을 효과적으로 사용할 수 있으며, 컴포넌트의 동작을 예측 가능하게 만들 수 있습니다. 또한, 컴포넌트가 렌더링될 때마다 동일한 순서로 Hook이 호출되는 것을 보장할 수 있습니다.

## 4.1. 최상위에서만 Hook 호출

```jsx
// 잘못된 예
if (condition) {
  useEffect(() => {
    // ...
  });
}

// 올바른 예
useEffect(() => {
  if (condition) {
    // ...
  }
}, [condition]);
```

Hook은 항상 React 함수 컴포넌트의 최상위 레벨에서 호출해야 합니다. 조건문, 루프, 중첩 함수 내에서 Hook을 호출하지 마세요.

## 4.2. React 함수 내에서만 Hook 호출

Hook은 React 함수 컴포넌트나 사용자 정의 Hook 내에서만 호출해야 합니다. 일반 JavaScript 함수에서는 Hook을 호출할 수 없습니다.

## 4.3. 의존성 배열 올바르게 지정

```jsx
useEffect(() => {
  console.log(count);
}, [count]); // count가 변경될 때만 효과가 실행됩니다.
```

useEffect나 useCallback, useMemo 등의 Hook을 사용할 때 의존성 배열을 올바르게 지정해야 합니다.

## 4.4. 커스텀 Hook은 `use`로 시작

```jsx
function useCustomHook() {
  // ...
}
```

사용자 정의 Hook을 만들 때는 이름을 "use"로 시작하세요. 이는 React의 규칙을 따르는 것이며, linter가 Hook 규칙 위반을 감지하는 데 도움이 됩니다.

## 4.5. 불필요한 의존성 제거

useCallback, useMemo 등을 사용할 때 불필요한 의존성을 제거하여 성능을 최적화하세요.
