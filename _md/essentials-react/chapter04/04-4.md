---
chapter: Hook
title: useRef
date: 2024-07-12
---

# 1. useRef

useRef 훅은 current라는 하나의 속성을 가지는 자바스크립트 객체를 생성합니다. current 속성을 통해 값에 접근하고 변경할 수 있습니다. 이 값은 컴포넌트의 생명주기 동안 지속되는 가변값으로, 컴포넌트가 화면에 나타나는 순간부터 사라지는 순간까지 값이 유지됩니다. 

useRef의 기본 구조를 살펴보겠습니다.

```jsx
const ref = useRef(initialValue);
```

여기서 initialValue는 ref.current의 초기값이 됩니다. 예를 들어, `const ref = useRef(0);`라고 하면 ref.current의 초기값은 0이 됩니다. 

useRef의 주요 특징을 알아보겠습니다. 

1. useRef의 값은 자유롭게 변경이 가능한 가변성을 가집니다. 불변성을 유지하기 위해 직접 수정하지 않고 새로운 값을 생성해 setState함수로 값을 변경하는 useState와 차이점을 가집니다. 
2. useRef의 값을 변경해도 컴포넌트 렌더링이 발생하지 않습니다. 이는 생성된 ref가 자바스크립트 객체이기 때문에 React가 ref 값의 변화를 감지하지 못하기 때문입니다. 따라서 ref의 값이 변해도 즉시 화면에 반영되지 않습니다. 컴포넌트가 다시 렌더링 되어도 초기화 되지 않아야 하는 값을 저장해야할 때 주로 사용합니다.
3. useRef를 통해 생성한 값은 컴포넌트가 다시 렌더링되어도 변하지 않습니다. 즉, 컴포넌트가 다시 렌더링되어도 값이 초기화되지 않고 기존 값을 유지합니다. 
4. 주로 DOM 요소에 직접 접근하고자 할 때 사용합니다. 이를 통해 컴포넌트의 특정 요소를 조작할 수 있습니다.

:::div{.callout}

useRef와 useState 비교

|  | ref (useRef) | state (useState) |
| --- | --- | --- |
| 값 업데이트 | ref.current를 직접 수정 | setState 함수 사용 |
| 렌더링 발생 | 값 변경 시 리렌더링 발생하지 않음 | 값 변경 시 리렌더링 발생 |
| 값 초기화 | 컴포넌트 생명주기 동안 한 번만 초기화 | 매 렌더링마다 재선언 (값은 유지) |
| 불변성 | 가변적으로 사용 가능 | 불변성 유지 필요 |
| 값 접근 | 항상 최신 값에 접근 가능 | 렌더링 사이클 내에서 최신 값 보장 |
| 비동기 처리 | 동기적으로 즉시 업데이트 | 비동기적으로 업데이트 |

:::

# 2. useRef와 다른 변수들 비교

useRef와 다른 변수들의 차이점을 알기 위해 예시를 살펴보겠습니다.

`App.css`

```css
.counter-container {
  padding: 20px;
}

.value {
  font-size: 20px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 20px;
  border: none;
  border-radius: 4px;
  padding: 10px 15px;
  margin: 5px 0 20px 0;
  cursor: pointer;
}
```

`App.jsx`

```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function Counter() {
    const [count, setCount] = useState(0)
    const [countTwo, setCountTwo] = useState(0)
    const countThree = useRef(0)
    let countFour = 0
    console.log(`화면 렌더링 발생`)

    // 렌더링 발생
    const handleCountUp = (e) => {
        setCount(count + 1)
        // 업데이트 전의 count 값을 보여줍니다.
        console.log(`count: ${count}`)
    }
    
    // 렌더링 발생
    const handleCountUpTwo = (e) => {
        setCountTwo(countTwo + 1)
        // 업데이트 전의 countTwo 값을 보여줍니다.
        console.log(`countTwo: ${countTwo}`)
    }
    
    // 클릭하면 변수의 값 증가, 렌더링 발생 X
    const handleCountUpThree = (e) => {
        countThree.current = countThree.current + 1
        console.log(`countThree.current: ${countThree.current}`)
    }
    
    // 렌더링 발생 X, 다른 state가 변해서 재렌더링 되면 0으로 초기화
    const handleCountUpFour = (e) => {
        countFour = countFour + 1
        console.log(`countFour: ${countFour}`)
    }

    useEffect(() => {
        console.log('count가 감시되고 있습니다.')
        console.log(`감시된 count 변수 : ${count}`)
    }, [count]) // count가 변경되는 것을 감시

    return(
        <div className="counter-container">
            <CounterBox
                label="useState로 생성한 count 변수입니다."
                value={count}
                onClick={handleCountUp}
                buttonText="Up!"
            />
            <CounterBox
                label="useState로 생성한 countTwo 변수입니다."
                value={countTwo}
                onClick={handleCountUpTwo}
                buttonText="Up!"
            />
            <CounterBox
                label="useRef로 생성한 객체의 current 속성 값인 countThree.current입니다."
                value={countThree.current}
                onClick={handleCountUpThree}
                buttonText="Up!"
            />
            <CounterBox
                label="일반 변수인 countFour입니다"
                value={countFour}
                onClick={handleCountUpFour}
                buttonText="Up!"
            />
        </div>
    );
}

function CounterBox({ label, value, onClick, buttonText }) {
    return (
        <div>
            <div className="text">{label}</div>
            <div className="value">{value}</div>
            <button onClick={onClick}>{buttonText}</button>
        </div>
    );
}

function App() {
    return (
        <div className="App">
            <Counter />
        </div>
    );
}

export default App;
```


:::div{.beforeAfter}
| 화면 | 콘솔창 |
| ------------------------------------------ | ------------------------------------------ |
| ![useState, useRef, 일반 변수의 값을 증가시키는 4개의 버튼이 보이는 화면](/images/basecamp-react/chapter04-2/chapter04-2-1.png) | ![버튼을 눌렀을 때 콘솔창에 출력되는 메세지](/images/basecamp-react/chapter04-2/chapter04-2-2.png) |
:::

화면과 콘솔창을 열어 버튼을 누를 때마다 어떤 일이 일어나는지 확인해보세요.

코드를 자세하게 살펴보겠습니다. count와 countTwo는 useState로 생성한 변수입니다. 값이 변경되면 컴포넌트가 리렌더링되고, 변경된 값은 화면에 바로 반영됩니다. count 변수는 useEffect가 값이 변하는지 계속 감시하고 있어, count의 값이 변하면 useEffect 함수가 실행됩니다.

`count` 값을 증가시키는 첫 번째 버튼을 눌렀을 때 콘솔창을 확인하여 자세한 동작 순서를 알아보겠습니다. handleCountUp 함수가 실행되면서 업데이트되기 전의 count 값이 출력됩니다. 렌더링이 발생하고 값이 업데이트되고 useEffect 함수가 실행된 것을 확인할 수 있습니다.

`countTwo` 변수의 값을 증가시키는 버튼을 클릭하면 첫 번째 버튼 클릭 때와 동일하게 변수의 값과 화면 렌더링 문구가 콘솔창에 출력됩니다. 하지만 useEffect가 감시하는 변수가 아니기 때문에 useEffect의 함수가 실행되지는 않습니다.

useRef가 관리하는 `countThree`객체의 countThree.current 속성 값을 증가시키는 세 번째 버튼을 클릭해보세요. 버튼을 클릭하면 콘솔창에 1씩 증가하는 countThree.current 값을 확인할 수 있지만, 화면 속 countThree.current의 값은 변하지 않습니다. 이는 useRef의 ref 값이 변해도 컴포넌트 렌더링이 발생하지 않기 때문에 바뀐 countThree.current의 값이 화면에 반영되지 않는 것입니다. 첫 번째나 두 번째 버튼을 누르면 useState로 관리하는 변수의 값이 바뀌어 렌더링이 발생하게 되는데, 이때 바뀐 countThree.current의 값이 화면에 반영됩니다. 리렌더링이 발생해도 countThree.current의 값이 초기값으로 바뀌지 않습니다.

일반 변수인 `countFour`의 값을 증가시키는 네 번째 버튼을 클릭하면 콘솔창에 1씩 증가하는 countFour의 값을 확인할 수 있지만, 바뀐 값이 화면에 반영되지 않습니다. 일반 변수이기 때문에 값이 변해도 렌더링이 발생하지 않기 때문입니다. 리렌더링이 발생하도록 하는 첫 번째나 두 번째 버튼을 누르면 렌더링이 발생하지만, countFour의 값은 여전히 0입니다. 이는 렌더링이 발생할 때마다 countFour 변수를 0으로 초기화하는 함수가 실행되기 때문입니다. 따라서 countFour는 항상 0으로 표시됩니다.

:::div{.callout}
**count와 countTwo의 값이 왜 증가한 값이 아닌 이전 값이 출력될까요?**
setCountTwo((prevCountTwo) => prevCountTwo + 1) 함수 이후에 console.log(\`countTwo: ${countTwo}\`) 함수가 실행되는데 콘솔창에는 바뀌기 전의 countTwo 값이 출력됩니다. 이는 상태 업데이트가 비동기적으로 발생하기 때문입니다. useRef의 ref.current는 렌더링 주기와 상관없이 항상 최신 값에 접근하기 때문에 이러한 문제가 발생하지 않습니다. 업데이트된 값을 출력하고 싶다면 `useEffect`를 사용하거나 useState의 상태 업데이트 함수를 `함수형 업데이트`로 사용할 수 있습니다.
함수형 업데이트는 setCount(prevCount => prevCount + 1)과 같은 방식으로 상태 업데이트 함수를 사용하는 것입니다. setCountTwo 함수를 함수형 업데이트 방식으로 바꾸어 봅시다.

```jsx
const handleCountUpTwo = (e) => {
  setCountTwo(prevCountTwo => {
    console.log(`countTwo: ${prevCountTwo + 1}`);
    return prevCountTwo + 1;
  })
}
```

두 번째 버튼을 눌러 콘솔창을 확인해보세요. 함수형 업데이트를 사용하면 항상 가장 최신의 상태 값에 접근하기 때문에 최신 값인 prevCountTwo에 1을 더하여 업데이트된 countTwo 값으로 출력됩니다.

useEffect를 사용해서 업데이트된 countTwo 값을 출력하는 코드를 살펴보겠습니다

```jsx
useEffect(() => {
  console.log('countTwo가 감시되고 있습니다.')
  console.log(`감시된 변수 : ${countTwo}`)
}, [countTwo]) // countTwo가 변경되는 것을 감시
```

setCountTwo 함수로 인해 상태 업데이트와 리렌더링이 발생한 후에 countTwo 변수를 감시하고 있던 useEffect의 함수가 실행되기 때문에 업데이트된 countTwo의 값을 출력하게 됩니다.

:::

# 3. useRef 사용 예시

useRef는 주로 DOM 요소에 직접 접근해야 할 때와 렌더링과 무관한 값을 저장해야 할 때, 이전 렌더링 값을 기억해야 하는 등의 상황에서 사용됩니다.

## 3.1 useRef로 컴포넌트의 특정 요소에 직접 접근하고 싶을 때

useRef를 사용하여 DOM 요소에 직접 접근하는 예시를 살펴보겠습니다. 

### 3.1.1 컴포넌트의 특정 요소에 포커스 지정

useRef를 사용해 컴포넌트의 특정 요소에 직접 접근하여 포커스를 주는 코드입니다. 이 예시에서는 페이지에 접속하면 자동으로 이메일 입력창에 포커스를 줍니다.

`App.css`

```css
.sign-up-container {
  padding: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
}

input {
  border: 1px solid black;
  border-radius: 5px;
  padding: 8px;
  margin-bottom: 10px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 15px;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  margin: 10px 0 20px 0;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}
```

`App.jsx`

```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function SignUp() {
    const formRef = useRef(null)
    const emailRef = useRef(null)
    const passwordRef = useRef(null)

    function signUp(e) {
        e.preventDefault()
        console.log('회원가입 완료')
        console.log(formRef)
        console.log(emailRef)
        console.log(passwordRef)
        formRef.current.reset()
    }

    useEffect(() => {
        emailRef.current.focus()
    }, [])

    return (
        <div className="sign-up-container">
            <form ref={formRef} onSubmit={signUp}>
                <h1>회원가입</h1>
                <div>
                    <label htmlFor="email">이메일</label>
                    <input
                        type="email"
                        id="email"
                        ref={emailRef}
                        required
                    />
                </div>
                <div>
                    <label htmlFor="password">비밀번호</label>
                    <input
                        type="password"
                        id="password"
                        ref={passwordRef}
                        autoComplete="off"
                        required
                    />
                </div>
                <button type="submit">회원가입</button>
            </form>
        </div>
    )
}

function App() {
    return (
        <div className="App">
            <SignUp />
        </div>
    );
}

export default App;
```

`localhost:3000`에 접근하면 회원가입 화면이 나타납니다. 이메일 입력창에 자동으로 포커스가 되어 있는 것을 확인할 수 있습니다.

::img{width="300" alt="요소에 포커스 지정하기 위한 회원가입 화면" src="/images/basecamp-react/chapter04-2/chapter04-2-3.png"}

코드를 자세히 살펴보겠습니다. 먼저 formRef와 emailRef, passwordRef 3개의 useRef를 생성합니다.

```jsx
const formRef = useRef(null)
const emailRef = useRef(null)
const passwordRef = useRef(null)
```

formRef는 form 요소에, emailRef는 email input 요소에, passwordRef는 password input 요소에 직접 접근할 수 있도록 해당 태그에 ref props로 전달합니다.

```jsx
<form ref={formRef} onSubmit={signUp}>
    ...
    <input type="email" id="email" ref={emailRef} required />
    ...
    <input type="password" id="password" ref={passwordRef} autoComplete="off" required />
    ...
</form>
```

이메일과 비밀번호를 입력하고 회원가입 버튼을 누르면 콘솔에 ref 객체들이 출력됩니다. formRef, emailRef, passwordRef는 ref 객체입니다.

![formRef, emailRef, passwordRef 객체 출력](/images/basecamp-react/chapter04-2/chapter04-2-4.png)

`ref.current`는 실제 DOM 요소를 가리킵니다. 이를 통해 해당 요소의 모든 속성과 메서드에 접근할 수 있습니다. 예를 들면 요소의 스타일을 변경하거나 포커스를 주고 싶을 때 등 사용합니다. 

`emailRef.current`는 email input 요소를 직접 가리킵니다. 페이지에 처음 접속하면 useEffect 함수가 실행됩니다. 이 함수 내에서 `emailRef.current.focus()`를 호출하여 이메일 입력 필드에 자동으로 포커스를 줍니다. 이렇게 함으로써 사용자가 페이지에 접속하자마자 이메일을 입력할 수 있는 상태가 됩니다.

`formRef.current`는 form 요소 전체를 참조합니다. 회원가입 버튼을 클릭하면 `formRef.current.reset()`이 실행됩니다. 이 메서드는 form 내의 모든 입력 필드를 초기 상태로 되돌립니다. 따라서 사용자가 입력했던 이메일과 비밀번호가 모두 지워집니다.

### 3.1.2 컴포넌트의 특정 요소의 값 가져오기

useRef를 사용하여 input 요소에 입력된 값을 가져와 화면에 보여주는 예시를 살펴보겠습니다. 입력한 이메일 주소로 환영 메세지를 표시합니다.

`App.jsx`

```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function SignUp() {
    const [welcomeMessage, setWelcomeMessage] = useState('')
    const formRef = useRef(null)
    const emailRef = useRef(null)
    const passwordRef = useRef(null)

    function signUp(e) {
        e.preventDefault()
        console.log(emailRef.current.value)
        console.log(passwordRef.current.value)
        setWelcomeMessage(`${emailRef.current.value}님 환영합니다!`)
        formRef.current.reset()
    }

    useEffect(() => {
        emailRef.current.focus()
    }, [])

    return (
        <div className="sign-up-container">
            <form ref={formRef} onSubmit={signUp}>
                <h1>회원가입</h1>
                <div>
                    <label htmlFor="email">이메일</label>
                    <input
                        type="email"
                        id="email"
                        ref={emailRef}
                        required
                    />
                </div>
                <div>
                    <label htmlFor="password">비밀번호</label>
                    <input
                        type="password"
                        id="password"
                        ref={passwordRef}
                        autoComplete="off"
                        required
                    />
                </div>
                <button type="submit">회원가입</button>
            </form>
            {welcomeMessage && <p>{welcomeMessage}</p>}
        </div>
    )
}

function App() {
    return (
        <div className="App">
            <SignUp />
        </div>
    );
}

export default App;
```

회원가입 환영 메시지를 담을 `welcomeMessage` 상태를 useState로 선언합니다. 이메일과 비밀번호를 입력하고 회원가입 버튼을 누르면 `signUp` 함수가 실행됩니다. signUp 함수가 실행되면 `emailRef.current.value`를 사용하여 이메일 입력창의 값을 가져옵니다. 이렇게 가져온 값으로 `setWelcomeMessage` 함수를 호출하여 환영 메시지를 설정합니다. 이 과정에서 상태 값이 변경되어 리렌더링이 발생하고, 결과적으로 환영 메시지가 화면에 표시됩니다.

환영 메시지의 조건부 렌더링을 위해 자바스크립트의 && (논리 AND) 연산자를 사용합니다. `welcomeMessage && <p>{welcomeMessage}</p>` 구문에서, welcomeMessage가 빈 문자열일 때는 아무것도 렌더링되지 않고, 값이 있을 때만 환영 메시지가 화면에 표시됩니다. 이는 && 연산자가 왼쪽에서 오른쪽으로 평가되며, falsy 값을 만나면 해당 값을 반환하고, 모든 값이 truthy일 때 마지막 값을 반환하는 특성을 이용한 것입니다. 

:::div{.callout}
**자바스크립트의 && 연산자에 대해 알고 싶다면 참고 바랍니다.**
::a[자바스크립트 && 연산자]{class='btn-link' href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Logical_AND" target="\_blank"}

:::

`ref.current`를 통해 DOM 요소에 직접 접근하여 다양한 조작을 할 수 있습니다. 하지만 React의 선언적 프로그래밍 방식과 상충될 수 있으므로, 꼭 필요한 경우에만 사용하는 것이 좋습니다.
예를 들어, 입력 필드의 값을 변경하거나 가져오는 작업은 보통 React의 state를 통해 관리하는 것이 더 좋습니다. 하지만 포커스를 주거나, 스크롤 위치를 조정하는 등의 작업은 useRef를 통한 직접 조작이 필요할 수 있습니다.
React에서 ref를 사용할 때는 항상 성능과 유지보수성을 고려해야 합니다. 가능한 한 React의 데이터 흐름 원칙을 따르고, **DOM 조작이 꼭 필요한 경우에만 ref를 사용하는 것이 좋습니다.**