---
chapter: 03장 타입
title: 03.7 None 자료형
date: 2024-01-29
---

# 1. None 자료형이란?

앞에서 우리는 변수를 포스트잇에 비유했습니다. 만약 ‘양말 바구니’에 ‘양말 바구니’라는 포스트잇을 붙였는데 이 바구니에 아무것도 없다면 비어있다는 것은 어떻게 표현할까요? 물론 양말은 갯수로 표현할 수 있기에 0으로 표현할 수 있겠지만 이처럼 숫자로 표현되지 않는 것들도 있습니다. 예를 들어 ‘글자 바구니’를 만들어 거기에 ‘1’, ‘0’, ‘a’, ‘b’를 넣는다면 비어있다는 것을 0으로 표현할 수 없죠. 0이라는 글자가 있는 것일 수도 있으니까요.

이처럼 ‘비어 있다’, ‘아무것도 없다’, ‘정보가 없다’를 표현하고 싶을 때 사용하는 것이 None입니다. 아래처럼 표현할 수 있습니다.

None 자료형은 가질 수 있는 값이 None이 유일합니다.

```python
양말상자 = None
```

:::div{.callout}
print 챕터에서 언급된 것 처럼 None은 print가 아닌 마지막 줄 출력인 경우 출력이 되지 않습니다.
:::

## 1.1 None 자료형의 연산

아래와 같이 None 타입에 무언가를 더하거나 빼거나, 곱하거나 나누는 연산은 에러를 일으킵니다. None과 None을 더하면 None이 나올 것 같지만 이러한 연산 자체를 허락하지 않습니다. 또한 True나 False처럼 값에 다른 값을 할당하는 것도 허락하지 않습니다.

```python
None + 5
None + None
None = 10
```

이러한 연산이 가능하다, 가능하지 않다는 어떻게 확인할 수 있을까요? 이런 연산이 가능하게 하는 것은 dir을 통해 확인할 수 있습니다.

```python
dir(None) #매직메서드, 메서드확인
```

```python
['__bool__',
 '__class__',
 '__delattr__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__init_subclass__',
 '__le__',
 '__lt__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__']
```

코드가 길지 않기 때문에 전문을 가지고 왔습니다. 앞에서 언급한 것처럼 언더바가 2개있는 것을 매직 메서드라고 하는데요. 여기에는 덧셈을 가능하게 하는 코드가 정의되어 있지 않습니다. 덧셈을 가능하게 하는 매직 메서드는 `__add__` 입니다. 이처럼 나중에는 `dir`만 확인해보더라도 이러한 자료형이 무엇을 뜻하는지, 무엇을 할 수 있는지를 대략적이나마 알 수 있게 됩니다.

## 1.2 None의 값은 항상 유일

None의 값은 항상 유일한 주소값을 가리킵니다. 여기서 id는 해당 변수가 가리키고 있는 주소를 나타냅니다.

```python
x = None
y = None
print(id(x), id(y))
```

None을 확인할 때에는 아래처럼 등호 2개를 사용하는 것보다는 메모리 주소를 직접 확인하는 is 연산자를 사용하기를 권합니다. 이는 is None이 속도가 더 빠른 경우도 있지만 `==` 연산이 특수한 경우 우리가 생각하는 것과는 다르게 작동할 수 있기 때문입니다. 또한 파이썬 코딩 권고사항인 PEP8에서도 None은 is None을 권고하고 있습니다.

```python
x = None

print(x == None)    # True, 하지만 이 방식은 권장되지 않습니다.
print(x is None)    # True, 이 방식을 사용하여 None을 확인하는 것이 좋습니다.
```

# 2. 나아가기

앞에서 말한 우리가 생각하는 것과 다르게 동작하는 경우는 어떤 경우가 있을까요? 아래와 같이 예를 들 수 있습니다. 아직 배우지 않은 개념이 많이 나오지만, ‘내가 의도하지 않은 오류’가 어떤 것인지 알려드리기 위해 이 예제를 넣었습니다.

```python
class 캐릭터:
    # ... 체력, 마력, 공경력, 방어력을 정의하는 수많은 코드 ...
    def __eq__(self, other):
        return True

주인공 = 캐릭터()
보스 = 캐릭터()

print(주인공 == None)
print(주인공 == 100)
print(주인공 == 보스)
print(주인공 is None)
```

매직 메서드 `__eq__`는 비교연산이 가능하게 해주는 것입니다. 위 예제에서 알아두어야 할 것은 이 메직 매서드를 통하여 비교 연산을 할 경우 모두 `True`로 출력하게 했다는 것입니다. 하지만 실제로 주인공이나 보스가 None, 즉 비어있는 상태는 아니라는 것이죠. 따라서 등호보다는 is연산을 통해 None을 확인하세요.

## 부가설명

Python에서 **`__eq__`** 메서드는 객체 간의 동등성을 비교할 때 사용되는 특별한 메서드입니다. 이 메서드를 사용자 정의 클래스에서 오버라이드(재정의)할 때, 객체간 비교를 어떻게 처리할지 결정할 수 있습니다.
위 예제에서 **`캐릭터`** 클래스는 **`__eq__`** 메서드를 오버라이드해 모든 비교가 무조건 **`True`** 로 평가되게 만들었습니다. 즉, 이 클래스의 인스턴스는 어떤 것과 비교해도 **`True`** 를 반환합니다. 이는 정상적인 동작이 아니며, 실제 프로그래밍에서는 바람직하지 않은 방식입니다.
좀 더 쉬운 예시를 들어보겠습니다:

```python
class 항상동일:
    def __eq__(self, other):
        return True

객체1 = 항상동일()
객체2 = 항상동일()

print(객체1 == 객체2)  # True
print(객체1 == 123)    # True
print(객체1 == None)   # True

```

위 코드에서 **`항상동일`** 클래스의 인스턴스는 어떤 다른 값이나 객체와 비교해도 항상 **`True`** 를 반환합니다. 이것은 일반적으로 예상하지 않는 동작입니다. 보통 객체 비교는 객체의 실제 값이나 상태를 기준으로 이루어져야 합니다.
**`None`** 과의 비교에서도 **`==`** 대신 **`is`** 를 사용하는 것이 좋습니다. **`is`** 는 객체의 정체성(identity)을 비교합니다. **`None`** 은 유일한 값이므로, **`x is None`** 은 **`x`** 가 정말로 **`None`** 인지를 정확하게 비교해 줍니다.
이렇게 **`__eq__`** 메서드를 잘못 사용하면 예상치 못한 오류나 혼동을 일으킬 수 있으므로 주의가 필요합니다.
위의 예제에서 **`==`** 연산자를 **`is`** 로 변경하면 모든 비교가 **`False`** 로 평가됩니다. 이유는 다음과 같습니다:

- **`is`** 연산자는 두 객체가 메모리 상에서 동일한 위치(즉, 동일한 객체)인지를 검사합니다.
- **`==`** 연산자는 두 객체의 값이 동등한지를 비교합니다. **`__eq__`** 메서드는 이 동등성 비교의 동작을 정의합니다.
- **`is None`** 을 사용하면 객체가 실제로 **`None`** 인지 확인할 수 있습니다. **`None`** 은 파이썬에서 하나의 유일한 객체이기 때문에, 이 방식으로 정확한 비교가 가능합니다.
  따라서, 위의 예제에서 **`==`** 연산자를 **`is`** 로 변경하면, **`객체1`** 과 **`객체2`** 가 서로 다른 객체이며 **`객체1`** 이 **`None`** 또는 **`123`** 이 아니므로, 모든 비교가 **`False`** 로 평가됩니다. 예를 들어:

```python
class 항상동일:
    def __eq__(self, other):
        return True

객체1 = 항상동일()
객체2 = 항상동일()

print(객체1 is 객체2)  # False
print(객체1 is 123)    # False
print(객체1 is None)   # False
```

이 코드에서는 **`객체1`** 과 **`객체2`** 가 서로 다른 인스턴스이므로, 메모리 상에서 다른 위치에 존재합니다. 따라서 **`is`** 연산자로 비교했을 때 모두 **`False`** 를 반환합니다.

## 쉬운설명

### **간단한 예시: 자동차 클래스**

먼저, 간단한 자동차 클래스를 만들어 보겠습니다. 이 클래스에는 자동차의 모델을 나타내는 **`model`** 속성이 있습니다.

```python
pythonCopy code
class Car:
    def __init__(self, model):
        self.model = model

    def __eq__(self, other):
        return self.model == other.model

```

여기서 **`__init__`** 메서드는 객체를 초기화할 때 사용되며, **`__eq__`** 메서드는 두 자동차 객체가 같은 모델인지 비교할 때 사용됩니다.

### **객체 생성 및 비교**

이제 두 자동차 객체를 생성해 보겠습니다.

```python
pythonCopy code
car1 = Car("Toyota")
car2 = Car("Toyota")
car3 = Car("Honda")

```

**`car1`** 과 **`car2`** 는 같은 모델("Toyota")을 가지고 있고, **`car3`** 는 다른 모델("Honda")을 가집니다.

### **`==` 연산자와 `is` 연산자 사용**

이제 이 객체들을 비교해 보겠습니다.

```python
pythonCopy code
print(car1 == car2)  # True, 같은 모델이기 때문에
print(car1 == car3)  # False, 다른 모델이기 때문에

```

여기서 **`==`** 연산자는 **`__eq__`** 메서드를 호출하여 두 객체의 모델이 같은지 비교합니다.
이제 **`is`** 연산자를 사용해 봅시다.

```python
pythonCopy code
print(car1 is car2)  # False, car1과 car2는 다른 객체입니다.

```

**`car1`** 과 **`car2`** 는 같은 모델을 가지고 있지만, 메모리 상에서는 서로 다른 객체입니다. 따라서 **`car1 is car2`** 는 **`False`** 를 반환합니다.

### **결론**

- **`==`** 연산자: 두 객체의 값을 비교합니다. 여기서는 **`__eq__`** 메서드를 통해 모델 이름을 비교합니다.
- **`is`** 연산자: 두 객체의 식별자(메모리 주소)를 비교합니다. 같은 객체인지를 판단합니다.

### **객체의 메모리 주소와 ID**

- 파이썬에서 객체는 메모리 상에 생성될 때 고유한 주소를 할당받습니다. 이 주소는 객체의 식별자로서, 파이썬의 내장 함수 **`id()`** 를 통해 확인할 수 있습니다.
- 동일한 클래스로부터 생성된 서로 다른 객체들은 각각 고유한 메모리 주소(즉, 고유한 ID)를 가집니다.

### **예제에서의 객체 생성과 ID**

- 예제에서 **`Car("Toyota")`** 로 생성된 **`car1`** 과 **`car2`** 는 두 개의 서로 다른 객체입니다.
- 각각의 **`Car`** 객체는 **`__init__`** 메서드 호출을 통해 생성되며, 이때 고유한 메모리 주소가 할당됩니다.
- 결과적으로, **`car1`** 과 **`car2`** 는 동일한 속성 값을 가지더라도 서로 다른 메모리 주소에 위치하는 별개의 객체입니다.
- **`id(car1)`** 과 **`id(car2)`** 를 비교하면, 이 두 객체가 서로 다른 주소(즉, 다른 ID)를 가지고 있음을 확인할 수 있습니다.

### **객체 비교**

- 객체의 동등성 비교(**`==`** )는 두 객체의 내용이 같은지 여부를 판단합니다. 예를 들어, 두 **`Car`** 객체의 **`model`** 이 같다면, **`car1 == car2`** 는 **`True`** 를 반환합니다.
- 객체의 동일성 비교(**`is`** )는 두 객체가 메모리 상에서 동일한 객체인지를 판단합니다. **`car1 is car2`** 는 두 객체가 서로 다른 메모리 주소를 가지고 있기 때문에 **`False`** 를 반환합니다.
