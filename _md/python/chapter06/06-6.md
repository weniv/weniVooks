---
chapter: 06장 함수
title: 06.6 built-in function
date: 2024-01-29
---

# 1. 빌트인 함수(built-in function)란?

**Built-in functions** 또는 **내장 함수**는 파이썬 언어에 기본적으로 포함되어 있는 함수들입니다. 이러한 함수들은 추가적인 코드를 작성하지 않고도 사용할 수 있습니다. 파이썬의 내장 함수들은 개발자가 더 효율적으로 코드를 작성할 수 있도록 도와줍니다.

# 2. 빌트인 함수(built-in function) 종류

공식문서([https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html))에 있는 빌트인 함수 중 코딩할 때 자주 등장하며 실무에서도 비중있게 다뤄야 하는 빌트인 함수를 선별해 보았습니다. 다만 실무자라면 모든 빌트인 함수를 한번씩은 작동해보는 것을 권합니다.

이 챕터는 모두 읽지 않고 아래 빌트인 함수에서 모르는 것이 있는지 체크해보고, 그 함수로 가서 해당 목차를 읽어보기 바랍니다.

```
# 요소 전체의 True, False 판별
all
any

# 숫자를 문자로 바꾸거나 문자를 숫자로 바꾸는 함수
chr
ord

# 함수와 순회할 수 있는 객체의 연산
map
filter

# 순회할 수 있는 객체의 묶음
zip

# 형식 변환
format

# 길이 반환
len

# 큰 값, 작은 값, 다 더한 값
max
min
sum

# 문자열, 대표 문자열, 문자열 출력
str
repr
print

# 순회할 수 있는 객체
enumerate
range

# 역순과 정렬
reversed
sorted
```

## 2.1 all, any

`all()` 함수는 iterable(반복 가능한) 객체(예: 리스트, 튜플, 문자열 등)를 인수로 받아, 그 안에 있는 모든 요소가 `True`로 평가되면 `True`를 반환하고, 그렇지 않으면 `False`를 반환합니다.

```python
# 모두 다 True여야 True 반환
all([True, True, True]) # 출력: True
all([True, True, False]) # 출력: False
all([1, 1, 1, 0]) # 출력: False
all([1, 0, 1, 1]) # 출력: False
all([1, 100, 10, -1]) # 출력: True
```

`any()` 함수도 iterable 객체를 인수로 받아, 그 안에 있는 어떤 요소라도 `True`로 평가되면 `True`를 반환하고, 그렇지 않으면 `False`를 반환합니다.

```python
# 하나라도 True이면 True이다.
any([True, False, False]) # 출력: True
any([False, False, False]) # 출력: False
```

이 함수들은 주어진 조건을 만족하는 요소가 있는지 또는 모든 요소가 조건을 만족하는지를 검사할 때 유용하게 사용됩니다.

## 2.2 chr, ord

`chr()` 함수는 정수를 인수로 받아 그에 해당하는 유니코드 문자를 반환합니다.

```python
# 10진수로 유니코드표에서 찾아 대응되는 값을 줍니다.
chr(65) # 출력: 'A'
chr(97) # 출력: 'a'
chr(54616) # 출력: '하'
```

`ord()` 함수는 문자를 인수로 받아 그 문자의 유니코드(또는 ASCII 코드) 값을 반환합니다.

```python
# 문자를 입력하면 유니코드에서 숫자로 출력합니다.
ord('a') # 출력: 97
ord('하') # 출력: 54616
```

int 함수도 ord와 같은 기능을 합니다. 다음과 같이 활용하면 '하' 문자의 유니코드 값을 나타냅니다. `int` 함수를 사용하여 이 값을 10진수로 변환하면 54616이 됩니다.

```python
# 유니코드 표에서 값 확인
int('D558', 16) # 출력: 54616
```

이러한 방법을 통해 문자와 유니코드 사이의 변환을 쉽게 수행할 수 있으며, 특히 문자 데이터를 처리하거나 문자 인코딩/디코딩 작업을 수행할 때 유용하게 사용됩니다.

## 2.3 map

`map()` 함수는 기존의 리스트(또는 튜플)의 모든 요소에 특정 함수를 적용한 결과를 map 객체 형태로 반환하는 함수입니다. map 객체는 다시 list()를 이용해 리스트 형태로 변환할 수 있습니다.

map 함수의 기본 구조는 다음과 같습니다.

```python
map(함수, 리스트 혹은 튜플)
```

동일한 작업을 수행하는 2개의 예시를 보며 설명드리도록 하겠습니다. 리스트 `[1, 2, 3, 4]`의 각 요소를 제곱하는 작업을 수행했습니다.

```python-exec
# 첫번째 방법
def 제곱(x):
    return x ** 2
list(map(제곱, [1, 2, 3, 4])) # 출력: [1, 4, 9, 16]
```

첫 번째 방법에서는 `제곱`이라는 일반 함수를 정의하고, 이를 `map()` 함수의 첫 번째 인자로 전달했습니다.

```python-exec
# 두번째 방법
list(map(lambda x : x ** 2, [1, 2, 3, 4])) # 출력: [1, 4, 9, 16]
```

두 번째 방법에서는 람다 함수를 직접 `map()` 함수의 첫 번째 인자로 전달하여 코드를 더 간결하게 작성했습니다.

두 방법 모두 `map()` 함수를 이용해 리스트의 각 요소에 함수를 적용한 후, 결과를 리스트 형태로 받아왔습니다.

`map()` 함수는 이처럼 리스트의 각 요소에 특정 함수를 일괄적으로 적용할 때 매우 유용하게 사용됩니다.

## 2.4 filter

`filter()` 함수는 순회할 수 있는 객체의 요소 중 특정 조건을 만족하는 요소만을 선택하여 반환합니다. 반환 값은 filter 객체 형태로 제공되며, 이를 다시 list()를 이용해 리스트 형태로 변환할 수 있습니다.

기본적인 형태는 아래와 같습니다.

```python
filter(조건 함수, 리스트 또는 튜플)
```

조건 함수는 각 요소를 입력으로 받아 True 또는 False 값을 반환합니다. `filter()` 함수는 True를 반환하는 요소만 선택하여 결과로 반환합니다.

해당 예제에서는 0부터 99까지의 숫자 중에서 50보다 큰 숫자만을 선택하여 리스트로 반환하도록 했습니다.

```python-exec
list(filter(lambda x : x > 50, range(100)))
```

```python
# 출력
[51,
 52,
 53,
 .
 .
 .
  ]
```

`filter()` 함수는 주어진 조건에 맞는 요소만을 선택할 때 사용되며, 람다 함수와 함께 사용하면 코드를 간결하게 작성할 수 있습니다.

## 2.5 zip

`zip()` 함수는 여러 개의 순회할 수 있는 객체의 요소를 묶어서 반환합니다. 다만 메모리의 효율을 위해 형변환이나 직접 순회를 하기 전까지는 메모리 주소로만 반환합니다.

```python
zip(순회할 수 있는 객체1, 순회할 수 있는 객체2...)
```

다음 예제들을 통해 배워봅시다.

```python-exec
zip('ab', '12') # 출력: <zip at 0x7b9d83c6e440>
```

위와 같이 사용하면 메모리 주소를 반환합니다. 순회를 하거나 형변환을 하면 아래와 같이 출력 값을 반환합니다.

```python-execn
list(zip('ab', '12')) # 출력: [('a', '1'), ('b', '2')]
```

'ab' 문자열과 '12' 문자열의 각 문자들이 순서대로 튜플로 묶여 리스트로 반환된 것을 확인할 수 있습니다. 리스트로 형변환 했기 때문에 리스트로 반환된 것이고, 그 안에 있는 값은 튜플로 묶입니다.

이번에는 세 개의 순회할 수 있는 객체를 넣어 수행해보도록 하겠습니다.

```python-exec
list(zip('ab', '12', [10, 20])) # 출력: [('a', '1', 10), ('b', '2', 20)]
```

각 요소가 순서대로 튜플로 묶여 리스트로 반환된 것을 확인할 수 있습니다.

길이가 다른 순회할 수 있는 객체가 오면 길이가 가장 짧은 것을 기준으로 출력합니다.

```python-exec
list(zip('abc', '1234567', [10, 20, 30]))
# 출력 : [('a', '1', 10), ('b', '2', 20), ('c', '3', 30)]
```

여기서는 'abc' 문자열이 가장 짧으므로 세 개의 튜플만 생성됩니다.

zip은 다양한 방식으로 응용될 수 있습니다. 예를 들어 x좌표와 y좌표의 묶음이 있다 한다면 x좌표와 y좌표를 묶어 반환할 수 있습니다.

```python-exec
x = [1, 2, 3]
y = [1, 4, 9]
list(zip(x, y)) # 출력: [(1, 1), (2, 4), (3, 9)]
```

또한 인접한 2개의 수나 인접한 3개의 수 등을 만들 때에도 유용하게 사용할 수 있습니다.

```python-exec
x = [2, 4, 8, 16, 32, 64, 128]
list(zip(x, x[1:], x[2:]))
```

```python
# 출력
[(2, 4, 8), (4, 8, 16), (8, 16, 32), (16, 32, 64), (32, 64, 128)]
```

위 코드는 x와 x의 1번째부터 슬라이싱한 값, x의 2번째부터 슬라이싱한 값들이 각각 zip으로 묶입니다. 여기서 주의깊게 보아야 할 점은 x는 32까지만 묶였다는 점입니다. 왜냐하면 길이가 가장 짧은 x[2:] 기준으로 묶였기 때문입니다.

## 2.6 format

`format()` 함수는 특정 값을 지정된 형식으로 변환하여 문자열로 반환하는 함수입니다. 만약 서식 지정자를 설정하지 않으면 str()한 것과 동일한 결과를 얻을 수 있습니다.

```python
format(값, '서식 지정자(format_spec)')
```

다음 예시를 통해 format을 알아봅시다. 이 예제에서는 10억을 의미하는 숫자 10000을 천 단위로 콤마(,)를 추가하여 문자열로 표현하고 있습니다. 결과적으로 숫자 10000은 '10,000'라는 문자열로 변환되어 반환됩니다.

```python-exec
format(10000, ',')
```

가장 많이 사용되는 것이 콤마이고 소숫점 표현이나 공백 표현도 가능합니다.

```python-exec
print(format(123.4567, '.2f')) # 출력: 123.46
print(format('Hello', '^9')) # 출력: '  Hello  '
```

첫 번째 예제는 소숫점 2자리까지 출력한 것이고, 두 번째 예제는 9자리에 중앙 정렬(`^`)하라는 것입니다.

더 많은 서식 지정자에 대해서는 부록에서 살펴봅니다.

## 2.7 len

`len()` 함수는 주어진 시퀀스(문자열, 리스트, 튜플 등) 또는 컬렉션(딕셔너리, 세트 등)의 길이(요소의 개수)를 반환합니다.

```python
len(길이를 계산하려는 객체)
```

아래 예제에서는 문자열 `'hello world'`의 길이를 구하고 있습니다. 문자열 `'hello world'`는 11개의 문자로 이루어져 있으며, 이 중 공백 문자(' ')도 길이에 포함됩니다. 따라서 `len('hello world')`는 11을 반환합니다.

```python-exec
len('hello world')
```

`len()` 함수는 문자열의 길이 외에도 리스트의 길이, 딕셔너리의 키-값 쌍의 개수 등을 구하는 데 사용할 수 있으며, 일반적으로 어떤 시퀀스나 컬렉션의 요소 개수를 알아내고자 할 때 사용됩니다. 다만 len가 모든 객체의 길이를 반환하지 않습니다. 아래와 같은 코드는 에러입니다.

```python-exec
len(zip('ab', '12')) # error
```

## 2.8 max, min, sum

`max`, `min`, `sum` 등의 내장 함수를 사용하여 최댓값, 최솟값, 모든 요소의 합을 구할 수 있습니다. 예제를 통해 살펴보도록 하겠습니다.

### 2.8.1 max, min

가장 먼저 max 함수를 살펴보도록 하겠습니다. `max` 함수는 주어진 순회할 수 있는 객체의 최댓값을 반환합니다.

기본적인 형태는 아래와 같습니다.

```python
max(순회할 수 있는 객체, 함수(key), 초깃값(default))
```

일반적으로는 순회할 수 있는 객체만 넣어 아래와 같은 형태로 사용이 됩니다.

```python
max([1, 2, 3, 4, 5]) # 출력 : 5
max([(1, 2), (3, 101), (1, 20), (3, 100)]) # 출력 : (3,101)
max(['hello', 'world', 'world1']) # 출력 : world1
```

첫 번째 예시에서는 리스트를 순회돌며 가장 큰 값인 5를 출력합니다.

두 번째 예제에서는 리스트를 순회돌며 튜플의 가장 처음에 있는 값인 1, 3, 1, 3을 기준으로 가장 큰 값을 선정합니다. 그렇게 되면 (3, 101), (3, 100)이 가장 큰 값이 됩니다. 여기서 뒤의 값을 비교하여 가장 큰 값인 (3, 101)을 출력합니다.

세 번째 예제에서는 리스트를 순회 돌며 문자열의 가장 앞에 있는 문자의 유니코드를 비교합니다. 알파벳만 있다면 알파벳 순서로 출력하는 것과 같습니다. ‘world’는 ‘world1’과 ‘world’까지의 문자열이 같으며 길이가 world1이 더 깁니다. 이럴 경우 world1을 출력합니다.

초깃값은 default로 입력할 수 있습니다. 아래 예제처럼 비어있는 리스트에 최댓값을 찾으려 할 때 기본 값을 반환하게 할 수 있습니다.

```python-exec
numbers = []

max(numbers, default=0) # 출력: 0
```

만약 리스트가 아래와 같이 비어있는 상태에서의 max 호출이라면 이 코드는 에러가 나게 됩니다.

```python-exec
numbers = []

max(numbers) # error
```

max는 key를 이용하여 아래와 같은 연산도 수행할 수 있습니다. key에는 일반적으로 lambda 함수가 들어갑니다.

```python-exec
students = [
    {'이름': '가', '국어': 90, '영어': 72, '수학': 95},
    {'이름': '나', "국어": 80, '영어': 90, '수학': 91},
    {'이름': '다', "국어": 95, '영어': 73, '수학': 92}
]

max(students, key=lambda student: student['수학']) # 출력: {'이름': '가', '국어': 90, '영어': 72, '수학': 95}
```

lambda 함수는 딕셔너리가 들어오면 딕셔너리의 수학점수를 반환하게 되어있습니다. 이를 key값으로 넣게 되면 각각의 수학 점수인 95, 91, 92 중 가장 큰 값인 95를 찾게 됩니다. 다만 95를 반환하는 것이 아니라 이 값을 가지고 있는 객체를 반환합니다.

이해를 위해 함수를 선언하는 방식으로 구현해보았습니다. 결과는 같습니다.

```python-exec
def select(student):
    return student['수학']

students = [
    {'이름': '가', '국어': 90, '영어': 72, '수학': 95},
    {'이름': '나', "국어": 80, '영어': 90, '수학': 91},
    {'이름': '다', "국어": 95, '영어': 73, '수학': 92}
]

max(students, key=select) # 출력: {'이름': '가', '국어': 90, '영어': 72, '수학': 95}
```

min의 형태도 max와 같습니다. 가장 작은 값을 찾아 반환합니다.

```python
min(순회할 수 있는 객체, 함수(key), 초깃값(default))
```

다음은 min을 사용한 예시입니다.

```python
min([1, 2, 3, 4, 5]) # 출력 : 1
min([], default=0) # 출력: 0
```

첫 번째 예시는 리스트 안에 가장 작은 값인 1을 출력한 예시이며 두 번째 예시는 기본 값 0을 설정해놓고 빈 리스트를 넣었을 때 0이 출력된 것을 확인해본 것입니다.

이번에는 딕셔너리에 수학에서 가장 낮은 점수를 출력하는 코드를 만들어 보았습니다.

```python-exec
students = [
    {'이름': '가', '국어': 90, '영어': 72, '수학': 95},
    {'이름': '나', "국어": 80, '영어': 90, '수학': 91},
    {'이름': '다', "국어": 95, '영어': 73, '수학': 92}
]

min(students, key=lambda student: student['수학']) # 출력: {'이름': '나', '국어': 80, '영어': 90, '수학': 91}
```

이 코드 역시 lambda 함수를 이용합니다. 이 함수는 student 딕셔너리를 받아 student의 수학 점수를 반환하고 있습니다. 각각의 수학 점수인 95, 91, 92 중 가장 작은 값인 91를 찾게되고 이 값을 가지고 있는 객체를 반환합니다.

### 2.8.2 sum

`sum` 함수는 순회 가능한 객체를 받아 모든 요소의 합을 계산하여 반환합니다. 기본 형태는 아래와 같습니다. max, min처럼 함수를 넣을 수 없다는 것도 주의해주세요.

```python
sum(iterable, start=0)
```

아래와 같이 사용될 수 있습니다.

```python
sum([1, 2, 3, 4, 5]) # 출력: 15
sum([1, 2, 3], 10) # 출력: 16
```

start 값에는 아래와 같이 리스트도 들어갈 수 있습니다.

```python-exec
sum([[1, 2], [10, 20], [100, 200]], []) # 출력: [1, 2, 10, 20, 100, 200]
# [] + [1, 2]
# [1, 2] + [10, 20]
# [1, 2, 10, 20] + [100, 200]
# [1, 2, 10, 20, 100, 200]
```

이렇게 될 경우 각각에 요소들은 빈 리스트에 누적되면서 최종적으로는 2차원 리스트에서 1차원 리스트가 됩니다. 만약 모든 합을 구하고 싶었다면 여기에 한 번 더 sum을 하면 됩니다.

```python-exec
# sum([[1, 2], [10, 20], [100, 200]]) # error
sum(sum([[1, 2], [10, 20], [100, 200]], [])) # 출력: 333
```

이러한 작업들을 손쉽게 해주는 라이브러리도 있습니다. 파이썬의 NumPy 라이브러리에는 이러한 작업을 쉽게 해주는 sum이 있습니다. 다음과 같이 `np.sum` 함수를 사용하여 2차원 리스트의 모든 요소의 합을 계산할 수 있습니다.

```python-exec
import numpy as np

np.sum([[1, 2], [3, 101], [1, 20], [3, 100]]) # 출력 : 328
```

## 2.9 print, repr

`print` 함수는 Python의 내장 함수로, 객체를 문자열 형태로 출력하는 기능을 합니다. 객체가 `__str__` 메서드를 가지고 있으면, 이 메서드를 호출하여 출력할 문자열을 얻습니다.

```python-exec
class Charactor:
    def __repr__(self):
        return 'hello'
    def __str__(self):
        return 'world'

hero = Charactor()
print(hero) # 출력 : 'world'
# hero # 출력 : 'hello'
```

`repr` 함수는 Python의 내장 함수로, 객체의 "공식" 문자열 표현을 가져옵니다. 객체가 `__repr__` 메서드를 가지고 있으면, 이 메서드를 호출하여 표현할 문자열을 얻습니다.

```python
repr(hero) # (__repr__ 메서드 호출로 인해) 출력 : hello
```

## 2.10 range, enumerate

### 2.10.1 range() 함수란?

`range` 함수는 순회할 수 있는 숫자 객체를 만들어주는 함수입니다. 파이썬 2버전에서는 반환값이 리스트였다가 메모리를 효율적으로 관리하기 위해 파이썬 3버전에서는 리스트 대신 `range` 객체를 반환합니다.

```python
range(start, stop, step)
```

`range` 함수의 기본 구조는 `range(start, stop, step)`으로, start부터 stop-1까지 step 간격으로 숫자 시퀀스를 생성합니다. 다만 아래와 같이 생성했을 경우에는 순회를 돌지 않고 설정한 값만 보여주기 때문에 list로 형변환을 해야 형태를 확인할 수 있습니다.

```python-exec
range(1, 10, 2) # 출력: range(1, 10, 2)
# list(range(1, 10, 2)) # 출력: [1, 3, 5, 7, 9]
```

자주 사용되는 range의 형태를 살펴보도록 하겠습니다.

```python-exec
print(list(range(100)))
# print(list(range(5, 10)))
```

```python
# 출력
[0, 1, 2, 3, 4, ... ,95, 96, 97, 98, 99]
[5, 6, 7, 8, 9]
```

첫 번째 예제는 start값을 명시하지 않은 것입니다. 명시하지 않은 값은 0으로 초기화 됩니다. 100은 stop값으로 설정됩니다. 따라서 0부터 99까지 출력합니다. 마지막 값에서 -1한 값까지만 출력하기 때문입니다. 가장 많이 사용되는 형태입니다.

두 번째 예제는 시작값을 명시한 것입니다. 명시하면 그 값부터 시작합니다. 종료값은 10입니다. 따라서 5부터 9까지를 출력합니다.

아래 예시는 step 값을 설정한 예제입니다.

```python-exec
print(list(range(0, 101, 2))) #짝수
print(list(range(1, 101, 2))) #홀수
```

```python
# 출력
[0, 2, 4, 6, 8, ... , 94, 96, 98, 100]
[1, 3, 5, 7, 9, ... , 93, 95, 97, 99]
```

start는 0이며 stop은 101입니다. 따라서 0부터 100까지 범위가 지정되며 step이 2칸씩 건너뛰었기 때문에 첫 번째 예제는 짝수를 출력합니다. 두 번째 예제는 1부터 시작하여 2칸씩 건너뛰었기 때문에 홀수를 출력합니다.

아래와 같이 음수 값도 사용할 수 있습니다. 자주 사용되는 형태는 아닙니다.

```python-exec
print(list(range(100, 1, -2)))
```

```python
# 출력
[100, 98, 96, ... , 8, 6, 4, 2]
```

### 2.10.2 range와 시퀀스 자료형

`range` 함수는 순차적인 수열을 생성하는데 사용되는 특별한 자료형으로, 시퀀스 자료형의 일종입니다. 시퀀스 자료형은 리스트, 튜플, 문자열 등과 같은 다양한 타입들을 포함하며, 공통적인 연산과 기능을 지니고 있습니다. 이런 특성은 `range` 함수가 생성하는 수열에도 적용됩니다. 다음과 같은 특성들을 확인할 수 있습니다:

인덱싱을 할 수 있습니다. 시퀀스 자료형은 인덱스를 통해 각 요소에 접근할 수 있습니다. 예를 들어, `range(10)[3]`은 숫자 3을 반환합니다.

슬라이싱을 할 수 있습니다. 범위를 지정하여 시퀀스의 일부를 추출할 수 있습니다. 예를 들면, `range(10)[3:7]`은 `range(3, 7)`과 동일한 결과를 반환합니다.

길이 확인이 가능합니다. `len` 함수를 사용하여 시퀀스의 길이를 확인할 수 있습니다. 예시로, `len(range(10))`은 10을 반환합니다. filter나 map은 길이 확인이 안된다는 점도 기억해두세요.

멤버십 테스트 (Membership)가 가능합니다. `in` 키워드를 이용하여 시퀀스 내 특정 요소의 존재 여부를 검사할 수 있습니다. 예를 들어, `5 in range(10)`은 `True`를 반환합니다.

반복 (Iteration)할 수 있습니다. `for` 반복문을 사용하여 시퀀스의 모든 요소를 순차적으로 순회할 수 있습니다. 예를 들어, `for i in range(3): print(i)` 구문은 0, 1, 2를 순서대로 출력합니다.

### 2.10.3 enumerate

`enumerate` 함수는 반복할 수 있는 객체의 인덱스와 값을 함께 반환하며 주로 반복문에서 사용합니다. 해당 예제에서는 리스트를 `enumerate` 함수에 전달하여 인덱스와 값을 함께 얻습니다. 추가로, `enumerate` 함수의 두 번째 인자를 통해 시작 인덱스를 지정할 수 있습니다. 이를 활용하여 반복문 내에서 인덱스와 값에 동시에 접근하는 것이 가능합니다.

```python-exec
values = ['A', 'B', 'C', 'D']
print(list(enumerate(values)))
print(list(enumerate(values, 1)))
print(list(enumerate(values, 100)))
```

```python
# 출력
[(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]
[(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D')]
[(100, 'A'), (101, 'B'), (102, 'C'), (103, 'D')]
```

## 2.11 sorted, reversed

`sorted` 함수는 시퀀스를 정렬하여 새로운 리스트를 반환합니다. `reverse` 및 `key` 아규먼트를 전달하여 정렬 방법을 사용자가 원하는 대로 변경할 수 있습니다.

```python-exec
sorted([1, 2, 100, 200, 3, 4, 10, 20])
# 출력 : [1, 2, 3, 4, 10, 20, 100, 200] - 오름차순
```

```python-exec
sorted([1, 2, 100, 200, 3, 4, 10, 20], reverse=True)
# 출력 : [200, 100, 20, 10, 4, 3, 2, 1] - 내림차순
```

첫 번째 예제 출력에서 값이 정렬된 것을 확인할 수 있습니다. 두 번째 예제에서는 `reverse=True` 값을 아규먼트로 전달하여 역순으로 정렬된 것을 확인할 수 있습니다.

이번에는 key에 아규먼트를 넣어보도록 하겠습니다. key에는 함수가 들어갈 수 있습니다. 가장 먼저 built-in function을 사용해보도록 하겠습니다.

```python-exec
sorted(['hello', 'l', 'hllo', 'hel', 'heo', 'a'])
# 출력 : ['a', 'hel', 'hello', 'heo', 'hllo', 'l']
```

```python-exec
sorted(['hello', 'l', 'hllo', 'hel', 'heo', 'a'], key=len)
# 출력 : ['l', 'a', 'hel', 'heo', 'hllo', 'hello']
```

`key=len`를 사용하여 각 값을 문자열 길이대로 정렬하게 하였습니다. 따라서 이 코드는 문자열 길이를 기준으로 오름차순으로 정렬합니다.

이번에는 사용자가 정의한 함수를 넣어보도록 하겠습니다.

```python-exec
sorted(['12', '15', '21', '22', '53', '21'])
# 출력 : ['12', '15', '21', '21', '22', '53']
```

```python-exec
sorted(['21', '21', '12', '22', '53', '15'], key=lambda x:x[-1])
# 출력 : ['21', '21', '12', '22', '53', '15']
```

`lambda x:x[-1]` 함수에서 마지막 값을 반환하고 있으므로 마지막 값을 기준으로 정렬하게 된 것입니다.

`reversed` 함수는 모든 항목을 역순으로 반환합니다. `reversed`는 `sorted`에서 `reverse=True`를 사용한 것과 다르게 역으로 정렬하는게 아니라 역순이라는 것을 기억해야 합니다.

```python-exec
list(reversed('hello world'))
# list(reversed([1, 2, 3, 10, 5, 4])) # 역 정렬 아닙니다! 역순입니다.
# list(reversed(sorted([1, 2, 3, 10, 5, 4])))
```

```python
# 출력
['d', 'l', 'r', 'o', 'w', ' ', 'o', 'l', 'l', 'e', 'h']
[4, 5, 10, 3, 2, 1]
[10, 5, 4, 3, 2, 1]
```

sorted와 reversed는 원본을 수정하지 않습니다.

```python-exec
l = [3, 2, 1, 5, 4]
print(sorted(l))
print(l)
```

```python
[1, 2, 3, 4, 5]
[3, 2, 1, 5, 4]
```

이처럼 l의 요소 값의 순서가 마지막에 바뀌지 않은 것을 확인할 수 있습니다. 리스트의 메서드인 sort와 reverse는 아래처럼 원본을 수정합니다. sort를 먼저 확인해보도록 하겠습니다.

```python-exec
l = [3, 2, 1, 5, 4]
print(l.sort())
print(l)
```

```python
None
[1, 2, 3, 4, 5]
```

이번에는 reverse입니다.

```python-exec
l = [3, 2, 1, 5, 4]
print(l.reverse())
print(l)
```

```python
None
[4, 5, 1, 2, 3]
```

# 3. 나아가기

```python-exec
type(print) # 출력: builtin_function_or_method
# type(max) # 출력: builtin_function_or_method
# type(len) # 출력: builtin_function_or_method
# type(enumerate) # 출력: type
# type(range) # 출력: type
# type(zip) # 출력: type
# type(map) # 출력: type
# type(filter) # 출력: type
# type(int) # 출력: type
# type(str) # 출력: type
```

range는 function이 아니라 타입입니다. 왜 이런 타입이 생겼을까요? 메모리 효율을 위해서입니다.

Python 2.x에서 `range`는 리스트를 반환합니다. 이는 생성할 숫자의 전체 리스트를 메모리에 저장하므로 매우 큰 범위의 경우 비효율적일 수 있습니다.`xrange`는 Python 2.x에서 `range`의 메모리 문제를 해결하기 위해 도입되었습니다. 이는 실제 리스트 대신 'xrange' 객체를 반환하여, 요청 시에만 숫자를 생성합니다.

Python 3.x에서는 `range`가 `xrange`의 기능을 채택하였으며, `xrange`는 사용되지 않습니다. 즉, Python 3.x에서 `range`는 숫자를 실시간으로 생성하는 레이지 평가 방식을 사용하여 메모리를 절약합니다.

아래 예제를 통해서 왜 2.x의 range가 3.x로 그대로 도입되지 못했는지 확인해보세요.

```python-exec
# range(start, stop, step) # 슬라이싱과 비슷한 형태를 지니고 있습니다.
print(range(10)) # 값을 가지고 있지 않습니다.
print(list(range(10)))
x = range(10)
print(type(x))
print(list(range(0, 10, 2)))
print(list(range(10, 0, -2)))
# print(list(range(10, 0, 2.1))) # error, numpy 모듈 사용하면 가능합니다.
# print(list(range(10.1, 2.0, 2))) # error, numpy 모듈 사용하면 가능합니다.
print(list(range(0, 10, -2)))
```

```python
# 2.x에서 range와 그 외 값들에 대한 히스토리
# print(range(10)) # 출력: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# 메모리를 모두 차지해야 합니다.

# print(range(100000000000000000000000000000000000000))
# 메모리의 효율이 극도로 안좋아짐

# 그런데 3.x에서 range(10000000000000000000000000000)는 메모리 효율이 안좋나요?
# 시작과, 끝, 스텝값만 가지고 있기 때문에 메모리 낭비가 전혀 없습니다.

# 2.x에서도 3.x와 같은 range타입이 있었습니다. xrange문법입니다. xrange문법이 3.x되면서 range가 된겁니다.
# 2.x에서 사용가능 문법
# print(xrange(10)) # 출력: xrange(10)
# for i in xrange(10): # 출력: 순회 가능
#     print(i)
```
