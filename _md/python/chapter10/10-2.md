---
chapter: 모듈과 패키지
title: 모듈과 패키지 관리
date: 2024-01-30
---

# 1. 모듈의 내부 동작 원리

`pip install` 명령어를 사용하면 PyPI로부터 패키지를 다운로드 받아 `site-packages` 디렉토리(`Python311\Lib\site-packages`, Lib 폴더 아래 있다는 것을 주의해주세요.)에 설치합니다. python3 -m site 명령어로 설치된 폴더를 확인할 수 있습니다.

![](/images/python/chapter10/2-1.png)

python에서도 아래와 같이 모듈을 추가하여 `sys.path` 를 살펴볼 수 있습니다.

![](/images/python/chapter10/2-2.png)

이렇게 설치된 모듈은 아래 명령어를 통해 확인할 수 있었습니다.

```python
pip list
```

## **모듈의 로딩**

Python에서 모듈은 아래와 같은 형태, `import`문을 통해 로드됩니다. 모듈이 처음 `import` 되었을 때, 그 모듈의 코드는 한 번만 실행되고, 그 결과 (함수나 클래스의 정의, 변수의 초기화 등)는 시스템의 모듈 테이블에 저장됩니다. 이후 동일한 모듈이 다시 `import` 되면, Python은 새로이 코드를 실행하는 대신 모듈 테이블에서 모듈의 상태를 불러옵니다.

```python
import pandas as pd
```

## **import 문의 내부 동작**

1. Python은 먼저 `sys.modules`를 체크(Python이 실행될 때 자동으로 로드)합니다. 이 딕셔너리는 이미 로드된 모듈들의 이름을 키로 하고, 해당 모듈 객체를 값으로 가집니다. 모듈이 이미 `sys.modules`에 존재한다면, 그것이 반환됩니다.

   ![](/images/python/chapter10/2-3.png)

2. `sys.modules`에 없다면, Python은 `sys.path`에 있는 디렉토리들을 순회하면서 모듈이 있는지 찾습니다. `sys.path`는 Python 인터프리터에서 모듈을 어디에서 찾아야 할지 알려주는 경로의 리스트입니다. 이 리스트는 다음과 같은 위치를 포함합니다.

   1. 스크립트가 실행되는 현재 디렉토리 (또는 Python 인터랙티브 세션을 시작한 디렉토리)
   2. `PYTHONPATH` 환경 변수에 명시된 모든 디렉토리 (환경 변수가 설정된 경우, window의 환경변수 설정하기로 검색하시면 됩니다.)
   3. Python 설치 시 지정된 라이브러리 디렉토리, 기본적으로 Windows에서는 "C:\PythonXX\Lib"와 같은 형태로 될 것입니다. 여기서 'XX'는 Python의 버전을 나타냅니다.

      ![](/images/python/chapter10/2-4.png)

   4. 각각의 `.egg` 파일 (있을 경우)
      ::a[EGG 파일 형식 - Python 배포 파일]{class='btn-link' href="https://docs.fileformat.com/ko/programming/egg/" target="\_blank"}

   5. `sys.path`에 디렉토리를 동적으로 추가한 경우. 예를 들어, 스크립트에서 다른 디렉토리에 있는 모듈을 임포트하려는 경우, `sys.path.append('/path/to/directory')`를 사용하여 해당 디렉토리를 `sys.path`에 추가할 수 있습니다. 그러면 Python은 그 디렉토리를 검색하여 모듈을 찾을 수 있습니다.
   6. `site-packages` 는 `.pth` 파일을 참고합니다.

      ![](/images/python/chapter10/2-5.png)

3. Python이 모듈을 찾았다면, 모듈의 코드를 읽고 실행합니다. 모듈의 이름이 `sys.modules`에 추가되고, 이 이름으로 모듈을 참조할 수 있습니다.

   1. **실습 1** : 아래와 같이 모듈을 만들고, sys.modules에 포함이 되었는지 확인해보세요.

      ```python
      # sampletest.py
      name = 'hojun'
      ```

      ```python
      # colab
      import sampletest

      sampletest.name
      ```

      ```python
      # colab
      import sys

      'sampletest' in sys.modules # True
      ```

   2. **실습 2** : colab에서 `/content/a/b/c`의 폴더를 만들어 거기서 모듈 검색이 가능하게 해주세요. `a/b/c` 폴더 안에는 sampletest 파일이 들어 있습니다. 실행하기 전 런타임을 초기화 해주세요.

      ```python
      import sampletest

      sampletest.name # Error
      ```

      ```python
      import sys

      'sampletest' in sys.modules # False
      ```

      ```python
      sys.path.append('/content/a/b/c')
      ```

      ```python
      import sampletest

      sampletest.name
      ```

      ```python
      import sys

      'sampletest' in sys.modules # False
      ```

4. 만약 Python이 모듈을 찾지 못했다면, `ModuleNotFoundError`가 발생합니다.

## **모듈의 실행**

모듈이 로드되면, 모듈의 코드는 최상위 레벨에서 실행되고, 모듈의 네임스페이스를 정의하는데 사용되는 이름들은 생성됩니다. 모듈의 네임스페이스는 `import` 문을 통해 접근할 수 있습니다.

# 2. 모듈과 패키지의 재사용성

**모듈과 패키지의 재사용성 이해하기**

1. 재사용성의 중요성
   - 코드의 재사용성을 높이는 것은 개발 시간을 줄이고, 코드의 품질을 향상시키는 데 중요합니다. 재사용성이 높은 코드는 수정이 용이하고, 에러를 줄일 수 있습니다.
   - Python의 모듈과 패키지 시스템은 코드의 재사용성을 크게 향상시킵니다.
2. 모듈의 재사용성
   - 모듈은 Python 코드를 포함하는 .py 파일로, 함수, 변수, 클래스 등을 정의할 수 있습니다. 이렇게 정의된 모듈은 `import`문을 통해 다른 Python 코드에서 재사용할 수 있습니다.
   - 예를 들어, 특정 기능을 수행하는 함수를 여러 스크립트에서 사용해야 하는 경우, 이 함수를 모듈에 정의하고 필요한 스크립트에서 임포트하여 사용할 수 있습니다.
3. **패키지의 재사용성**

   - 패키지는 관련된 여러 모듈을 하나의 디렉토리에 모아놓은 것입니다. 패키지를 통해 모듈을 논리적으로 그룹화하고, 이를 재사용할 수 있습니다.
   - 예를 들어, **여러 모듈에서 공통으로 사용하는 클래스나 함수를 `utilities`라는 패키지에 모아놓고, 이 패키지를 임포트하여 코드를 재사용할 수 있습니다.**

   - **실습**

     먼저, `utilities` 패키지를 만들고, 이 안에 `math_tools.py`라는 모듈을 만들어 보겠습니다. 이 모듈에는 공통으로 사용할 수 있는 수학 함수들을 정의합니다.

     ```python
     # utilities/math_tools.py

     def add(x, y):
         return x + y

     def subtract(x, y):
         return x - y
     ```

     그 다음, 이 `utilities` 패키지를 다른 스크립트에서 임포트하여 함수를 사용하는 예제입니다.

     ```python
     # main.py

     from utilities.math_tools import add, subtract

     def main():
         print(add(10, 5))  # 출력: 15
         print(subtract(10, 5))  # 출력: 5

     if __name__ == "__main__":
         main()
     ```

     위 예제에서 `main.py` 스크립트는 `utilities` 패키지의 `math_tools` 모듈에서 `add`와 `subtract` 함수를 임포트하여 사용하고 있습니다. 이렇게 패키지와 모듈을 사용하면, 공통 함수를 한 곳에 모아서 코드의 재사용성을 높일 수 있습니다.

**모듈과 패키지의 재사용성 향상하기**

1. 모듈과 패키지의 설계
   - 재사용성을 높이려면 모듈과 패키지를 잘 설계해야 합니다. 즉, 하나의 모듈은 하나의 주요 기능에 집중하고, 패키지는 관련된 모듈들을 그룹화하는 것이 좋습니다.
2. 명확한 API 제공
   - 모듈과 패키지는 재사용성을 위해 명확한 API(Application Programming Interface)를 제공해야 합니다. 즉, 외부에서 사용할 수 있는 함수와 클래스, 변수 등을 명확하게 정의하고, 그 사용법을 문서화하는 것이 중요합니다.
3. 테스트 코드 작성
   - 모듈과 패키지의 재사용성을 높이려면 이를 검증하는 테스트 코드가 필요합니다.

# 3. 자주 사용되는 표준 라이브러리

:::div{.callout}

간단한 사용법 또는 모듈들은 한 번 살펴보시기를 권해드립니다.

:::

1. `os` 모듈: 운영체제와 상호작용하는 데 사용되는 함수들을 제공합니다. 파일과 디렉토리를 만들고, 읽고, 쓰는 것을 비롯하여 환경 변수에 접근하거나 운영 체제 명령을 실행하는 등의 작업을 수행할 수 있습니다.

   ```python
   import os

   os.mkdir('licat') # licat이란 폴더 생성, 삭제는 os.rmdir()
   os.getcwd() # 현재 경로 반환
   os.open('a.txt', os.O_CREAT | os.O_WRONLY) # 파일 생성(os.O_CREAT: 필요한 경우 파일을 생성, os.O_WRONLY: 파일을 쓰기 전용 모드로 연다.)
   os.rename('a.txt', 'b.txt') # a.txt파일을 b.txt파일로 변경
   os.remove('b.txt')
   ```

2. `sys` 모듈: Python 인터프리터와 상호작용하는 도구를 제공합니다. 이 모듈을 사용하면 명령행 인수를 처리하거나, 입/출력 스트림을 제어하거나, 인터프리터의 상태를 점검하고 제어할 수 있습니다.

   ```python-exec
   import sys

   a = [1, 2, 3]
   b = a
   c = a
   sys.getrefcount(a) # 얼마나 참조되고 있는가, 기본값은 1입니다.
   ```

3. `math` 모듈: 수학적 연산을 수행하는데 필요한 함수들을 제공합니다. 제곱근, 로그, 삼각함수 등의 기능이 포함되어 있습니다.

   ```python-exec
   import math

   math.pi # 출력: 3.141592653589793
   ```

4. `datetime` 모듈: 날짜와 시간을 다루는 클래스를 제공합니다. 현재 날짜와 시간을 가져오는 것부터 날짜와 시간의 차이를 계산하는 것까지 다양한 기능을 제공합니다.

   ```python-exec
   import datetime

   s = datetime.datetime(2023, 9, 19, 14, 10)
   print(s)
   print(s.year, s.month, s.day, s.hour, s.minute)

   s = datetime.datetime(2023, 9, 18, 14, 10)
   print(s.weekday()) # 월요일0, 화요일1, 수요일2 ... 일요일6

   today = datetime.date.today()
   days = datetime.timedelta(days=100)
   today + days # 100일 후 시간

   graduation_date = datetime.date(2023, 12, 29)
   today = datetime.date.today()

   print(graduation_date - today) # 졸업까지 남은 일자
   ```

5. `json` 모듈: JSON 형식의 데이터를 읽고 쓰는 데 사용됩니다. Python 데이터 구조를 JSON 문자열로 직렬화하거나, JSON 문자열을 Python 데이터 구조로 역직렬화하는 기능을 제공합니다. 일반적으로 클래스로 구현하여 만든 인스턴스는 직렬화되지 않습니다.

   :::div{.callout}

   직렬화란 데이터를 저장/전송 형식으로 변환하는 것을 얘기합니다. 보통 문자열로 변환됩니다.

   :::

   ```python-exec
   import json

   d = {
       'one': 1,
       'two': 2,
       'three': 3
   }

   s = json.dumps(d)
   print(type(s)) # str
   d = json.loads(s)
   print(type(d)) # dict
   ```

6. `collections` 모듈: 기본 데이터 컨테이너 외에도 다양한 데이터 컨테이너 타입을 제공합니다. deque, Counter, OrderedDict, defaultdict 등과 같은 고급 데이터 구조를 제공합니다.

   ```python-exec
   import collections

   d = collections.deque([1, 2, 3, 4])
   d.rotate(1) # 1번 오른쪽으로 쉬프트 합니다. 숫자를 2로 바꾸어 비교해보세요.
   d # 출력: deque([4, 1, 2, 3])

   c = collections.Counter('hello world')
   c # 출력: Counter({'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
   c.most_common()
   # 출력:
   '''
   [('l', 3),
    ('o', 2),
    ('h', 1),
    ('e', 1),
    (' ', 1),
    ('w', 1),
    ('r', 1),
    ('d', 1)]
   '''
   ```

7. `requests` 모듈: HTTP 요청을 쉽게 보낼 수 있는 기능을 제공하는 외부 라이브러리입니다. REST API와 통신하거나 웹 페이지를 스크래핑하는 등의 작업을 수행하는 데 유용합니다. 보통 `BeautifulSoup` 모듈과 함께 사용됩니다. `BeautifulSoup`는 가지고 온 데이터를 우리가 보다 쉽게 접근할 수 있게 파싱합니다.

   :::div{.callout}

   파싱은 문자열이나 데이터를 분석하여 구조화된 정보로 변환하는 과정을 말합니다.

   :::

   ```python
   import requests
   from bs4 import BeautifulSoup

   paullab_url = 'https://paullab.co.kr/bookservice/'
   response = requests.get(paullab_url)
   response.encoding = 'utf-8'
   html = response.text

   soup = BeautifulSoup(html, 'html.parser')

   bookservices = soup.select('.col-lg-6 > h2') # col-lg-6 클래스 안의 h2 태그 탐색
   for no, book in enumerate(bookservices, 1):
       print(no, book.text)
   ```
