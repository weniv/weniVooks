---
chapter: 05장 리스트, 튜플, 딕셔너리, 셋
title: 05.2 리스트(list)
date: 2024-01-29
---

# 1. 리스트(List)란?

리스트는 파이썬에서 제공하는 가변적(mutable)이고, 순서가 있는 시퀀스 자료형입니다. 위치의 특성을 가지고 있어 정렬할수 있으며, 가변적이라는 특성 때문에 리스트 내의 원소들은 생성 후에도 변경, 추가, 삭제가 가능합니다. (디렉터리에서 파일리스트, 회사에서 직원리스트, 메일함의 이메일 목록 등)

리스트가 왜 필요할까요?

100명의 성적을 채점하기 위해서 지금까지 배웠던 지식으로는 100개의 변수를 만들어야 했습니다. x1, x2, x3…그것을 쉽게 구현한 것이 리스트라고 생각하시면 됩니다. 이를 배열이라고 하기도합니다.

## 1.1 리스트 생성

리스트를 생성하는 방법 역시 간단합니다. 대괄호(`[]`) 안에 쉼표(`,`)로 구분된 데이터들을 넣으면 됩니다.

```python
x = [1, 2, 3] #CSV 파일과 비슷 ,
y = ['apple', 'banana', 'cherry']
z = [1, [2], 3] in [2]
```

:::div{.callout}
리스트는 문자열뿐만 아니라 다양한 데이터 타입을 포함할 수 있습니다. 심지어 리스트 내부에 또 다른 리스트를 넣는 것도 가능합니다.

:::

이렇게 사용하게 되면 1에는 0, 2에는 1, 3에는 2 / apple에는 0, banana에는 1, cherry는 2라는 주소값이 붙게됩니다. 이는 시퀀스형의 기본입니다. 왜 0부터 시작할까요? 이진수 관점에서 메모리를 절약할수 있다는 장점이 있습니다.

len을 사용하면 리스트안에 몇개의 데이터가 있는지 확인할 수 있습니다. 이는 데이터 검증할때 매우 유용합니다.

```python
print(len(x))
print(len(y))
```

리스트 안에 여러 종류의 데이터를 혼합하여 저장할 수도 있습니다. 다만 일관된 데이터 처리를 위해 이렇게 혼합해 데이터를 넣는 것을 권장하지 않습니다.

```python
z = [1, 'apple', 2.5, ['a', 'b'], (1, 2)]
print(z[0])
```

리스트 내부에 저장된 각 데이터를 "항목" 또는 "원소"라고 부릅니다. 위의 `z` 리스트에는 총 5개의 항목이 있습니다. 리스트는 콤마 사이에 공백을 병합합니다. 아래와 같은 형태가 가능합니다.

```python
z = [
	1,
	'apple',
	2.5,
	['a', 'b'],
	(1, 2)
]
print(z[0])
```

아래와 같이 마지막에 콤마를 넣는 경우도 많습니다.

```python
z = [
	1,
	'apple',
	2.5,
	['a', 'b'],
	(1, 2),
]
print(z[0])
```

리스트는 순서가 있으므로, 인덱싱을 통해 각 항목에 접근할 수 있습니다. 인덱스는 0부터 시작하며, 첫 번째 항목은 `z[0]`, 두 번째 항목은 `z[1]`로 접근할 수 있습니다.

```python
# 출력 결과
1
```

리스트는 데이터의 집합을 효과적으로 관리할 수 있는 중요한 자료형입니다. 데이터를 순서대로 저장하고, 필요할 때 쉽게 접근하거나 수정할 수 있으므로 많은 프로그램에서 활용됩니다.

```python
z[99] # Index Error: list index out of range
z[99] = 1 # Index Error: list assignment index out of range
```

리스트는 사실 고정된 크기가 없습니다. 그러나 존재하지 않는것이 수행이 된다면 나중에 문제가 생길수 있습니다. 가상의 정보가 생성이 된다던가 정보가 꼬일수 있기 때문에 보통은 에러가 발생이됩니다. 그래서 보통 파이썬은 에러를 보고하며, 이를 가능하게 하기 위해서 append() 같은 메서드를 사용합니다.

## 1.2 리스트의 수정 및 다차원 리스트

파이썬의 리스트는 항목의 변경이 가능하며, 다양한 자료형을 함께 담을 수 있습니다. 더 나아가, 리스트 안에 또 다른 리스트를 담아서 다차원 리스트를 구성할 수도 있습니다.

데이터 분석과 같은 분야에서는 이러한 다차원 리스트를 이용하여 행렬을 표현하기도 합니다.

### 1.2.1 리스트의 항목 변경하기

리스트는 항목의 변경이 가능합니다. 단순히 인덱싱을 이용하여 값을 할당하는 것만으로 리스트의 특정 항목을 변경할 수 있습니다.

```python
a = [1, 2, 3, 4, 5]
a[0] = 10000
print(a)
```

이 코드는 리스트 `a`의 첫 번째 항목을 `10000`으로 변경합니다.

### 1.2.2 문자열은 변경이 불가능하다(immutable)

리스트와는 달리, 문자열은 불변(immutable)입니다. 따라서 문자열의 특정 문자를 변경하는 것은 불가능합니다.

```python
s = 'licat'
print(s[0])
s[0] = 'k'
```

```python
# 출력
TypeError: 'str' object does not support item assignment
```

위의 코드에서 `s[0]`은 문자열 `s`의 첫 번째 문자를 의미하며, 이 값은 `'l'`입니다. 그러나, `s[0] = 'k'`를 실행하려고 하면 문자열의 변경은 지원되지 않기 때문에 에러가 발생합니다.

:::div{.callout}
문자열은 한번 생성되면 그 내용을 변경할 수 없습니다. 만약 문자열의 내용을 변경하고 싶다면, 새로운 문자열을 생성해야 합니다.

:::

### 1.2.3 다차원 리스트

리스트는 다양한 자료형을 담을 수 있기 때문에, 리스트 안에 리스트를 넣어 다차원 리스트를 만들 수 있습니다.

```python
b = [[10, 20, 30], [1, 2, 3]]
print(b[1][2]) # 출력: 3
```

위의 코드에서 `b[1][2]`는 `b` 리스트의 두 번째 리스트 항목의 세 번째 값을 의미하며, 이 값은 `3`입니다.

# 2. 리스트 연산

## 2.1 덧셈과 곱셈 연산

이전에 배웠던 문자열과 마찬가지로 리스트에서도 덧셈과 곱셈 연산이 가능합니다. 덧셈은 두 리스트를 연결합니다.

```python
a = [1, 2, 3, 4, 5]
b = [6, 7, 8]

print(a + b) # 출력: [1, 2, 3, 4, 5, 6, 7, 8]
```

이러한 덧셈은 `__add__`에 구현이 되어 있기 때문에 가능한 것입니다. `__add__`에 요소마다 더하는 것으로 구현이 되어 있었다면 [2, 4, 6]을 출력했을 것입니다. 실제로 아래 덧셈은 요소마다 더해지게 되어 있습니다.

```python
import numpy as np

l = [1, 2, 3]
l = np.array(l)
l * 3
l + l
# 너무 당연하게 요소를 붙이는 것이다라고 생각하지 않으셨으면 좋겠습니다.
```

곱셈은 리스트를 여러 번 반복합니다.

```python
x = [1]
print(x * 3) # 출력: [1, 1, 1]
```

다만 곱셈은 다음과 같은 사항에 주의해야 합니다.

```python
a = [1, 2, 3]
a = a * 3

a[0] = 1000
print(a)
```

```python
[1000, 2, 3, 1, 2, 3, 1, 2, 3]
```

위와 같이 중첩되지 않은 리스트의 곱셈은 값이 하나가 변경이 되어도 다른 값들이 변경이 되지 않습니다.

```python
a = [1, 2, 3]
a = [a * 2] * 2 # 리스트 컴프리헨션 사용하셔서 만드시는 것을 권합니다.

print(a)
print(id(a[0]), id(a[1]))
a[0][0] = 10000
print(a)
```

```python
[[1, 2, 3, 1, 2, 3], [1, 2, 3, 1, 2, 3]]
136783650416896, 136783650416896
[[10000, 2, 3, 1, 2, 3], [10000, 2, 3, 1, 2, 3]]
```

위 코드에서 복사는 제대로 이뤄진 것을 볼 수 있습니다. 다만 이렇게 복사된 것이 id를 확인해보면 같은 id라는 것을 확인할 수 있습니다.

중첩된 리스트가 아닌 경우에는 복사된 리스트가 연결되는 것이기 때문에 단일 요소의 수정이 전체에 영향을 미치게 됩니다.

## 2.2 리스트 인덱싱

리스트도 문자열처럼 순서가 있어 인덱싱을 통해 각 항목에 접근할 수 있습니다. 인덱스는 0부터 시작하며, 리스트의 마지막 항목의 인덱스는 -1입니다.

:::div{.callout}

리스트는 문자열과 마찬가지로 0부터 인덱싱을 시작합니다. 순서가 있는 시퀀스형 자료형의 공통적인 특징입니다.
:::

```python
l = [1, 2, 3, 4, 5]
print(l[0]) # 출력: 1
print(l[3]) # 출력: 4
print(l[-1]) # 출력: 5
print(l[-3]) # 출력: 3
```

범위를 넘어가는 인덱스로 값을 호출하려면 에러가 발생합니다. 에러명은 **`IndexError`** 이며, 리스트에 인덱스가 범위를 벗어났다는 것을 나타냅니다.

```python
lst = [1, 2, 3, 4, 5]
print(lst[10])
```

```sql
# 출력
IndexError: list index out of range
```

## 2.3 리스트 슬라이싱

리스트의 일부분을 추출하고 싶을 때에는 인덱스를 사용하여 잘라낼 수 있습니다.

### 2.3.1 슬라이싱

슬라이싱은 **`[start:stop:step]`** 형태로 사용하며, 마찬가지로 step은 기본적으로 1이며 생략할 수 있습니다.

```python
l = [1, 2, 3, 4, 5]
print([1:4]) # 출력: [2, 3, 4]
```

### 2.3.2 다양한 슬라이싱 형태 알아보기

문자열과 같이 다양한 형태의 슬라이싱이 사용가능합니다. 맨 아래 예제처럼 슬라이싱을 2번 또는 n번 사용하여 값을 반환하는 것도 가능합니다.

```python
l = [1, 2, 3, 4, 5]
print(l[:])     # 출력: [1, 2, 3, 4, 5]
print(l[::-1])  # 출력: [5, 4, 3, 2, 1]
print(l[::2])   # 출력: [1, 3, 5]
print(l[0:4][::-1]) # 출력: [3, 2, 1]
```

### 2.3.3 슬라이싱은 에러가 발생하지 않는다

리스트의 슬라이싱은 범위가 넘어가더라도 오류를 발생시키지 않습니다. 이는 안정적인 코드 작성을 위한 특징입니다.

```python
l = [1, 2, 3, 4, 5]
print(l[10:20]) # 출력: []
```

# 3. 리스트의 구조 및 특징

리스트가 어떻게 동작하는지 대략적으로 알아보았으니 이제 리스트의 상세 구조 및 특징을 면밀히 살펴보도록 하겠습니다.

## 3.1 메모리 구조

리스트는 연속된 메모리 공간에 원소들을 저장하지 않습니다. 대신, 각 원소들은 참조를 통해 다양한 위치에 저장된 객체를 가리킵니다. 이러한 구조 때문에 리스트는 다양한 타입의 데이터를 동시에 저장할 수 있습니다.

리스트의 메모리 구조를 이해하려면, 파이썬에서 객체의 저장 방식을 먼저 이해해야 합니다.

파이썬에서 모든 것은 객체로 취급됩니다. 이는 정수, 실수, 문자열, 리스트, 튜플, 딕셔너리 등 모든 데이터 타입이 객체로 관리된다는 것을 의미합니다.

리스트는 이 객체들의 참조를 저장하는 컨테이너로 볼 수 있습니다. 따라서 리스트의 각 요소는 실제 데이터 값을 직접 저장하는 것이 아니라, 해당 객체를 참조하는 주소를 저장합니다. 이러한 특성 때문에 리스트는 다양한 데이터 타입을 원소로 포함할 수 있습니다.

### 3.1.1 파이썬의 메모리 구조

다음과 같이 리스트를 생성해봅시다.

```python
my_list = [1, 2, 'apple', 3.14]
```

이 리스트의 메모리 구조는 다음과 같이 설명될 수 있습니다:

1. `1`, `2`, `'apple'`, `3.14`는 각각 다른 메모리 위치에 저장된 객체입니다.
2. `my_list`은 이러한 객체들의 참조(즉, 메모리 주소)를 저장하는 배열입니다.

그림으로 표현하면 아래와 같습니다.

![](/images/python/chapter05/02-1.png)

위의 그림에서 보다시피 `my_list`는 각 요소에 대한 참조(주소)를 저장하고, 그 참조를 통해 실제 메모리 위치를 찾아가면 1, 2, apple, 3.14와 같은 실제 값을 저장하는 객체들이 있습니다.

:::div{.callout}
파이썬에서 각 객체의 주소들은 일반적으로 연속적이지 않습니다.
:::

### 3.1.2 다른 언어에서의 메모리구조

![](/images/python/chapter05/02-2.png)

위 그림처럼 C언어에서의 배열은 메모리 상에서 연속적인 주소 공간에 직접 값을 저장합니다. `c_array`라는 변수를 선언했을 때 1000이라는 특정한 위치를 가리키게 되고, 이 위치로부터 연속된 4개의 정수값이 저장됩니다. 또한 이 변수에는 정수값만 담을 수 있습니다.

여기서 알아야 할 포인트는 C언어의 메모리 구조가 아니라 이처럼 데이터를 다루는 형식이 언어마다 다르기 때문에 다른 언어를 이해했던 개념으로 다른 언어를 이해해서는 안된다는 것입니다.

### 3.1.3 메모리 효율성과 성능

파이썬 리스트 메모리 구조의 장점은 다양한 데이터 타입의 원소를 동일한 리스트에 저장할 수 있다는 것입니다. 또한, 데이터의 추가 및 삭제가 다른 언어에 비해 비교적 효율적입니다. 하지만 단점으로는 참조를 저장하기 위한 추가적인 메모리가 필요하다는 점과, 데이터가 연속적인 메모리 공간에 저장되지 않아 캐시의 지역성(cache locality)이 떨어진다는 점이 있습니다.

:::div{.callout}
**캐시의 지역성(cache locality)**
컴퓨터의 메모리는 여러 계층으로 구성되어 있습니다. 이 중에서 CPU에 가장 가까운 메모리를 '캐시 메모리'라고 합니다. 이 캐시 메모리는 매우 빠르지만 용량이 작습니다.
컴퓨터가 빠르게 데이터에 접근하려면 그 데이터가 가까운 곳에 모여 있어야 합니다. 캐시 지역성은 데이터가 얼마나 가까이 모여 있는지를 나타냅니다. 파이썬 리스트는 메모리가 모여있지 않기 때문에, 때로는 느릴 수 있습니다.

:::

즉, 리스트의 메모리 구조는 다양한 데이터 타입과 동적인 크기 변경을 지원하기 위한 트레이드 오프(trade-off)로 일부 메모리 및 성능 효율성을 포기하고 있습니다.

:::div{.callout}
**트레이드 오프(trade-off)**
어떤 것을 얻기 위해 다른 것을 포기하는 것을 트레이드 오프라고 합니다.
예를 들어, 아이스크림을 더 많이 먹으면 행복하겠지만, 체중이 늘어날 수도 있습니다. 여기서 '아이스크림'과 '체중 증가' 사이의 선택은 트레이드 오프입니다.

:::

## 3.2 동적 배열

파이썬의 리스트는 내부적으로 동적 배열로 구현되어 있습니다. 이는 리스트가 공간을 초과한 데이터를 저장해야 할 경우, 자동으로 더 큰 메모리 공간을 확보하고 기존 데이터를 복사하는 방식으로 동작한다는 것을 의미합니다.

## 3.3 접근 시간

### 3.3.1 인덱스를 통한 접근 (Indexing)

리스트의 특정 인덱스에 위치한 요소에 접근하는 시간 복잡도는 _O_(1)입니다. 리스트는 내부적으로 배열의 형태로 참조(주소)들을 저장하고 있기 때문에, 시작 주소에서 인덱스에 해당하는 오프셋(offset)만큼 이동해서 해당 인덱스의 위치에 접근할 수 있습니다.

`my_list[3]`로 리스트의 4번째 요소에 바로 접근할 수 있습니다. 파이썬 리스트는 내부적으로 동적 배열로 구현되어 있습니다. 이 동적 배열은 메모리 상에 연속적인 공간에 각 요소의 참조(주소)를 저장하게 됩니다.

여기서 중요한 점은, 리스트의 각 요소는 메모리 상에 연속적으로 저장되는 것이 아니라, 각 요소의 **참조(주소)** 가 연속적으로 저장된다는 것입니다. `my_list[3]`의 경우, 리스트의 시작 주소에서 4번째 위치에 저장된 참조(주소)를 찾아 해당 참조가 가리키는 메모리 위치에 있는 실제 객체를 반환합니다.

### 3.3.2 슬라이싱 (Slicing)

슬라이싱 연산은 새로운 리스트 객체를 반환하기 때문에 해당 범위의 요소를 새 리스트로 복사하는 시간이 필요합니다.

리스트를 슬라이스해서 부분 리스트를 얻는 연산의 시간 복잡도는 _O_(_k_)입니다. 여기서 *k*는 슬라이스의 길이입니다.

`my_list[2:5]`는 3개의 요소를 가진 부분 리스트를 반환합니다. 이 3개의 요소를 새 리스트로 복사하는 데 슬라이스한 배열의 길이 만큼의 시간이 걸립니다.

### 3.3.3 **검색**

리스트 내에서 특정 요소를 찾는 시간 복잡도는 _O_(_n_)입니다. `3 in my_list`는 리스트 전체를 검색하여 3이 포함되어 있는지 확인합니다. 리스트 내에서 요소를 검색할 때 최악의 경우에는 리스트의 모든 요소를 검사해야 할 수 있습니다.

### 3.3.4 마지막 요소 접근

리스트의 끝에서 요소에 접근하는 것도 _O_(1)의 시간 복잡도를 가집니다. _O_(1) `my_list[-1]`은 리스트의 마지막 요소에 바로 접근합니다.

파이썬 리스트는 인덱스가 음수일 경우 리스트의 끝에서부터 요소를 참조합니다. 이 연산도 주소 계산을 통해 바로 해당 인덱스의 위치에 접근하므로 상수 시간이 걸립니다.

# 4. 리스트 메서드

리스트는 다양한 메서드를 제공하여, 데이터를 처리하거나 리스트를 관리하기 편리합니다. 이번 섹션에서는 주요 리스트 메서드를 살펴보겠습니다.

본격적으로 설명하기 전에 파이썬 내장 함수인 `dir()` 를 이용해서 어떤 메서드와 어떤 속성이 있는지 살펴보겠습니다.

```python
print(dir(list))
```

```python
# 출력
['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__','__dir__', '__doc__','__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__','__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__','__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

```

## 4.1 append()

리스트의 끝에 값을 추가합니다.

```python
a = [1, 2, 3]
a.append(10)
print(a)  # 출력: [1, 2, 3, 10]
```

## 4.2 clear()

리스트의 모든 항목을 삭제합니다.

```python
a.clear()
print(a)  # 출력: []
```

## 4.3 copy()

리스트의 얕은 복사를 생성합니다. 즉, 동일한 값을 가진 새로운 리스트를 반환합니다.

```python
a = [1, 2, 3]
b = a.copy()
b[0] = 10000
print(a)  # 출력: [1, 2, 3]
print(b)  # 출력: [10000, 2, 3]
```

여기서 copy를 하지 않으면 아래와 같은 결과가 출력됩니다.

```python
a = [1, 2, 3]
b = a
b[0] = 10000
print(a)  # 출력: [10000, 2, 3]
print(b)  # 출력: [10000, 2, 3]
```

슬라이싱으로 copy와 같은 효과를 발휘할 수 있습니다.

```python
l = [10, 20, 30]
ll = l[:]
print(id(ll), id(l))
l[0] = 1000
print(l, ll) # 출력: [1000, 20, 30] [10, 20, 30]
```

다만 아래와 같은 코드에서는 의도치 않은 코드의 수정이 일어날 수 있습니다.

```python
k = [10000]

a = [10, k]
b = [100, k]

l = [a, b]
ll = l.copy()
# ll = copy.deepcopy(l)
k[0] = 999

print(l)  # 출력: [[10, [999]], [100, [999]]]
print(ll) # 출력: [[10, [999]], [100, [999]]]
```

이럴 경우 copy 모듈을 사용하여 깊은 복사를 통해 해결할 수 있습니다. 깊은 복사는 기존의 값의 모든 참조가 더 이상 이어지지 않는 것입니다. 즉, 이제 l과 ll은 무관합니다.

```python
import copy

k = [10000]

a = [10, k]
b = [100, k]

l = [a, b]
ll = copy.deepcopy(l)
k[0] = 999

print(l)  # 출력: [[10, [999]], [100, [999]]]
print(ll) # 출력: [[10, [10000]], [100, [10000]]]
```

## 4.4 count()

특정 값이 리스트에 몇 번 포함되어 있는지 카운트합니다.

```python
a = [1, 1, 2, 3, 1]
print(a.count(1))  # 출력: 3
```

## 4.5 extend()

리스트에 다른 리스트나 순회 가능한(iterable) 항목들을 추가합니다.

```python
a = [1, 2, 3]
a.extend([4, 5, 6])
print(a)  # 출력: [1, 2, 3, 4, 5, 6]
```

들어가는 값이 이터러블한 객체이기때문에 아래와 같이 활용될 수도 있습니다.

```python
l = [10, 20, 30]
l.extend('hello')
l # 출력: [10, 20, 30, 'h', 'e', 'l', 'l', 'o']
```

```python
l = [10, 20, 30]
ll = ['40', '50', '60']
l.extend(map(int, ll))
l # 출력: [10, 20, 30, 40, 50, 60]
```

## 4.6 index()

주어진 값을 찾아 해당 값의 위치(인덱스)를 반환합니다. str 메서드에서 index와 함께 다뤘던 find 메서드는 리스트에 없습니다.

```python
a = [10, 20, 30, 40]
print(a.index(30))  # 출력: 2
```

## 4.7 insert()

주어진 위치에 값을 삽입합니다.

```python
a.insert(2, 25)
print(a)  # 출력: [10, 20, 25, 30, 40]
```

## 4.8 pop()

리스트의 특정 위치에 있는 값을 반환하고 해당 값을 리스트에서 삭제합니다.

```python
print(a.pop(2))  # 출력: 25
print(a)  # 출력: [10, 20, 30, 40]
```

값을 넣지 않을 경우 마지막에서 값을 뺍니다.

```python
# 마지막에서 빼는 것
l = [10, 20, 30]
print(l.pop())
print(l)
```

아래와 같이 사용되기도 합니다. 여기서 while 구문은 뒤에 리스트가 있을 경우 리스트 안에 값이 있는 동안 반복합니다. 두 예제를 모두 실행해보세요.

```python
l = [1, 2, 3, 4, 5]

while l:
    print(l.pop()) # 5, 4, 3, 2, 1
```

```python
l = [1, 2, 3, 4, 5]

while l:
    print(l.pop(0)) # 1, 2, 3, 4, 5
```

## 4.9 remove()

리스트에서 첫 번째로 발견되는 주어진 값을 삭제합니다.

```python
a = [1, 2, 3, 1, 2]
a.remove(2)
print(a)  # 출력: [1, 3, 1, 2]
```

아래와 같이 모든 요소를 제거할 수 있습니다. 여기서 l.count(2)가 있는 동안 그 아래 들여쓰기 4칸된 코드를 반복하게 됩니다.

```python
l = [1, 2, 3, 1, 2, 2, 2, 1, 1]
while l.count(2):
    l.remove(2)
l
```

다만 위의 방식 보다는 아래 방식을 사용하시는 것을 권합니다.

```python
l = [1, 2, 3, 1, 2, 2, 2, 1, 1]
list(filter(lambda x: x != 2, l))
```

## 4.10 reverse() 및 reversed()

### 4.10.1 reverse()

리스트의 항목들의 순서를 뒤집습니다. 이 메서드는 원래의 리스트를 변경하고, 아무것도 반환하지 않습니다(None을 반환).

```python
a.reverse()
print(a)  # 출력: [2, 1, 3, 1]
```

### 4.10.2 reversed()

역순으로 새로운 이터러블 객체를 반환하는 내장 함수입니다. map이나 zip처럼 메모리 값만 반환하기에 아래 예제에서는 리스트로 형변환을 하였습니다. 원래의 리스트는 변경되지 않습니다.

```python
a = [3, 2, 5, 1, 4]
b = reversed(a)
print(a)        # 출력: [3, 2, 5, 1, 4]
print(list(b))  # 출력: [4, 1, 5, 2, 3]
```

## 4.11 sort() 및 sorted()

### 4.11.1 sort()

`sort()`는 리스트 자체를 정렬합니다. 이 메서드는 원래의 리스트를 변경하고, 아무것도 반환하지 않습니다(None을 반환).

```python
a = [3, 2, 5, 1, 4]
a.sort()
print(a)  # 출력: [1, 2, 3, 4, 5]
```

### 4.11.2 sorted()

`sorted()`는 새로운 리스트를 반환하는 내장 함수입니다. 원래의 리스트는 변경되지 않습니다.

```python
a = [3, 2, 5, 1, 4]
b = sorted(a)
print(a)  # 출력: [3, 2, 5, 1, 4]
print(b)  # 출력: [1, 2, 3, 4, 5]
```
