---
chapter: 05장 리스트, 튜플, 딕셔너리, 셋
title: 05.4 딕셔너리(dict)
date: 2024-01-29
---

# 1. 딕셔너리(Dictionary)란?

파이썬의 딕셔너리는 마치 일상생활에서 사용하는 **사전** 같은 자료형입니다. 사전에는 단어와 그 단어의 뜻이 함께 들어있죠. 파이썬의 딕셔너리도 이와 비슷하게, `키(key)`와 그에 해당하는 `값(value)`이 함께 들어있습니다.

예를 들면, `{'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}`에서 `'name'`은 키이고, `'licat'`은 그에 해당하는 값입니다. 이 딕셔너리의 길이는 3개의 키-값 쌍으로 이루어져 있어요.

이는 어떨때 쓰일까요? 하나의 사람이 등록시에 주민번호와 학번, 제품번호등을 같이 입력하게 된다면 바로바로 필요한 값을 찾을수 있겠죠? 이렇게 저장하게 되면 엑셀처럼 값을 저장하는것이 가능하게 됩니다.

딕셔너리는 이런 키-값 쌍의 형태로 정보를 저장하므로, 특정 정보를 빠르게 찾아내거나 접근할 수 있습니다. 또한 딕셔너리는 키를 기준으로 데이터를 찾기 때문에 키는 **유일**해야 합니다. 즉, 중복된 키를 가질 수 없어요. 그렇지만 값은 중복될 수 있습니다. 만약 중복된 키를 사용하면, 그 키에 해당하는 이전 값은 사라지게 됩니다.

이런 특성 덕분에, 딕셔너리는 파이썬에서 정보를 효율적으로 관리하고 조작하는 데 매우 유용한 자료형입니다.

:::div{.callout}
딕셔너리는 시퀀스 자료형이 아닙니다. 따라서 인덱싱이나 슬라이싱은 가능하지 않습니다. 다만 순서는 있는 자료형입니다. 이 순서가 보장된 것은 불과 4년 밖에 되지 않았습니다. 파이썬 3.6 버전부터 삽입 순서가 보장되었는데요. 이 변경사항은 2016년에 발표되었습니다. 따라서 딕셔너리가 순서가 없다는 말은 3.5 이하 버전에서는 맞지만 3.6 이상 버전에서는 틀린 얘기입니다.

:::

## 1.1 딕셔너리 생성 방법

딕셔너리는 중괄호(`{}`)를 사용하여 생성하며, 키와 값의 쌍으로 구성됩니다. 키와 값 사이에는 콜론(`:`)을 사용하여 구분하고, 각 키-값 쌍은 쉼표(`,`)로 구분합니다.

```python
# 형태
# { key1: value1, key2: value2 }
```

```python
person = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
```

### 1.1.1 빈 딕셔너리,`dict` 함수로 생성

빈 딕셔너리는 중괄호 `{}` 또는 `dict()`를 사용하여 생성할 수 있습니다.

```python
d1 = {}
d2 = dict()

print(type(d1))  # 출력: <class 'dict'>
print(type(d2))  # 출력: <class 'dict'>
```

### 1.1.2 키는 중복될 수 없다

키는 딕셔너리 내에서 유일해야 합니다. 만약 중복된 키로 값을 할당하면 마지막으로 할당된 값만 유지됩니다.

```python
d = {'one' : '하나', 'one' : '하나2', 'one' : '하나3'}
print(d)  # 출력: {'one' : '하나3'}
```

위의 예에서 볼 수 있듯이, 'one'이라는 키에 여러 값을 차례대로 할당했지만 마지막 값인 `하나3`만 유지되었습니다.

### 1.1.3 튜플 리스트로 생성

키와 값을 갖는 튜플의 리스트로 딕셔너리를 생성할 수 있습니다.

```python
d = dict([('one' , '하나'), ('two', '둘')])
print(d)  # 출력: {'one' : '하나', 'two' : '둘'}
```

### 1.1.4 키워드 인자로 생성

키워드 인자를 사용하여 딕셔너리를 생성할 수 있습니다.

```python
d = dict(name='licat', age=10)
print(d)  # 출력: {'name': 'licat', 'age': 10}
```

### 1.1.5 다양한 자료형을 값으로 넣기

다양한 자료형을 값으로 사용할 수 있으며, 키로는 문자열, 숫자, 튜플 등 불변의 자료형을 사용할 수 있습니다.

```python
complex_dict = {
    "numbers": [1, 2, 3],
    42: "answer",
    ("x", "y"): [10, 20],
    True: [100, 200]
}
print(complex_dict["numbers"])  # 출력: [1, 2, 3]
print(complex_dict[42])         # 출력: answer
print(complex_dict[("x", "y")]) # 출력: [10, 20]
print(complex_dict[True])       # 출력: [10, 20]
```

이렇게 다양한 방법으로 딕셔너리를 생성할 수 있습니다. 상황에 맞는 방법을 선택하여 사용하면 됩니다.

## 1.2 딕셔너리 수정 및 중첩

### 1.2.1 딕셔너리 항목 변경 및 추가

딕셔너리의 항목 값을 변경하려면, 해당 키를 이용하여 값을 할당하면 됩니다. 존재하지 않는 키를 이용하여 값을 할당하면, 새로운 키-값 쌍이 추가됩니다.

```python
person = {'name': 'licat', 'city': 'Jeju'}
person['name'] = 'mura'
person['city'] = 'Seoul'

print(person) # 출력: {'name': 'mura', 'city': 'Seoul'}
```

아래와 같이 항목을 추가할 수 있습니다.

```python
person['age'] = 10
print(person) # 출력: {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
```

### 1.2.2 중첩된 딕셔너리

딕셔너리는 다양한 자료형을 값으로 사용할 수 있기 때문에, 딕셔너리 안에 또 다른 딕셔너리를 넣을 수 있습니다. 이를 중첩된 딕셔너리라고 합니다.

```python
users = {
    "leehojun": {"city": "Jeju", "job": "Developer"},
    "licat": {"city": "Seoul", "job": "Designer"}
}
print(users["leehojun"]["job"]) # 출력: Developer
```

:::div{.callout}
중첩된 딕셔너리는 특히 JSON 형식의 데이터를 다룰 때 자주 사용됩니다.
:::

이렇게 딕셔너리는 데이터를 구조화하고 효율적으로 관리하는데 매우 유용한 자료형입니다. 키를 통해 빠르게 값을 검색하거나 수정할 수 있기 때문에 많은 프로그램에서 활용됩니다.

## 1.3 `zip` 함수와 `dict`를 사용한 딕셔너리 생성

앞서 built-in function 챕터에서 살펴본 `zip`은 두 리스트를 서로 짝짓는 함수입니다. `dict`는 그 짝을 딕셔너리로 바꿔줍니다.

예를 들어

```python
keys = ["name", "city", "job"]
values = ["licat", "Jeju", "Developer"]

new_dict = dict(zip(keys, values))
print(new_dict)
```

이 코드는 `keys`의 첫 번째 값 ‘name’과 `values`의 첫 번째 값 ‘licat’을 짝짓고 나머지도 순서대로 짝짓습니다. 그리고 `dict`로 그 짝을 딕셔너리로 바꿔줍니다.

```python
# 출력
{'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
```

`zip`과 `dict`를 이렇게 같이 쓰면 두 리스트를 딕셔너리로 쉽게 합칠 수 있습니다.

# 2. 딕셔너리의 구조 및 특징

이제 딕셔너리의 구조 및 특징을 면밀하게 살펴봅시다.

## 2.1 딕셔너리의 메모리 구조(3.10버전 이하)

딕셔너리의 구현은 내부적으로 해시 테이블을 사용합니다. 해시 테이블은 데이터의 검색, 추가, 삭제를 평균적으로 O(1)의 시간 복잡도로 처리할 수 있는 특징을 가집니다.

### 2.1.1 해시테이블

```python
my_dict = {'name': 'licat', 'age': 10}
```

이 딕셔너리의 메모리 구조는 다음과 같이 설명될 수 있습니다:

1. 'name' 및 'age'라는 키는 해시 함수를 통해 해시 테이블의 특정 위치로 변환됩니다.
2. 해당 위치에는 키와 값이 저장됩니다. 예를 들어 'name': 'licat'이라는 키-값 쌍이 저장됩니다.

파이썬 3.10 이하버전에서의 해시테이블을 시각화하면 아래와 같이 생겼습니다.

![](/images/python/chapter05/04-1.png)

배열에서 name을 검색하고 싶을 경우 모든 key값을 비교해야 하므로 O(N)의 시간이 걸리지만 해시 테이블을 이용하게 된다면 해시 함수를 이용해서 해시 값을 한번만 계산하면 되므로 O(1)만에 찾을 수 있게 됩니다.

:::div{.callout}
**알아두어야 할 것**  
해시 테이블은 효율적인 검색을 위해 설계되었지만, 버킷(Bucket)을 추가적으로 할당해주어야 하므로 메모리 공간을 약간 더 사용하는 경향이 있습니다. 이는 빠른 검색 시간을 위한 trade-off입니다.

:::

## 2.2 딕셔너리의 메모리 구조(3.11버전 이상)

3.11버전 이후부터 딕셔너리의 메모리 접근 방법이 변경되었습니다.

## 2.3 딕셔너리의 특징

### 2.3.1 키의 유일성

딕셔너리의 키는 고유해야 합니다. 중복된 키를 가진 항목을 추가하면 기존의 값을 덮어씁니다.

### 2.3.2 순서 유지

파이썬 3.7부터 딕셔너리는 항목을 삽입한 순서를 유지합니다. 이는 내부적으로 이중 연결 리스트(double linked list)를 사용하여 구현됩니다.

### 2.3.3 다양한 데이터 타입

딕셔너리의 키는 해싱이 가능한(즉, 변경 불가능한) 타입이어야 합니다. 문자열, 숫자, 튜플 등이 키로 사용될 수 있습니다. 값은 어떤 데이터 타입도 가능합니다.

### 2.3.4 동적 크기

딕셔너리는 필요에 따라 동적으로 크기가 조정됩니다. 따라서 항목을 추가하거나 삭제할 때 크기에 대해 걱정할 필요가 없습니다.

### 2.3.5 효율적인 검색

딕셔너리는 해시 테이블을 기반으로 하기 때문에, 키를 사용한 데이터 검색이 매우 빠릅니다.

딕셔너리는 파이썬에서 데이터를 효율적으로 관리하기 위한 중요한 도구입니다. 키-값 쌍의 형태로 데이터를 저장하므로, 데이터 검색 및 관리가 쉽고 빠릅니다.

# 3. 딕셔너리의 메서드

딕셔너리의 메서드를 `dir()` 메서드를 이용해서 확인해봅시다.

```python
print(dir(dict))
```

```python
# 출력

['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__xor__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
```

## 3.1 clear()

`clear` 메서드는 딕셔너리의 모든 키-값 쌍을 삭제합니다.

```python
data = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
data.clear()
print(data)
```

```python
# 출력
{}
```

## 3.2 copy()

`copy` 메서드는 딕셔너리의 얕은 복사본을 반환합니다.

```python
person = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
copied_person = person.copy()
print(copied_person)
```

```python
# 출력
{'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
```

## 3.3 fromkeys( )

`fromkeys` 메서드를 사용하면 시퀀스 자료형을 기반으로 딕셔너리를 생성할 수 있습니다.

```python
keys = ['name', 'city', 'job']
value = None
print(dict.fromkeys(keys, value))
```

```python
# 출력
{'name': None, 'city': None, 'job': None}
```

아래처럼 iterable한 객체를 넣어 생성할 수 있을 것이라 기대하면 안됩니다.

```python
keys = ['name', 'city', 'job']
value = ['licat', 'Jeju', 'Developer']
print(dict.fromkeys(keys, value))
```

```python
# 출력
{'name': ['licat', 'Jeju', 'Developer'],
'city': ['licat', 'Jeju', 'Developer'],
'job': ['licat', 'Jeju', 'Developer']}
```

## 3.4 get( )

딕셔너리에서는 존재하지 않는 키를 직접 접근하면 오류가 발생합니다. 딕셔너리에서 에러없이 값을 추출하려면 `get` 메서드를 활용합니다. 만약 해당 키가 없을 경우에는 None을 반환하지만 두번째 인자에 값을 넣어 기본값을 반환할 수도 있습니다.

```python
my_list.get('key', 'default(선택)')
# key값을 찾을건데, 없으면 default값에 들어간 값으로 알려줘 라는 뜻입니다.
```

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
print(numbers.get('four'))
print(numbers.get('three', '없음'))
print(numbers.get('four', '없음'))
print(numbers['four'])
```

```python
# 출력
None
셋
없음
KeyError: 'four'
```

만약 아래와 같은 코드로 작성이 되어 있다고 한다면 이는 get 메서드를 수정하여 수정할 수 있습니다.

```python
def 요일변경(n):
    return {
        1: '월요일',
        2: '화요일',
        3: '수요일',
        4: '목요일',
        5: '금요일',
        6: '토요일',
        7: '일요일',
    }[n]

요일변경(3) # 출력: 수요일
# 요일변경(8) # error
```

```python
def 요일변경(n):
    return {
        1: '월요일',
        2: '화요일',
        3: '수요일',
        4: '목요일',
        5: '금요일',
        6: '토요일',
        7: '일요일',
    }.get(n, '')

요일변경(3)
print(요일변경(8))
print(요일변경(8))
```

## 3.5 items( )

딕셔너리의 키와 값을 쌍으로 추출하려면 `items` 메서드를 사용합니다. 반환되는 결과는 `dict_items` 객체입니다. 이 객체는 인덱싱이 안되니 인덱싱을 하고 싶다면 list로 변환 후 사용해주세요.

```python
person = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
print(person.items())
```

```python
dict_items([('name', 'licat'), ('city', 'Jeju'), ('job', 'Developer')])
```

또한, 딕셔너리에서 특정 키의 존재 여부를 확인하려면 `in` 연산자를 활용합니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
print('one' in numbers)
print('four' in numbers)
```

```python
# 출력
True
False
```

만약 특정 값이 존재하는지 확인하고 싶다면 values 메서드를 사용하고 반환된 객체에서 in 연산자를 사용해야 합니다.

## 3.6 keys( )

`keys()` 메서드는 딕셔너리의 모든 키를 추출하려고 할 때 사용합니다. 반환되는 결과는 `dict_keys` 객체입니다. 이 객체는 리스트와 유사하게 작동하지만, 리스트의 메서드를 모두 지원하는 것은 아닙니다. 하지만 반복문과 함께 사용하여 키들을 순회할 수 있습니다.

```python
person = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
print(person.keys())
```

```python
# 출력
dict_keys(['name', 'city', 'job'])
```

:::div{.callout}
`dict_keys` 객체를 리스트로 변환하려면, `list()` 함수를 사용하면 됩니다. 예를 들어, `list(person.keys())` 는 `['name', 'city', 'job']`을 반환합니다. 이를 통해 리스트의 메서드를 활용하여 추가적인 처리나 변경을 수행할 수 있습니다.

:::

## 3.7 pop( )

`pop` 메서드는 주어진 키의 값을 반환하고, 해당 키-값 쌍을 딕셔너리에서 삭제합니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
one_value = numbers.pop('one')
print(one_value)
print(numbers)
```

```python
# 출력
하나
{'two': '둘', 'three': '셋'}
```

아래와 같이 아무것도 없는 값을 pop하게 되면 error가 출력됩니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
numbers.pop() # error
numbers
```

## 3.8 popitem()

`popitem` 메서드는 딕셔너리의 마지막 키-값 쌍을 반환하고, 그 항목을 삭제합니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
item = numbers.popitem()
print(item)
print(numbers)
```

```python
# 출력
('three', '셋')
{'one': '하나', 'two': '둘'}
```

## 3.9 setdefault()

`setdefault` 메서드는 주어진 키에 대한 값을 반환합니다. 키가 없으면 기본값을 설정하고 반환합니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
four_value = numbers.setdefault("four", "넷")
print(four_value)
print(numbers)
```

```python
# 출력
넷
{'one': '하나', 'two': '둘', 'three': '셋', 'four': '넷'}
```

아래처럼 이미 dict에 있는 값일 경우 반영되지 않습니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
four_value = numbers.setdefault("three", 3) # 3이 반영되지 않습니다.
print(four_value)
print(numbers)
```

```python
# 출력
셋
{'one': '하나', 'two': '둘', 'three': '셋'}
```

## 3.10 update( )

기존 딕셔너리에 추가 데이터를 병합하려면 `update` 메서드를 사용합니다.

```python
numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
numbers.update({'four': '넷', 'five': '다섯'})
print(numbers)
```

```python
# 출력
{'one': '하나', 'two': '둘', 'three': '셋', 'four': '넷', 'five': '다섯'}
```

## 3.11 values( )

`values()` 메서드는 딕셔너리에서 값들만 추출하려 할 때 사용됩니다. 이 메서드의 반환값은 `dict_values` 객체입니다. 이 객체도 `dict_keys`와 마찬가지로 리스트와 유사하게 작동하지만, 리스트의 메서드를 모두 지원하는 것은 아닙니다. 그럼에도 불구하고, `dict_values` 객체는 반복문과 함께 사용하여 순회할 수 있습니다.

```python
person = {'name': 'licat', 'city': 'Jeju', 'job': 'Developer'}
print(person.values())
```

```python
# 출력
dict_values(['licat', 'Jeju', 'Developer'])
```

:::div{.callout}
`dict_values` 객체를 리스트로 변환하려면, 마찬가지로 `list()` 함수를 사용하면 됩니다. 예를 들어, `list(person.values())` 는 `['licat', 'Jeju', 'Developer']`을 반환합니다.

:::
