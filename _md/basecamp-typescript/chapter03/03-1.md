---
chapter: 타입스크립트 추가 문법
title: 고급 타입
date: 2024-11-14
---

# 1. 고급 타입

## 1.1 제네릭

제네릭을 사용하면 타입을 마치 함수의 파라미터처럼 사용할 수 있습니다. 마치 데이터를 하나의 변수처럼 취급하는 것입니다. 제네릭은 함수, 클래스, 인터페이스 등에서 사용할 수 있습니다. 이렇게 사용하면 외부에서 타입을 지정할 수 있어 재사용성이 높아집니다. 

### 1.1.1 제네릭 함수

여기서 함수 `getValue`는 제네릭 타입 `T`를 사용합니다. `T`는 Type parameter의 약자입니다. 여기서 꼭 `T`를 사용할 필요는 없습니다. 다른 문자를 사용해도 됩니다. 아래 코드를 작성하고 `T`를 다른 글자로 바꿔보세요.

```tsx
function getValue<T>(value: T): T {
  return value;
}

const numberValue = getValue<number>(123);  // number 타입
const stringValue = getValue<string>("hello");  // string 타입

console.log(numberValue);
console.log(stringValue);
```

:::div{.callout}
💡 **제네릭을 사용하는데 꼭 T를 사용해야 하나요?**

다른 문자를 사용해도 되지만 관례상 `T`를 사용합니다. 다만 `T` 대신 명확한 타입 이름을 사용하는 것이 코드의 가독성을 높일 수 있습니다. 예를 들어, `interface Licat<MPType>`, `Licat<StatusType>` 와 같은 형식으로도 사용할 수 있습니다.
:::

여기서 `getValue<number>(123);`로 호출하면 `T`가 `number`로 대체되어 `function getValue<number>(value: number): number`와 같은 형태가 됩니다. 실제로는 `function getValue(value: number): number`와 같은 형태가 됩니다.

좀 더 간단하게 사용하려면 `<>` 안에 타입을 지정하지 않아도 됩니다.

```tsx
function getValue<T>(value: T) {
  return value;
}

const numberValue = getValue(123);  // number 타입
const stringValue = getValue("hello");  // string 타입

console.log(numberValue);
console.log(stringValue);
```

이렇게 사용하면 TypeScript가 타입을 추론하여 `number`와 `string` 타입으로 지정합니다. return 값 또한 추론된 타입으로 반환됩니다.

### 1.1.2 제네릭 인터페이스

제네릭을 함수에서만 사용할 수 있는 것이 아닙니다. 인터페이스에서도 사용할 수 있습니다.

```tsx
// 예제1
interface Container<T> {
    value: T;
}

const numberContainer: Container<number> = { value: 10 };
const stringContainer: Container<string> = { value: "hello" };

console.log(numberContainer.value); // 10
console.log(stringContainer.value); // hello
```

```tsx
// 예제2
interface ApiResponse<T> {
  status: number;
  data: T;
  error?: string;
}

interface UserData {
  id: number;
  name: string;
}

const response: ApiResponse<UserData> = {
  status: 200,
  data: {
    id: 1,
    name: "홍길동"
  }
};
```

예제 1은 인터페이스를 정의하고 제네릭을 사용하였습니다. 간단하게 변수 하나를 가지고 있으며, 해당 변수는 제네릭으로 받은 타입을 가지고 있습니다. 예제 2는 조금 다릅니다. 인터페이스에 제네릭은 모든 변수에 적용되는 것이 아니라 특정 변수에 적용하였습니다.

이번에는 여러개의 인터페이스를 연결할 때 제네릭을 어떻게 사용하는지 살펴보도록 하겠습니다. 여기서 `U`라는 키워드를 사용했는데 이는 추가적인 타입이 필요할 때 사용하는 것으로 `T`와 같은 역할을 합니다. `S`도 관례상 많이 사용합니다.

```tsx
interface Cat<T> {
    name: T;
    age: number;
}

interface Licat<U> extends Cat<string> {
    hp: number;
    mp: U;
}

// mp를 number 타입으로 지정
const licat: Licat<number> = {
    name: "licat",
    age: 3,
    hp: 100,
    mp: 50
};

// mp를 string 타입으로 지정
const licat_bot: Licat<string> = {
    name: "licat_bot",
    age: 3,
    hp: 100,
    mp: "high"
};
```

아래와 같이 여러개의 제네릭 타입을 사용할 수도 있습니다.

```tsx
interface Cat<T> {
    name: T;
    age: number;
}

interface Licat<T, U> extends Cat<T> {
    hp: number;
    mp: U;
}

const licat: Licat<string, number> = {
    name: "licat",
    age: 3,
    hp: 100,
    mp: 50
};

const licat_bot: Licat<number, string> = {
    name: 1,  // name이 number 타입
    age: 3,
    hp: 100,
    mp: "high"
};
```

아래와 같이 인터페이스, class와 함께 사용할 수도 있습니다.

```tsx
interface Container<T> {
    value: T;
    getValue(): T;
}

class StringContainer implements Container<string> {
    value: string;
    
    constructor(value: string) {
        this.value = value;
    }
    
    getValue(): string {
        return this.value;
    }
}

const s = new StringContainer("hello");
console.log(s.getValue()); // hello
```


### 1.1.3 제네릭 클래스

클래스에서도 사용할 수 있습니다. 여기서 배열을 사용하는 Queue 클래스를 제네릭으로 만들어보겠습니다.

```ts
class Queue<T> {
    private data: T[] = [];
    
    push(item: T) {
        this.data.push(item);
    }
    
    pop(): T | undefined {
        return this.data.shift();
    }
}

const numberQueue = new Queue<number>();
numberQueue.push(10);  // OK
numberQueue.push("10"); // 에러: string 타입은 number 타입에 할당할 수 없습니다
```

### 1.1.4 제네릭 사용 시 고려사항

제네릭을 사용할 때 몇 가지 주의사항이 있습니다.

```ts
// 안좋은 예
function printValue<T>(value: T): void {
    console.log(value);
}

// 좋은 예
function printValue(value: any): void {
    console.log(value);
}
```

위 코드는 제네릭을 사용할 필요가 없습니다. `any` 타입을 사용하면 어떤 타입이든 받을 수 있기 때문입니다. 이렇게 하면 '제네릭을 사용할 필요가 없겠다'라고 생각을 할 수 있습니다. 아래와 같은 경우를 가정해보겠습니다.

```ts
function addNumber(a: number, b: number): number {
    return a + b;
}

function addString(a: string, b: string): string {
    return a + b;
}
```

만약 이 2개의 함수를 합치고 싶었다고 가정해보도록 하겠습니다. 

```ts
function add(a: any, b: any): any {
    return a + b;
}
```

이렇게 하면 `add` 함수는 어떤 타입이든 받을 수 있지만, 반환값은 `any` 타입이 됩니다. 이렇게 하면 타입 안정성이 떨어지게 됩니다. 이런 경우에 제네릭을 사용하면 됩니다.

```ts
function add<T>(a: T, b: T): T {
    return a + b;
}

const result = add<number>(1, 2); // number 타입
const result2 = add<string>("hello", "world"); // string 타입
```

이렇게 하면 `add` 함수는 어떤 타입이든 받을 수 있고, 반환값도 받은 타입으로 반환됩니다.


## 1.2 Enum

상수 집합을 정의할 때 사용하는 타입입니다. 다른 언어에서도 종종 사용되며, 주로 숫자나 문자열 값으로 이루어진 집합을 정의할 때 사용합니다.

### 1.2.1 숫자형 Enum
```tsx
enum Direction {
  Up = 1,
  Down,  // 2
  Left,  // 3
  Right  // 4
}

console.log(Direction.Up); // 1
```

### 1.2.2 문자열 Enum
```tsx
enum Status {
  Active = "ACTIVE",
  Inactive = "INACTIVE",
  Pending = "PENDING"
}

console.log(Status.Active); // ACTIVE
```

## 1.3 유틸리티 타입

TypeScript에서 제공하는 유용한 타입 변환 도구들입니다.

### 1.3.1 Partial

모든 속성을 선택적으로 만듭니다.

```tsx
interface Todo {
  title: string;
  description: string;
}

// 모든 필드가 선택적인 타입이 됨
type PartialTodo = Partial<Todo>;

const todo: PartialTodo = {
  title: "할 일"
};

// 모든 필드가 선택적이므로 빈 객체도 가능
const emptyTodo: PartialTodo = {};

console.log(todo);
console.log(emptyTodo);
```

### 1.3.2 Pick

특정 속성만 선택합니다.

```tsx
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

// title과 completed만 가지는 타입
type TodoPreview = Pick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "할 일",
  completed: false
};

console.log(todo);
```

### 1.3.3 Omit

특정 속성을 제외합니다.

```tsx
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoWithoutDescription = Omit<Todo, "description">;

const todo: TodoWithoutDescription = {
  title: "할 일",
  completed: false
};

console.log(todo);
```

## 1.4 unknown 타입

`unknown`은 타입 안전성을 강화한 `any` 타입입니다. 타입을 확정하기 전까지는 값을 사용할 수 없습니다.

```tsx
let value: unknown = 4;
value = "hello";

// 타입 검사 없이 사용 불가
// console.log(value.length); // 에러!

// 타입 검사 후 사용 가능
if (typeof value === "string") {
    console.log(value.length); // 정상 동작
}
```

## 1.5 타입 가드

타입 가드를 사용하면 특정 스코프 내에서 타입을 보장할 수 있습니다. "이 객체가 특정 타입인지 확인하고, 맞다면 TypeScript에게 그 사실을 알려주는" 방법이라고 생각하시면 됩니다.

### 1.5.1 typeof 타입 가드

typeof는 JavaScript의 typeof처럼 Array를 Object로 반환합니다. 따라서 객체를 취급할 때에는 주의해야 합니다.

```tsx
function processValue(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase(); // string으로 타입 보장
    }
    return value.toFixed(2); // number로 타입 보장
}
```

### 1.5.2 instanceof 타입 가드

```tsx
class Dog {
    bark() { return "Woof!"; }
}

class Cat {
    meow() { return "Meow!"; }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        return animal.bark();
    }
    return animal.meow();
}

const dog = new Dog();
const cat = new Cat();

console.log(makeSound(dog)); // Woof!
console.log(makeSound(cat)); // Meow!
```

### 1.5.3 사용자 정의 타입 가드

```tsx
interface Fish {
    swim(): void;
}

interface Bird {
    fly(): void;
}

function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
    if (isFish(pet)) {
        pet.swim();
    } else {
        pet.fly();
    }
}

const fish = {
    swim: () => console.log("물고기가 헤엄칩니다.")
};

const bird = {
    fly: () => console.log("새가 날아갑니다.")
};

move(fish); // "물고기가 헤엄칩니다 🐠"
move(bird); // "새가 날아갑니다 🐦"
```

`pet is Fish`는 TypeScript의 타입 술어(Type Predicate)로, 함수가 true를 반환할 때 해당 매개변수가 Fish 타입이라는 것을 TypeScript에게 알려주는 역할을 합니다. 쉽게 말해서, `이 조건이 참이면 pet은 Fish 타입이다`라고 TypeScript의 타입 시스템에게 알려주는 것입니다.

`(pet as Fish).swim !== undefined`는 타입 단언(Type Assertion)을 사용한 코드입니다. pet 객체를 Fish 타입이라고 가정(타입 단언)하고, swim이라는 메서드가 존재하는지 확인합니다. 만약 swim 메서드가 존재한다면 true를 반환하여 이 객체가 Fish 타입이라고 판단합니다. 즉, "물고기라면 반드시 가지고 있어야 할 swim 메서드가 있는지 확인"하는 것입니다.


## 1.6 맵드 타입

맵드 타입(Mapped Types)은 기존 타입의 모든 속성을 새로운 규칙에 따라 변환하여 새로운 타입을 만드는 방법입니다. 마치 배열의 map 함수처럼, 타입의 각 속성을 다른 형태로 변환할 수 있습니다.

### 1.6.1 기본 개념

```typescript
// 기본 인터페이스
interface User {
    name: string;    // 필수
    age: number;     // 필수
    email: string;   // 필수
}

// 모든 속성을 선택적(optional)으로 만드는 맵드 타입
type Optional<T> = {
    [P in keyof T]?: T[P];
};

// 사용 예시
type OptionalUser = Optional<User>;

// OptionalUser는 다음과 같은 형태가 됩니다:
// {
//     name?: string;    // 선택적
//     age?: number;     // 선택적
//     email?: string;   // 선택적
// }

// 실제 사용
const user1: User = {
    name: "licat",     // 모든 속성이 필수
    age: 10,
    email: "kim@mail.com"
};

const user2: OptionalUser = {
    name: "mura"      // 일부 속성만 사용 가능
};  // OK! - age와 email이 선택적이므로 생략 가능
```

### 1.6.2 자주 사용하는 맵드 타입 예시

```typescript
// 1. 모든 속성을 읽기 전용으로 만들기
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

// 2. 모든 속성을 필수로 만들기
type Required<T> = {
    [P in keyof T]-?: T[P];  // -?는 선택적 속성을 제거
};

// 3. 속성 이름에 접두사 추가하기
type Prefixed<T> = {
    ['pre_' + P in keyof T]: T[P];
};

// 사용 예시
interface Product {
    name: string;
    price: number;
}

// 읽기 전용 제품 타입
type ReadonlyProduct = Readonly<Product>;
const product: ReadonlyProduct = {
    name: "노트북",
    price: 1000000
};
// product.price = 900000;  // 에러! 읽기 전용 속성이므로 수정 불가

// 접두사가 붙은 제품 타입
type PrefixedProduct = Prefixed<Product>;
// {
//     pre_name: string;
//     pre_price: number;
// }
```

# 2. 연습문제

1. 다음 요구사항에 맞는 제네릭 함수를 작성해보세요.
  * 배열을 입력받아 첫 번째 요소를 반환하는 함수
  * 배열이 비어있으면 undefined 반환
  * 모든 타입의 배열에 대해 동작해야 함

2. 아래 인터페이스를 기반으로 유틸리티 타입을 활용해보세요.
```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  category: string;
}

// 1. 제품 생성 시 필요한 타입 (id 제외)
// 2. 제품 수정 시 필요한 타입 (모든 필드 선택적)
// 3. 제품 목록 표시용 타입 (id, name, price만 포함)
```

3. 다음과 같은 맵드 타입을 구현해보세요.
   - 모든 속성을 읽기 전용으로 만드는 `Readonly<T>` 구현
   - 모든 속성을 필수로 만드는 `Required<T>` 구현

4. 다음 코드에 타입 가드를 추가해보세요.
```tsx
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

// 도형의 면적을 계산하는 함수를 작성하세요.
function calculateArea(shape: Shape): number {
    // 여기에 구현
}
```

# 3. 연습문제 정답

1. 배열의 첫 번째 요소를 반환하는 제네릭 함수

```typescript
function getFirstElement<T>(array: T[]): T | undefined {
    return array.length > 0 ? array[0] : undefined;
}

// 사용 예시
const numbers = [1, 2, 3];
const firstNumber = getFirstElement(numbers); // 타입: number | undefined

const strings = ["a", "b", "c"];
const firstString = getFirstElement(strings); // 타입: string | undefined

const empty: number[] = [];
const noElement = getFirstElement(empty); // 타입: number | undefined, 값: undefined
```

2. Product 인터페이스 기반 유틸리티 타입

```typescript
interface Product {
    id: number;
    name: string;
    price: number;
    description: string;
    category: string;
}

// 1) 제품 생성 시 필요한 타입 (id 제외)
type CreateProductDTO = Omit<Product, "id">;

// 2) 제품 수정 시 필요한 타입 (모든 필드 선택적)
type UpdateProductDTO = Partial<Product>;

// 3) 제품 목록 표시용 타입 (id, name, price만 포함)
type ProductListItem = Pick<Product, "id" | "name" | "price">;

// 사용 예시
const newProduct: CreateProductDTO = {
    name: "노트북",
    price: 1000000,
    description: "최신 노트북",
    category: "전자기기"
};

const updateProduct: UpdateProductDTO = {
    price: 1200000,
    description: "최신 고성능 노트북"
};

const listItem: ProductListItem = {
    id: 1,
    name: "노트북",
    price: 1000000
};
```

3. 맵드 타입 구현

```typescript
// Readonly<T> 구현
type MyReadonly<T> = {
    readonly [P in keyof T]: T[P];
};

// Required<T> 구현
type MyRequired<T> = {
    [P in keyof T]-?: T[P];
};

// 사용 예시
interface User {
    name?: string;
    age?: number;
}

type ReadonlyUser = MyReadonly<User>;  // 모든 속성이 readonly
type RequiredUser = MyRequired<User>;   // 모든 속성이 필수

// 타입 검증
const readonlyUser: ReadonlyUser = {
    name: "John",
    age: 30
};
// readonlyUser.name = "Jane"; // 에러: readonly 속성이므로 수정 불가

const requiredUser: RequiredUser = {
    name: "John",
    age: 30
    // 모든 속성을 반드시 지정해야 함
};
```

4. 도형의 면적을 계산하는 함수 (타입 가드 사용)

```typescript
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

// 타입 가드 함수들
function isSquare(shape: Shape): shape is Square {
    return shape.kind === "square";
}

function isRectangle(shape: Shape): shape is Rectangle {
    return shape.kind === "rectangle";
}

function isCircle(shape: Shape): shape is Circle {
    return shape.kind === "circle";
}

function calculateArea(shape: Shape): number {
    if (isSquare(shape)) {
        return shape.size * shape.size;
    }
    
    if (isRectangle(shape)) {
        return shape.width * shape.height;
    }
    
    if (isCircle(shape)) {
        return Math.PI * shape.radius * shape.radius;
    }
    
    // 모든 케이스를 처리했지만, TypeScript의 타입 체크를 위해 필요
    const unreachable: never = shape;
    throw new Error(`Unhandled shape type: ${unreachable}`);
}

// 사용 예시
const square: Square = { kind: "square", size: 5 };
const rectangle: Rectangle = { kind: "rectangle", width: 4, height: 6 };
const circle: Circle = { kind: "circle", radius: 3 };

console.log(calculateArea(square));    // 25
console.log(calculateArea(rectangle)); // 24
console.log(calculateArea(circle));    // 약 28.27
```