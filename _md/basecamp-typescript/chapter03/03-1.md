---
chapter: 타입스크립트 추가 문법
title: 고급 타입
date: 2024-11-14
---

# 1. 고급 타입

## 1.1 제네릭

제네릭을 사용하면 타입을 마치 함수의 파라미터처럼 사용할 수 있습니다. 제네릭은 함수, 클래스, 인터페이스 등에서 사용할 수 있습니다. 외부에서 타입을 지정할 수 있어 재사용성이 높아집니다. 데이터를 하나의 변수로 취급하여 전달할 수 있습니다.

### 1.1.1 제네릭 함수

여기서 함수 `getValue`는 제네릭 타입 `T`를 사용합니다. `T`는 Type parameter의 약자입니다.

```tsx
function getValue<T>(value: T): T {
  return value;
}

const numberValue = getValue<number>(123);  // number 타입
const stringValue = getValue<string>("hello");  // string 타입
```

여기서 `getValue<number>(123);`로 호출하면 `T`가 `number`로 대체되어 `function getValue<number>(value: number): number`와 같은 형태가 됩니다. 실제로는 `function getValue(value: number): number`와 같은 형태가 됩니다.

좀 더 간단하게 사용하려면 `<>` 안에 타입을 지정하지 않아도 됩니다.

```tsx
function getValue<T>(value: T) {
  return value;
}

const numberValue = getValue(123);  // number 타입
const stringValue = getValue("hello");  // string 타입

console.log(numberValue);
console.log(stringValue);
```

이렇게 사용하면 TypeScript가 타입을 추론하여 `number`와 `string` 타입으로 지정합니다. return 값 또한 추론된 타입으로 반환됩니다.

### 1.1.2 제네릭 인터페이스

제네릭을 함수에서만 사용할 수 있는 것이 아닙니다. 인터페이스에서도 사용할 수 있습니다.

```tsx
interface ApiResponse<T> {
  status: number;
  data: T;
  error?: string;
}

interface UserData {
  id: number;
  name: string;
}

const response: ApiResponse<UserData> = {
  status: 200,
  data: {
    id: 1,
    name: "홍길동"
  }
};
```

아래와 같이 class와 함께 사용할 수 있습니다.

```tsx
interface Container<T> {
    value: T;
    getValue(): T;
}

class StringContainer implements Container<string> {
    value: string;
    
    constructor(value: string) {
        this.value = value;
    }
    
    getValue(): string {
        return this.value;
    }
}
```

### 1.1.3 제네릭 클래스

클래스에서도 사용할 수 있ㅅ브니다. 여기서 배열을 사용하는 Queue 클래스를 제네릭으로 만들어보겠습니다.

```ts
class Queue<T> {
    private data: T[] = [];
    
    push(item: T) {
        this.data.push(item);
    }
    
    pop(): T | undefined {
        return this.data.shift();
    }
}

const numberQueue = new Queue<number>();
numberQueue.push(10);  // OK
numberQueue.push("10"); // 에러: string 타입은 number 타입에 할당할 수 없습니다
```

### 1.1.4 제네릭 사용 시 고려사항

제네릭을 사용할 때 몇 가지 주의사항이 있습니다.

```ts
// 안좋은 예
function printValue<T>(value: T): void {
    console.log(value);
}

// 좋은 예
function printValue(value: any): void {
    console.log(value);
}
```

위 코드는 제네릭을 사용할 필요가 없습니다. `any` 타입을 사용하면 어떤 타입이든 받을 수 있기 때문입니다.


## 1.2 Enum

상수 집합을 정의할 때 사용하는 타입입니다.

### 1.2.1 숫자형 Enum
```tsx
enum Direction {
  Up = 1,
  Down,  // 2
  Left,  // 3
  Right  // 4
}
```

### 1.2.2 문자열 Enum
```tsx
enum Status {
  Active = "ACTIVE",
  Inactive = "INACTIVE",
  Pending = "PENDING"
}
```

## 1.3 유틸리티 타입

TypeScript에서 제공하는 유용한 타입 변환 도구들입니다.

### 1.3.1 Partial
모든 속성을 선택적으로 만듭니다.
```tsx
interface Todo {
  title: string;
  description: string;
}

// 모든 필드가 선택적인 타입이 됨
type PartialTodo = Partial<Todo>;
```

### 1.3.2 Pick
특정 속성만 선택합니다.
```tsx
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

// title과 completed만 가지는 타입
type TodoPreview = Pick<Todo, "title" | "completed">;
```

### 1.3.3 Omit
특정 속성을 제외합니다.
```tsx
type TodoWithoutDescription = Omit<Todo, "description">;
```

## 1.4 unknown 타입

`unknown`은 타입 안전성을 강화한 `any` 타입입니다. 타입을 확정하기 전까지는 값을 사용할 수 없습니다.

```tsx
let value: unknown = 4;
value = "hello";

// 타입 검사 없이 사용 불가
// console.log(value.length); // 에러!

// 타입 검사 후 사용 가능
if (typeof value === "string") {
    console.log(value.length); // 정상 동작
}
```

## 1.5 타입 가드

타입 가드를 사용하면 특정 스코프 내에서 타입을 보장할 수 있습니다.

### 1.5.1 typeof 타입 가드
```tsx
function processValue(value: string | number) {
    if (typeof value === "string") {
        return value.toUpperCase(); // string으로 타입 보장
    }
    return value.toFixed(2); // number로 타입 보장
}
```

### 1.5.2 instanceof 타입 가드
```tsx
class Dog {
    bark() { return "Woof!"; }
}

class Cat {
    meow() { return "Meow!"; }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        return animal.bark();
    }
    return animal.meow();
}
```

### 1.5.3 사용자 정의 타입 가드
```tsx
interface Fish {
    swim(): void;
}

interface Bird {
    fly(): void;
}

function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

function move(pet: Fish | Bird) {
    if (isFish(pet)) {
        pet.swim();
    } else {
        pet.fly();
    }
}
```

## 1.6 맵드 타입

기존 타입을 기반으로 새로운 타입을 생성할 수 있습니다.

```tsx
type Optional<T> = {
    [P in keyof T]?: T[P];
};

interface User {
    name: string;
    age: number;
}

// 모든 속성이 선택적인 새로운 타입
type OptionalUser = Optional<User>;
```

# 2. 연습문제

1. 다음 요구사항에 맞는 제네릭 함수를 작성해보세요.
  * 배열을 입력받아 첫 번째 요소를 반환하는 함수
  * 배열이 비어있으면 undefined 반환
  * 모든 타입의 배열에 대해 동작해야 함

2. 아래 인터페이스를 기반으로 유틸리티 타입을 활용해보세요.
```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  category: string;
}

// 1. 제품 생성 시 필요한 타입 (id 제외)
// 2. 제품 수정 시 필요한 타입 (모든 필드 선택적)
// 3. 제품 목록 표시용 타입 (id, name, price만 포함)
```

3. 다음과 같은 맵드 타입을 구현해보세요.
   - 모든 속성을 읽기 전용으로 만드는 `Readonly<T>` 구현
   - 모든 속성을 필수로 만드는 `Required<T>` 구현

4. 다음 코드에 타입 가드를 추가해보세요.
```tsx
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

// 도형의 면적을 계산하는 함수를 작성하세요.
function calculateArea(shape: Shape): number {
    // 여기에 구현
}
```

:::div{.callout}
💡 타입 가드와 맵드 타입은 TypeScript의 고급 기능이지만, 타입 안전성을 높이고 코드의 재사용성을 향상시키는 데 매우 유용합니다.
:::

# 3. 연습문제 정답

1. 배열의 첫 번째 요소를 반환하는 제네릭 함수

```typescript
function getFirstElement<T>(array: T[]): T | undefined {
    return array.length > 0 ? array[0] : undefined;
}

// 사용 예시
const numbers = [1, 2, 3];
const firstNumber = getFirstElement(numbers); // 타입: number | undefined

const strings = ["a", "b", "c"];
const firstString = getFirstElement(strings); // 타입: string | undefined

const empty: number[] = [];
const noElement = getFirstElement(empty); // 타입: number | undefined, 값: undefined
```

2. Product 인터페이스 기반 유틸리티 타입

```typescript
interface Product {
    id: number;
    name: string;
    price: number;
    description: string;
    category: string;
}

// 1) 제품 생성 시 필요한 타입 (id 제외)
type CreateProductDTO = Omit<Product, "id">;

// 2) 제품 수정 시 필요한 타입 (모든 필드 선택적)
type UpdateProductDTO = Partial<Product>;

// 3) 제품 목록 표시용 타입 (id, name, price만 포함)
type ProductListItem = Pick<Product, "id" | "name" | "price">;

// 사용 예시
const newProduct: CreateProductDTO = {
    name: "노트북",
    price: 1000000,
    description: "최신 노트북",
    category: "전자기기"
};

const updateProduct: UpdateProductDTO = {
    price: 1200000,
    description: "최신 고성능 노트북"
};

const listItem: ProductListItem = {
    id: 1,
    name: "노트북",
    price: 1000000
};
```

3. 맵드 타입 구현

```typescript
// Readonly<T> 구현
type MyReadonly<T> = {
    readonly [P in keyof T]: T[P];
};

// Required<T> 구현
type MyRequired<T> = {
    [P in keyof T]-?: T[P];
};

// 사용 예시
interface User {
    name?: string;
    age?: number;
}

type ReadonlyUser = MyReadonly<User>;  // 모든 속성이 readonly
type RequiredUser = MyRequired<User>;   // 모든 속성이 필수

// 타입 검증
const readonlyUser: ReadonlyUser = {
    name: "John",
    age: 30
};
// readonlyUser.name = "Jane"; // 에러: readonly 속성이므로 수정 불가

const requiredUser: RequiredUser = {
    name: "John",
    age: 30
    // 모든 속성을 반드시 지정해야 함
};
```

4. 도형의 면적을 계산하는 함수 (타입 가드 사용)

```typescript
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;

// 타입 가드 함수들
function isSquare(shape: Shape): shape is Square {
    return shape.kind === "square";
}

function isRectangle(shape: Shape): shape is Rectangle {
    return shape.kind === "rectangle";
}

function isCircle(shape: Shape): shape is Circle {
    return shape.kind === "circle";
}

function calculateArea(shape: Shape): number {
    if (isSquare(shape)) {
        return shape.size * shape.size;
    }
    
    if (isRectangle(shape)) {
        return shape.width * shape.height;
    }
    
    if (isCircle(shape)) {
        return Math.PI * shape.radius * shape.radius;
    }
    
    // 모든 케이스를 처리했지만, TypeScript의 타입 체크를 위해 필요
    const unreachable: never = shape;
    throw new Error(`Unhandled shape type: ${unreachable}`);
}

// 사용 예시
const square: Square = { kind: "square", size: 5 };
const rectangle: Rectangle = { kind: "rectangle", width: 4, height: 6 };
const circle: Circle = { kind: "circle", radius: 3 };

console.log(calculateArea(square));    // 25
console.log(calculateArea(rectangle)); // 24
console.log(calculateArea(circle));    // 약 28.27
```