---
chapter: 타입스크립트 추가 문법
title: 타입스크립트 추가문법
date: 2024-09-23
---

# 1. 타입 단언과 널 처리

## 1.1 Non-Null-Assertion
null이 아님을 보장하는 `!` 연산자를 사용하여 타입을 단언할 수 있습니다.

```tsx
const $div = document.querySelector('div');
$div!.innerText; // null이 아님을 보장
```

## 1.2 타입 단언(Type Assertion)
`as` 키워드를 사용하여 타입을 명시적으로 지정합니다.

```tsx
document.querySelector('input')!.addEventListener('change', (e) => {
  const target = e.target as HTMLInputElement;
  console.log(target.value);
});
```

:::div{.callout}
💡 타입 단언은 필요한 경우에만 사용하고, 가능하면 타입 가드를 활용하는 것이 좋습니다.
:::

# 2. 객체 타입 고급 기능

## 2.1 인덱스 시그니처
동적 속성을 가진 객체의 타입을 정의합니다.

```tsx
interface User {
    id: number;
    name: string;
    [key: string]: string | number; // 동적 속성 허용
}

const user: User = {
    id: 1,
    name: "gary",
    info: "안녕하세요",
    age: 25
};
```

## 2.2 keyof 연산자
객체 타입의 키를 유니온 타입으로 추출합니다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
}

type ProductKeys = keyof Product; // "id" | "name" | "price"
const key: ProductKeys = "name"; // 정상
const invalidKey: ProductKeys = "invalid"; // 에러
```

# 3. 비동기 처리

## 3.1 async/await 타입 지정
Promise 타입을 사용하여 비동기 함수의 반환 타입을 명시합니다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
}

async function fetchProduct(id: number): Promise<Product> {
  const response = await fetch(`/api/products/${id}`);
  return response.json();
}
```

# 4. 유틸리티 타입

## 4.1 객체 속성 변환

```tsx
// Partial
interface User {
  id: number;
  name: string;
  email: string;
}

const updateUser = (user: Partial<User>) => {
  console.log(user);
};
updateUser({ id: 1 }); // 가능

// Required
interface OptionalUser {
  id?: number;
  name?: string;
}

const user: Required<OptionalUser> = {
  id: 1,
  name: "John" // 모든 속성 필수
};

// Readonly
const product: Readonly<Product> = {
  id: 1,
  name: "Phone"
};
// product.name = "Laptop"; // 에러
```

## 4.2 타입 선택과 제외

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

// Pick
type ProductPreview = Pick<Product, 'name' | 'price'>;

// Omit
type ProductBasic = Omit<Product, 'stock'>;

// Exclude
type Status = 'active' | 'inactive' | 'pending';
type NonActiveStatus = Exclude<Status, 'active'>; // 'inactive' | 'pending'

// Extract
type ActiveStatus = Extract<Status, 'active'>; // 'active'
```

## 4.3 Record
키-값 쌍의 타입을 정의합니다.

```tsx
type ProductStatus = 'inStock' | 'outOfStock';
type ProductInventory = Record<ProductStatus, number>;

const inventory: ProductInventory = {
  inStock: 100,
  outOfStock: 0
};
```

# 연습문제

1. 다음 코드를 타입 가드를 사용하여 리팩토링하세요.
```tsx
document.querySelector('input')!.addEventListener('change', (e) => {
  const target = e.target as HTMLInputElement;
  console.log(target.value);
});
```

2. 아래 인터페이스에 적절한 유틸리티 타입을 적용해보세요.
```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  description?: string;
}

// 1. 모든 필드를 필수로 만들기
// 2. id를 제외한 필드만 선택하기
// 3. 모든 필드를 읽기 전용으로 만들기
```

:::div{.callout}
💡 필요에 따라 여러 유틸리티 타입을 조합하여 사용할 수도 있습니다.
:::

# 5. 고급 타입 가드 패턴

## 5.1 사용자 정의 타입 가드
타입 가드 함수를 정의하여 타입 범위를 좁힐 수 있습니다.

```tsx
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

function moveAnimal(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim();
  } else {
    pet.fly();
  }
}
```

## 5.2 타입 가드와 제네릭 조합
제네릭과 타입 가드를 함께 사용하여 더 유연한 타입 체크가 가능합니다.

```tsx
function isOfType<T>(value: any, property: keyof T): value is T {
  return (value as T)[property] !== undefined;
}

interface Product {
  id: number;
  price: number;
}

function processValue(value: any) {
  if (isOfType<Product>(value, 'price')) {
    console.log(value.price);
  }
}
```

# 6. 조건부 타입

## 6.1 기본 조건부 타입
타입을 조건에 따라 결정할 수 있습니다.

```tsx
type IsString<T> = T extends string ? true : false;

// 사용 예시
type A = IsString<string>;  // true
type B = IsString<number>;  // false
```

## 6.2 infer 키워드
타입 추론을 위한 조건부 타입에서 사용됩니다.

```tsx
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function getData(): number {
  return 123;
}

type DataType = ReturnType<typeof getData>; // number
```

# 연습문제

1. 조건부 타입을 사용하여 다음 기능을 구현해보세요.
```tsx
// 1. 배열의 요소 타입을 추출하는 ElementType<T> 구현
// 2. 함수의 매개변수 타입을 추출하는 ParamType<T> 구현

type ElementType<T> = // 여기에 구현
type ParamType<T> = // 여기에 구현

// 테스트
type NumberArray = number[];
type StringArray = Array<string>;
type ElementNumber = ElementType<NumberArray>; // should be number
type ElementString = ElementType<StringArray>; // should be string
```

2. 다음 인터페이스에 대한 타입 가드를 작성해보세요.
```tsx
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

// Shape 타입에 대한 타입 가드 함수 구현하기
function isCircle(shape: Shape): // 여기에 구현
function isSquare(shape: Shape): // 여기에 구현
```

:::div{.callout}
💡 타입 가드와 조건부 타입을 활용하면 더 안전하고 유연한 타입 시스템을 구축할 수 있습니다.
:::

# 7. 맵드 타입 고급 기능

## 7.1 템플릿 리터럴 타입과 맵드 타입
문자열 리터럴 타입을 동적으로 생성할 수 있습니다.

```tsx
type EventName<T extends string> = `${T}Event`;
type MouseEvents = EventName<'click' | 'mousedown' | 'mouseup'>;
// 'clickEvent' | 'mousedownEvent' | 'mouseupEvent'
```

## 7.2 조건부 타입과 맵드 타입
맵드 타입에서 조건부 타입을 사용하여 복잡한 타입 변환을 수행할 수 있습니다.

```tsx
type NonNullableProperties<T> = {
  [P in keyof T]: T[P] extends null | undefined ? never : T[P];
};

interface User {
  name: string;
  age: number | null;
  email: string | undefined;
}

type NonNullableUser = NonNullableProperties<User>;
```

:::div{.callout}
💡 이러한 고급 타입 기능들은 복잡한 타입 시스템을 구축할 때 유용하지만, 코드의 가독성과 유지보수성을 고려하여 적절히 사용해야 합니다.
:::