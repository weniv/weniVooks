---
chapter: 타입스크립트란?
title: 타입스크립트란?
date: 2024-09-10
---

# 타입스크립트란

## 일단 겁내지 말자

모던 자바스크립트(ES2015이후로 치자)에 익숙한 사용자라면 큰 어려움 없이 사용 가능합니다. 물론 “잘 사용할 수 있는가” 라는 관점에서는 조금 멀어지겠지만 일단 사용 자체에 드는 시간과 비용은 크지 않을 것입니다. 그 이유는 타입스크립트가 자바스크립트의 **‘수퍼셋’**이라는 데 있습니다.

이러한 특성 덕분에 자바스크립트 기반의 프로젝트라고 하더라도 **일부 파일만** 타입스크립트로 바꿔서 부분적으로 도입이 가능하니 팀 자체적으로도 누군가의 러닝커브에 휩쓸릴 위험 없이 점진적인 도입이 가능합니다!

<aside>
💡

왜 점진적인 도입이 필요할까요?

</aside>

## 자바스크립트로 충분한데요?

물론 자바스크립트만으로도 충분한 케이스가 있습니다. 다음의 코드를 참고하겠습니다.

```jsx
// 버튼 클릭 시 메시지 출력
const button = document.querySelector('button');
button.addEventListener('click', () => {
  alert('버튼이 클릭되었습니다!');
});
```

위의 코드는 버튼 클릭 시 메시지를 출력하는 간단한 자바스크립트 코드입니다.
이와 같이 코드만 읽어도 어떤 자료형인지 알 수 있거나, 자료형을 알 필요가 없는 코드의 경우에는 타입스크립트를 사용하지 않아도 충분하다고 볼 수 있습니다.

## 자바스크립트로 안 충분한데요?

이번에는 다음의 자바스크립트 코드를 참고하겠습니다.

```jsx
function add(a, b) {
  return a + b;
}

const result = add(1, '2');
console.log(result); // '12'
```

두 개의 “숫자”를 입력 받아 더한 값을 반환해주는 함수를 만들었습니다. 그리고 두 개의 인자로 1과 문자열“2”를 전달하여 결과값을 받습니다.

이 때 예상하지 못한 결과가 발생합니다.

1. 두 개의 숫자를 받기 위한 함수는 하나의 숫자와 하나의 문자열을 받게 되었습니다.
2. 1과 2를 입력하여 결과로 3을 반환 받길 원했지만, 1과 문자열 2를 더해서 “12”가 되었습니다.
3. 함수가 반환하는 값의 자료형이 number이길 원했지만 문자열이 반환됩니다.
4. 결과적으로 우리는 두 개의 숫자를 더하는 함수를 만들지 않았을 가능성이 보입니다.

해당 함수의 올바른 사용법을 알려주기 위해 다음과 같은 주석을 달아보겠습니다.

```jsx
/**
 * 두 수의 차를 구한다.
 * @param {number} a - 첫번째 매개변수 입니다.
 * @param {number} b - 두번째 매개변수 입니다.
 * @returns {number} - 리턴값 입니다.
 */
function add(a, b) {
  return a + b;
}
```

이제 커서를 가져가면 아래와 같이 볼 수 있습니다.

::img{width="600" alt="커서를 가져갔을때 파라미터의 타입이 보인다." src="/Images/basecamp-typescript/chapter01/chapter-01-0.png"}

오! 이제는 이 함수를 사용하는 사람이 첫번째 매개변수와 두번째 매개변수 그리고 리턴값이 무엇인지 알 수 있게 되었어요! 조금 더 명확하고 목적에 맞게 쓸 수 있겠네요 :)

하지만 슬프게도 누구나 이런 부분을 확인하는 것은 아닙니다. 아래처럼 입력을 해도 여전히 에러 없이 동작됩니다.

::img{width="600" alt="사용자가 잘못 사용하는 경우" src="/Images/basecamp-typescript/chapter01/chapter-01-1.png"}

또한, 주석을 다는 사람이 실수를 하지 말라는 법도 없겠네요. 이런, 두 개의 숫자를 더하는 함수로 사용해야 했지만 잘못된 주석으로 인해 문자와 숫자를 더해주는 이상한 함수로 사용하고 있습니다.

::img{width="600" alt="주석이 잘못 입력된 경우" src="/Images/basecamp-typescript/chapter01/chapter-01-2.png"}

<aside>
💡

실제로 우리가 이전 수업들에서 진행한 실습에서 타입으로 인한 오작동(?)이 있었는지 생각해봅시다.

</aside>

## 제한해서 해결하기

앞서 살펴본 문제를 어떤 방법으로 해결하면 좋을까요? 애초에 함수 내에서 인자의 타입이 `number`가 아니라면 에러를 반환하도록 제한하면 될 것 같습니다!

해당 문제를 해결해보겠습니다.

```jsx
function add(a, b) {
  if (typeof a == 'number' && typeof b == 'number') {
    throw new TypeError('인자는 모두 숫자여야 합니다.');
  }
  return a + b;
}

const result = add(1, '2'); //에러발생! TypeError('인자는 모두 숫자여야 합니다.')
console.log(result);
```

위의 코드에서 **`add`** 함수는 두 개의 인자 **`a`**와 **`b`**가 모두 숫자인지 확인한 후 더한 값을 반환합니다. 만약 인자 중 하나라도 숫자가 아니라면 **`TypeError`**를 발생 시킵니다.

이렇게 자바스크립트에서도 타입 검사를 수행할 수 있지만, 코드가 복잡해지고 가독성이 떨어집니다. 그리고 여전히 함수 자체에서 a, b가 number가 아닌데도 함수 실행이 가능합니다.

만약 직접 작성한 **`throw new TypeError('인자는 모두 숫자여야 합니다.');`** 에러가 아니라면 사용자는 여전히 어떤 문제인지 알기 힘들겠네요.

이러한 문제가 발생할 때마다 우리는 **타입에 대해서 예외사항**을 계속 만들어야 합니다.

## 타입스크립트를 쓰자

앞서 자바스크립트에서 발생하는 불편한 부분을 해결하는 것은 간단합니다. 타입이 **`number`**가 아니라면 애초에 **`a`**와 **`b`**에 할당할 수 없음을 알리는 것입니다. 그리고 한 번 정해진 **`a`**와 **`b`**의 타입은 변하지 않습니다.

하나의 변수의 타입이 계속 바뀌는 자바스크립트의 타입 형태를 **동적 타입**이라고 부릅니다. 그리고 한번 정해진 변수의 타입이 바뀌지 않는 타입 형태를 **정적 타입**이라고 합니다.

그럼 타입스크립트에서는 앞서 살펴본 **`add`** 함수를 어떤 식으로 작성하고, 위와 같이 의도한 형태로 타입을 사용하지 않았을 때 어떻게 오류를 잡는지 살펴보겠습니다.

```tsx
//          👇 a, b가 number타입임을 명시 👇 이 함수가 반환하는 값이 number임을 명시
function add(a: number, b: number): number {
  return a + b;
}

const result = add(1, '2'); // 에러: 인자 '2'의 타입이 'number'가 아님
console.log(result);
```

타입스크립트에서는 위와 같이 작성합니다. 타입스크립트가 무엇이고 어떻게 사용하는지는 모르겠지만 **`number`**라는 타입이 적혀있는 것은 보입니다.

어떠한 값에 대해 **타입을 명시적으로 작성할 수 있는 기능**을 타입스크립트에서 제공하고 있습니다. 이러한 점을 이용하여 코드를 작성하게 되면 이 함수를 사용하는 모든 사용자는 ‘함수 **`add`**가 문자열을 합치는 것인지?’, ‘숫자를 더해주는 함수인지?’에서 주는 혼란에서 탈출할 수 있게 됩니다.

이렇게 타입을 제대로 작성하는 것만으로 많은 것들을 해결할 수 있고 편리함도 생길 수 있습니다. 앞서 자바스크립트코드에서 타입을 알리기 위해 주석을 작성했습니다.

이 주석은 함수 사용법에 대한 문서로 생각할 수도 있습니다. 그런데 우리는 이런 정보 전달을 타입스크립트에서 주석 없이 코드로만 작성했습니다.

**_“이럴 수가!”_**

코드만 작성했을 뿐인데 하나의 문서와 같은 역할 또한 하게 될 수 있습니다! **잘 만든 코드 자체가 문서가 될 수 있겠군요.** 그리고 타입을 넣어서 조금 더 문서처럼 작성하는 주석을 줄일 수도 있겠습니다.

이렇게 타입을 작성하는 것 만으로 많은 것을 전해 줄 수 있습니다. 우리는 조금 더 코드로 소통할 수 있는 가능성이 생겼습니다.

---
