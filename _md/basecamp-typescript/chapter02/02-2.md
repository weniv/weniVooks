---
chapter: 타입스크립트 문법
title: 타입스크립트란 문법
date: 2024-09-23
---

## 타입을 명시하지 않았을 때

타입스크립트에서는 타입을 명시하지 않았을 경우 타입스크립트가 타입을 알아서 가장 일반적으로 적합한 타입을 넣어줍니다. 이러한 과정을 **타입추론(Type Inference)** 이라 합니다.

```tsx
const num = 1;
```

::img{width="600" alt="타입추론이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-1.png"}

이와 같은 코드를 사용하면 num은 타입스크립트의 타입추론을 통해 num은 조금 더 구체적인 타입이 됩니다. 앞서 타입을 생성했을 때는 let으로 생성했습니다. 이번에는 const로 생성했습니다.

num을 생성했을 때 number라는 타입이 아니라 `1` 이라는 구체적인 값을 보여줍니다. 이렇게 구체적인 값을 타입으로 나타내는 것을 `리터럴 타입`이라고 부릅니다.

이번에는 const가 아닌 let으로 변수를 생성해 보겠습니다.

::img{width="600" alt="타입추론이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-2.png"}

변수에 직접 값을 할당했습니다.

이 경우 타입스크립트는 1이라는 값과 같은 타입이 들어올 수 있도록 적합한 타입을 넣어줍니다. 이렇게 생성한 변수는 직접 타입을 명시했을 때와 마찬가지로 정해진 타입만 할당이 가능합니다.

변수를 초기화하지 않고 생성만 했을 때는 어떻게 추론 될까요?

::img{width="600" alt="타입추론이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-3.png"}

any라는 타입이 지정되는 모습을 볼 수 있습니다.
이렇게 만들어진 변수는 어떤 값이든 할당이 가능하게 됩니다.
하지만 이 any라는 타입은 권장 되지 않는 타입인데 그 이유는 어떤 타입이든 들어갈 수 있는 형태로 만들게 되면 기존 JS를 쓰는 것과 TS를 사용하는 것의 차이가 없어지기 때문입니다.

<aside>
💡 앞서 타입 종류를 배울 때 변수를 `let 변수명:타입 = 값` 과 같은 형태로 선언했습니다.
하지만 값만 넣어도 이미 타입스크립트에서 타입을 추론하기 때문에
 `string`이라는 타입추론 + `string` 이라는 타입 명시를 하는 것은 중복적으로 타입을 명시한 것으로 볼 수 있습니다. 
따라서 타입이 변하지 않는(하나의 타입만 갖는) 변수에는 따로 타입을 적지 않는 것을 선호하는 경우가 많습니다.

</aside>

- 재미있는거
  ```tsx
  let name:“ChoWonBeom”
  name = “ChoWonBeom” // 이건 잘됨
  name = “WonBeom” // 이건 빨간줄나옴
  ```

### any타입

any타입은 타입스크립트에서 특정 값으로 인해 유형 검사 오류가 발생하는 것을 막기 위해 사용할 수 있습니다.
앞서 이야기한 것처럼 권장 되지는 않지만 자바스크립트에서 타입스크립트로 이동하는 경우에는 유용하게 사용할 수 있습니다.

하지만 any타입을 사용하게 되면 각 타입에 대한 자동 완성 등 편리한 기능을 사용할 수 없게 됩니다.

::img{width="600" alt="any타입을 사용했을 때는 자동 완성이 되지 않는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-4.png"}

::img{width="600" alt="any타입을 사용했을 때는 자동 완성이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-5.png"}

<aside>
💡 any 타입에는 never 타입을 제외한 모든 타입을 사용할 수 있습니다.

</aside>

아직 전체적으로 어떤 값이 들어오는지 확실하진 않아, any타입을 사용하는 상황이라고 가정하겠습니다. 이때, string이 들어올 가능성이 있는 경우 `타입 좁히기(type narrowing)`를 통해 타입을 명시하고 사용 가능합니다. `타입가드`라고도 함

::img{width="600" alt="타입 좁히기를 사용했을 때는 자동 완성이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-6.png"}

타입 좁히기를 사용했을 때는 자동 완성이 된다.

타입 좁히기를 진행한 경우 선언한 값에 타입이 할당되어 있는 것을 확인할 수 있습니다.

::img{width="600" alt="타입 좁히기를 사용했을 때는 자동 완성이 안되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-7.png"}

타입 좁히기 전

::img{width="600" alt="타입 좁히기를 사용했을 때는 자동 완성이 되는 모습" src="/Images/basecamp-typescript/chapter02/chapter-02-2-8.png"}
타입 좁히기 후

### 유니언타입

하나의 변수가 두 개 이상의 타입을 허용하게 하고 싶을 수 있습니다.
앞서 배열을 만들 때 배열 안의 값에는 문자열 또는 숫자 값을 넣는 방법을 보았는데요.
비슷한 경우를 타입스크립트의 타입추론을 통해 어떤식으로 타입이 들어가는지 보겠습니다.

조건은 이렇습니다.

```tsx
union이라는 변수를 만듭니다.
랜덤숫자를 뽑고 0.5이상이라면 “통과” 텍스트를 0.5미만 이라면 0이라는 값을 union에 넣어줍니다.
```

이때 union의 타입은 string 또는 number겠네요.
해당 논리를 구현한 코드입니다.

::img{width="600" alt="유니온타입을 사용한 예시" src="/Images/basecamp-typescript/chapter02/chapter-02-2-9.png"}

`let 변수명:타입|다른타입` 이렇게 나오네요.
이런식으로 `|`(or)를 통해 타입을 명시해 줄 수 있습니다.

```tsx
let union: string | number;
```

이때도 값을 할당하면 할당한 값에 따라 타입 추론이 일어납니다.

::img{width="600" alt="유니온타입을 했을때 타입추론" src="/Images/basecamp-typescript/chapter02/chapter-02-2-10.png"}

```tsx
let union: string | number;
union = 1; //이렇게하면 number가됨
union = 'hello'; //이렇게하면 string이됨
```

### unknown

```tsx
let unknownValue: unknown = 4;
unknownValue = 'maybe a string instead';
unknownValue = false;
```

**`unknown`** 타입은 **`any`**와 비슷하지만, 더 안전합니다.
타입을 확정하기 전까지 사용할 수 없습니다.

::img{width="600" alt="unknown타입을 사용했을 때" src="/Images/basecamp-typescript/chapter02/chapter-02-2-11.png"}

조건문 안에 있는 코드는 오류가 없지만 조건문 밖의 코드는 오류를 보여주고 있습니다.
이는 조건문에서 `unknownValue` 의 타입이 `string`일 때만 실행한다고 작성했기 때문에 가능한 것입니다.
반면, 조건문 밖의 코드는 여전히 unknown입니다.
타입이 확정되지 않았기 때문에 사용이 불가능합니다.

::img{width="600" alt="any타입을 사용했을 때" src="/Images/basecamp-typescript/chapter02/chapter-02-2-12.png"}

반면 `any`로 선언했을때는 모두 실행이 됩니다.
`any`보다 더 강력하게 타입 안정성을 지키고 싶을 때 사용하면 됩니다.

---

## 함수에서 사용하기

타입스크립트에서는 함수가 어떤 타입의 값을 받을지, 어떤 타입을 리턴하는지 정해줄 수 있습니다.

```tsx
function 함수명(파라미터: 타입): 리턴타입 {}
```

간단한 덧셈 함수를 만들겠습니다.

```tsx
function add(firstNum, secondNum) {
  return firstNum + secondNum;
}
```

::img{width="600" alt="타입을 명시하지 않은 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-13.png"}

이렇게 작성하면 add함수의 입력으로 받는 firstNum, secondNum, 그리고 리턴하는 값의 타입이 any로 설정됩니다. 우린 파라미터가 숫자였으면 좋겠습니다. 그리고 이 함수가 리턴하는 값 또한 숫자였으면 합니다.
사용하는 경우에도 문자열을 더해주는 것이 아님을 확실히 알면 좋겠네요.

```tsx
function add(firstNum: number, secondNum: number): number {
  return firstNum + secondNum;
}
```

이렇게 작성하면 함수에 어떤 값을 넣으면 좋은지 반환되는 값은 어떤 형태인지 바로 알 수 있습니다.
또한 명시하지 않아도 반환 가능한 모든 타입을 타입스크립트가 추론하여 알려주기도 합니다.

::img{width="600" alt="코드에디터에서 타입을 보여준다." src="/Images/basecamp-typescript/chapter02/chapter-02-2-15.png"}

타입스크립트의 타입추론을 활용한 예시

함수를 사용할 때는 여러 경우가 존재합니다.

- 매개변수를 여러개 받을 수 있지만 입력하지 않아도 되는 경우
- 반환값이 없는 경우
- 함수가 끝나지 않는 경우

### 선택적 매개변수

만약 앞서 작성한 코드에 첫번째 매개변수만 들어오는 경우를 만들고 싶을 수 있습니다.

그럴 때는 선택적 매개변수를 사용할 수 있습니다.

::img{width="600" alt="선택적 매개변수를 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-16.png"}

`?` 를 매개변수 뒤에 붙이고 타입을 작성하면 해당 매개변수는 들어오지 않을 수 있다는 것을 의미합니다.
그런데 왜 빨간 밑줄이 생겼을까요?
자바스크립트에서는 함수에 매개변수가 제공되지 않으면 해당되는 매개변수는 undefined가 됩니다.
그럼 아무것도 입력하지 않은 경우에는 secondNum이 undefined가 되는 것으로 유추할 수 있겠네요.

::img{width="600" alt="선택적 매개변수를 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-17.png"}

이런 경우에는 second는 number가 아니기 때문에 해당 연산을 할 수 없습니다.
우리는 이런 명확하지 않은 부분을 해결하기 위해 타입좁히기를 이용할 수 있습니다.

::img{width="600" alt="타입좁히기를 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-18.png"}

이번에는 함수명에 경고가 표시되었네요. 함수가 return을 할 수도 있고 안 할 수도 있기 때문인 것 같습니다.
역시 return값이 없을 수도 있는 경우에 대한 타입을 명시해줘야 할 것 같습니다.

<aside>
💡 typescript config에는 return에 undefined를 허용할지 안할지 결정하는 `noImplicitReturns`라는 옵션이 있습니다. 해당 옵션을 false로 설정하면 타입스크립트의 타입추론을 통해 `string|undefined`가 타입으로 할당됩니다. 물론 빨간 경고줄도 사라지구요!

</aside>

### void

- 반환값이 없는 경우

함수의 return이 없는 경우에 사용하는 반환타입입니다.

::img{width="600" alt="void타입을 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-19.png"}

firstNum:string과 secondNum:string을 입력으로 받아 콘솔로 출력해줍니다.
해당 함수는 js에서는 undefined를 return해줍니다.
함수를 사용할 때 undefined가 return되는 것이 아닌 return값이 없다고 명확하게 아는 것이 더 좋겠습니다.
void타입은 undefined와 다르게 함수의 반환타입을 무시할 때 사용합니다.
즉 `undefined는 값`이고, `void는 어떠한 값도 아님`을 의미합니다. 이렇게 두가지를 구분하는 것이 좋겠네요.

선택적 매개변수를 사용하여 작성한 함수의 경고를 없애보겠습니다.

::img{width="600" alt="void타입을 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-20.png"}

이렇게 작성하면 add함수는 `number를 반환하거나 아무런 값도 반환하지 않는다.` 라고 명시 되었습니다!

<aside>
💡 void는 사용하기 위한 값이 아니며 반환되는 값도 아닙니다. 함수의 반환 형태를 나타내며 단순히 반환 값이 없음을 알리는데 사용됩니다.

</aside>

### never

never 반환타입은 함수가 절대로 끝나지 않는 경우에 사용됩니다.
무한으로 반복되는 함수 또는 의도적으로 에러를 발생시키는 경우에는 함수가 끝나지 않았다고 볼 수 있습니다.
이런 경우를 명시적으로 나타내기 위해 사용됩니다.

타입을 명시하지 않으면 void로 타입이 추론됩니다 기본적으로 타입스크립트는 return이 없으면 void로 추론됩니다. 종료되지 않는 함수를 사용하는 입장에서는 내부 로직을 생각하지 않으면 함수가 종료되지 않는 경우를 생각하기 힘들 수도 있습니다. 이런 경우에는 함수가 종료되지 않는다고 알려주면 좋습니다.

::img{width="600" alt="never타입을 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-21.png"}

::img{width="600" alt="never타입을 사용한 함수" src="/Images/basecamp-typescript/chapter02/chapter-02-2-22.png"}

<aside>
💡 never와 void의 차이

- **`never`**: 함수가 어떤 값도 절대 반환하지 않음 - 함수가 예외를 던지거나 무한 루프에 빠지는 경우등 함수가 정상적으로 종료되지 않는 경우
- **`void`**: 함수가 명시적으로 값을 반환하지 않음 - 반환값이 없다(함수가 중간에 종료되어도 리턴값이 없음으로 포함)
</aside>

{}

타입스크립트는 `{}` 구문을 통해 객체를 생성하면 새로운 타입을 고려합니다.

```tsx
const obj = {
  key: 'test',
};
```

::img{width="600" alt="객체를 생성한 경우" src="/Images/basecamp-typescript/chapter02/chapter-02-2-23.png"}

선언한 obj의 타입

obj라는 객체를 하나 만들었습니다. 이때 생성된 타입을 보면 `{key:string}`이라는 형태로 타입이 할당된 것을 확인 할 수 있습니다. 역시 변수를 하나 생성하고 원하는 형태의 객체로 타입을 만들 수 있습니다.

```tsx
let obj: { key: string };
```

이런 형태로 사용하면 obj라는 변수는 object의 기본 속성과 key라는 이름의 키와 문자열값 쌍으로 이루어진 속성만 가질 수 있게됩니다.

## type 키워드

타입스크립트를 사용하면서 특정 형태의 데이터를 자주 사용한다고 가정하겠습니다.

```tsx
let todoData: {
  key: string;
  todo: string;
};
function addTodo(newTodoData: { key: string; todo: string }) {
  //엄청난 코드
}
function editTodo(prevTodo: { key: string; todo: string }): {
  key: string;
  todo: string;
} {
  //엄청난 코드
  return editedTodo;
}
```

이렇게 같은 형태의 객체를 반복하여 작성하는 것은 매우 귀찮습니다. `어떤 객체는 이런 형태(type)이다`라는 것을 명시할 수 있습니다. 이렇게 타입을 만들고 이름을 붙여 사용하는 방식을 `타입별칭`이라고합니다.

```tsx
// key와 todo라는 속성을 가지고있는 타입에 Todo라는 이름을 부여
type Todo = {
  key: string;
  todo: string;
};
// 기존에 만들어둔 Todo라는 타입 사용하기
function addTodo(newTodoData: Todo) {
  //엄청난 코드
}
function editTodo(prevTodo: Todo): Todo {
  //엄청난 코드
  return editedTodo;
}
```

`?` 를 이용하여 옵셔널한 속성을 넣어 정의할 수 있습니다.

```tsx
type Todo = {
  key: string;
  todo: string;
  caption?: string;
};
```

이렇게 정의하면 caption 속성을 선택적으로 사용하는 Todo타입을 사용할 수 있습니다.

꼭 객체가 아니어도 타입을 정의하여 사용 가능합니다.

```tsx
type Id = string;
```

Id의 타입이 매번 바뀐다면 문자열 타입이 아니라 Id라는 의미있는 타입으로 사용하기 위해 이런식으로 사용하기도 합니다.

### 연산자를 이용한 타입 정의

Id타입이 문자열 또는 숫자로 사용될 수도 있습니다.
그럴때는 유니언 타입을 이용해 타입을 정의할 수 있습니다.

```tsx
type Id = string | number;
```

타입을 확장하는 방법도 있습니다 이를 `인터섹션 타입` 이라고 합니다.
인터섹션 타입은 `&`(and)를 사용합니다. 여러 타입의 조건을 모두 충족하는 타입을 만들어 사용 가능합니다.

```tsx
type Character = {
  nickName: string;
};
type Rabbit = {
  jump: number;
};
type Bird = {
  fly: number;
};
type RabbitChracter = Character & Rabbit;
type BirdChracter = Character & Bird;

const rabbit: RabbitChracter = {
  nickName: 'rabbit',
  jump: 10,
};
```

또한 아래처럼도 사용 가능합니다.

```tsx
type Character = {
  nickName: string;
};
type BirdCharacter = { fly: number } & Character;
```

### 읽기전용 속성

type에서 속성을 읽기전용으로만 사용하도록 명시할 수 있습니다.
읽기전용으로 명시한 속성은 const로 선언한 변수처럼 읽기만 가능하고 변경이 불가능합니다.

```tsx
type Character = {
  nickName: string;
  readonly id: number;
};
```

::img{width="600" alt="읽기전용 속성을 사용한 타입" src="/Images/basecamp-typescript/chapter02/chapter-02-2-24.png"}

readonly를 명시하지 않은 nickName은 재할당이 가능하지만 id는 타입스크립트에서 경고를 보여주는 모습을 볼 수 있습니다.

readonly를 명시해서, 변경이 되면 안되는 중요한 속성을 보호할 수 있습니다.

### 구조적 타이핑

타입스크립트는 구조적 타이핑을 따릅니다.
구조적 타이핑이란 구조가 같으면 같은 타입으로 취급한다는 의미입니다.

```tsx
type Todo = { key: string; todo: string };
type TodoSample = { key: string; todo: string };

const sampleTodo: TodoSample = { key: '1', todo: '샘플' };

function addTodo(todo: Todo): void {
  console.log(todo);
}

addTodo(sampleTodo);
```

addTodo 함수는 Todo 타입을 지원합니다. 하지만 함수를 호출할 때 사용한 sampleTodo의 타입은 TodoSample입니다. ‘타입이 다르기 때문에 에러가 나겠다’라고 생각하지만 잘 동작합니다.

타입스크립트는 ‘어떤 타입인가’를 기준으로 하는 것이 아닌 `타입의 구조가 어떠한가`를 보고 호환 여부를 판단합니다.

```tsx
type Todo = {todo : string }
type TodoSample = { key : string; todo : string}

function addTodo(todo:Todo):void{
    console.log(todo)
}
const sampleTodo:TodoSample = {key:"a"; todo:"샘플"}
addTodo(sampleTodo)
```

위와 같은 코드에서 `Todo`타입을 받는 함수에 `TodoSample`타입이 호환되는 이유도 같은 이유인데요.
TodoSample은 Todo에서 호환이 됩니다 구조적으로 `todo:string` 라는 속성이 있는 객체는 `Todo` 타입으로 사용 가능합니다.

```tsx
type Todo = { todo: string };
type TodoSample = { key: string; todo: string };

function addTodo(todo: TodoSample): void {
  console.log(todo);
}
const todo: Todo = { todo: '샘플' };
addTodo(todo);
```

하지만 반대의 경우는 에러가 나옵니다.
`type Todo = {todo : string }`
`type TodoSample = { key : string, todo : string}`

이 두개의 케이스는 이렇게 볼 수 있습니다.

- Todo : key를 가지고있으면 Todo에서 할당 가능
- TodoSample: key,todo를 가지고 있으면 TodoSample에 할당 가능

## interface 키워드

객체를 `정의` 하기 위해 interface 키워드를 사용할 수 있습니다.
interface는 type과 비슷하게 사용되지만 여러가지 기능을 사용할 수 있습니다.

```tsx
interface user {
  id: number;
  name: string;
  info: string;
}
```

### 선택적 속성

```tsx
interface user {
  id: number;
  name: string;
  info?: string;
}
```

필수 속성 외 제공되지 않아도 사용할 수 있는 선택적 속성을 `?`를 통해 정의 가능합니다.

### 인터페이스 확장

인터페이스 또한 type을 사용했을 때처럼 확장이 가능합니다. `extends`를 이용하여 확장합니다.

```tsx
//type Character = {
//	nickName:string;
//}
//type BirdCharacter = { fly:number } & Character

interface Character {
  nickName: string;
}
interface BirdCharacter extends Character {
  fly: number;
}
```

여러 인터페이스를 상속받을 수도 있습니다.

```tsx
interface Character {
  nickName: string;
}
interface Bird {
  fly: number;
}
interface BirdCharacter extends Character, Bird {
  level: number;
}

const birdChar: BirdCharacter = {
  nickName: 'Gary',
  fly: 10,
  level: 1,
};
```

### 인터페이스 병합

```tsx
interface Character {
    nickName:string;
}
interface Character {
    level:number;
}

const char:Character{
    nickName:string,
    level:number
}
```

두 개의 인터페이스가 같은 이름으로 `같은 스코프에 선언된 경우` 이전에 선언된 인터페이스에 병합됩니다.

<aside>
💡

여러 곳에 흩어져 선언한 경우 인터페이스를 명확하게 인지하기 힘들 수 있습니다.
하지만 기본 제공된 전역 인터페이스를 확장할 때는 유용할 수 있습니다.

</aside>

- 해보세요
  type과 interface의 차이를 알아보자.

## 제네릭

타입을 명확히 정하여 사용하기 위해 기본 타입들, 그리고 type, interface를 위해 정의한 타입을 이용했습니다. 하지만 코드를 호출하는 시점까지 타입을 모르는 경우는 어떨까요?
예를 들어, 배열을 만드는데 문자열 배열인지, 숫자 배열인지, 객체들이 들어있는 배열인지 모를 때 처럼요.

::img{width="600" alt="제네릭을 사용한 예시" src="/Images/basecamp-typescript/chapter02/chapter-02-2-25.png"}

::img{width="600" alt="제네릭을 사용한 예시" src="/Images/basecamp-typescript/chapter02/chapter-02-2-26.png"}

생성자 함수를 이용하여 배열을 생성하는 모습입니다. 입력값과 반환값의 타입이 유동적입니다.
즉, 사용하기 전까지는 입력값과 반환값이 정해져있지 않다는 뜻입니다.

```tsx
//생성자 함수를 사용하여 배열 생성.
const a = new Array<number>(1, 2, 3);
```

Array뒤에 `<number>` 라는 것이 붙어있는데요 이 문법이 제네릭을 사용하는 문법입니다.

제네릭은 함수의 파라미터를 생각하면 이해하기 쉽습니다.

```tsx
function add(a: number, b: number) {
  return a + b;
}
```

a와 b는 함수를 호출하기 전까지는 아직 `값이 정해지지 않은` 상태입니다.

```tsx
add(3, 4);
```

이렇게 호출할 때 a는 3으로, b는 4로 값이 정해집니다.
함수에서의 파라미터처럼 실제로 `사용할 때 타입이 정해지도록` 하는 방식입니다!

### 인터페이스에서 제네릭 사용하기

```tsx
interface ReqTodoData {
  status: number;
  ok: boolean;
  data: {
    todo: string;
    id: number;
  };
}
interface ReqCommentData {
  status: number;
  ok: boolean;
  data: {
    comment: string;
    writer: number;
  };
}
```

서버에서 받아온 데이터를 표현하는 타입들 입니다.
이때 `status`와 `ok`속성이 중복되는 모습을 볼 수 있네요. 이런 경우 중복된 코드가 많이 사용되고, 이것을 고치고 싶어질 것입니다.

이런 경우 제네릭을 이용하여 인터페이스를 만들면 유용합니다.

```tsx
interface TodoData {
  todo: string;
  id: number;
}
interface CommentData {
  comment: string;
  writer: number;
}
interface ReqData<T> {
  status: number;
  ok: boolean;
  data: T;
}

const commnetData: ReqData<CommentData> = {
  status: 200,
  ok: true,
  data: {
    comment: '댓글',
    writer: 1,
  },
};
```

### 함수에서 제네릭 사용하기

```tsx
function 함수명<타입이름>(파라미터: 타입이름): 타입이름 {}
```

- 퀴즈
  ```tsx
  function func(value) {
    return value;
  }
  const result = func('hi');
  const result_num = func(1);
  ```
  제네릭을 활용하여 함수의 결과에서 type이 추론 되도록 해보자
- 퀴즈2
  ```tsx
  function funcNum(value: number) {
    return value;
  }
  function funcString(value: string) {
    return value;
  }
  const result = funcNum(1);
  const result_num = funcString('hi');
  ```
  두 개의 함수가 있다 제네릭을 이용해서 중복코드를 없애보자.

## Enum

`Enum`(열거형)은 TypeScript에서 상수 값들의 집합을 정의할 때 사용하는 특별한 자료형입니다. 열거형을 사용하면 코드에서 의미 있는 이름을 사용해 가독성을 높이고, 실수를 줄일 수 있습니다. `Enum`은 `숫자형`(Numeric Enums)과 `문자열형`(String Enums)의 두 가지 형태로 사용할 수 있습니다.

### 숫자형 Enum

숫자형 `Enum`은 기본적으로 첫 번째 값이 `0`부터 시작하고, 이후 값들이 1씩 증가합니다. 원하는 숫자로 값을 설정할 수도 있습니다.

```tsx
enum Direction {
  Up, // 0
  Down, // 1
  Left, // 2
  Right, // 3
}

let move: Direction = Direction.Up; // move = 0
```

숫자를 명시적으로 할당할 수도 있습니다.

```tsx
enum Direction {
  Up = 1, // 1
  Down, // 2
  Left = 10, // 10
  Right, // 11
}

let move: Direction = Direction.Left; // move = 10
```

**사용 예시:**

```tsx
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

function movePlayer(direction: Direction) {
  switch (direction) {
    case Direction.Up:
      console.log('Moving Up');
      break;
    case Direction.Down:
      console.log('Moving Down');
      break;
    case Direction.Left:
      console.log('Moving Left');
      break;
    case Direction.Right:
      console.log('Moving Right');
      break;
  }
}

movePlayer(Direction.Up); // "Moving Up"
```

### 문자열형 Enum

문자열형 `Enum`은 값이 문자열로 지정됩니다. 이 경우 자동으로 값이 증가하지 않으며, 각 값을 명시적으로 지정해야 합니다.

```tsx
enum Status {
  Success = 'SUCCESS',
  Error = 'ERROR',
  Loading = 'LOADING',
}

let currentStatus: Status = Status.Success;
```

**사용 예시:**

```tsx
function displayStatus(status: Status) {
  if (status === Status.Success) {
    console.log('Operation was successful!');
  } else if (status === Status.Error) {
    console.log('There was an error.');
  } else if (status === Status.Loading) {
    console.log('Loading...');
  }
}

displayStatus(Status.Loading); // "Loading..."
```

### Heterogeneous Enum (혼합형 Enum)

숫자형과 문자열형 값을 혼합해서 사용할 수도 있지만, 권장되지는 않습니다.

```tsx
enum Mix {
  Yes = 'YES',
  No = 0,
}
```

### Enum을 값으로 사용하기

`Enum`은 정의한 상수들 외에도 다양한 기능을 제공합니다. 예를 들어, `Enum`의 값에 접근하거나 역으로 키를 찾을 수도 있습니다.

```tsx
enum Colors {
  Red,
  Green,
  Blue,
}

let colorName: string = Colors[2]; // "Blue"
let colorValue: number = Colors.Green; // 1
```

## 타입스크립트 조금 더 써보기

### Non-Null-Assertion

null이 아님을 확신할 때 사용합니다.

```tsx
const $div = document.querySelector('div');
```

`querySelector`를 이용하여 div를 찾는 코드입니다. div를 찾고 안에있는 텍스트를 꺼내고 싶습니다.

::img{width="600" alt="null일 수 있는 값에 대한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-27.png"}

해당 코드에서 검색을 했지만 아무것도 나오지 않는다면 null을 반환합니다. 이로인해 innerText를 쓰고싶지만 $div가 null일 수 있다고 타입스크립트가 경고를 보여줍니다.
이를 해결하기 위해서는

```tsx
if ($div == null) {
  console.log('div가 없다.');
} else {
  $div.innerText;
}
```

이런 형태의 코드를 작성하면 경고가 사라집니다.(이전에 언급한 타입가드!)
하지만 우리가 작성한 프로젝트에서는 null이 나올 일이 전혀 없다고 가정하겠습니다.
그렇다면 위 코드는 그다지 쓸모가 없어 보이네요.

이럴때 사용하는 것이 `!` 를 이용한 연산자입니다. js에서 옵셔널체이닝을 기억하시나요? null이나 undefined가 아니라면 다음 속성 또는 메서드로 이어주는 문법이었죠. 비슷하다고 생각하시면 됩니다.

해당 문법은 무조건 이어진다! 라고 타입스크립트에게 알려주는 문법입니다.

```tsx
const $div = document.querySelector('div');
$div!.innerText;
```

이렇게 작성하면 타입에러가 사라지는 것을 보실 수 있습니다.

### 인덱스 시그니처

```tsx
interface User {
    id:number;
    name:string;
    [key:string]:string; //key대신 이름 마음대로 해도됨
}
const user:User={
    id:1;
    name:"gary";
    info:"안녕하세요";
}
```

위 코드에서 이상한 것을 느끼셨다면 훌륭합니다. info라는 속성이 없었는데 작성을 하고 있습니다.
인덱스 시그니처는 속성이 어떤 타입인지 알고 있고 값이 어떤 타입인지 알고 있지만 속성의 이름이 명확하지 않을때 해당 속성의 이름을 동적으로 작성하고 싶을 때 사용합니다.

```tsx
interface User = {
    id:number;
    name:string;
}
const user:User={
    id:1;
    name:"gary";
    info:"안녕하세요;
}
```

::img{width="600" alt="인덱스 시그니처를 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-28.png"}

만약 이와 같이 되어 있다면. info라는 속성이 존재하지 않는다는 위협적인 경고를 보게 됩니다.
명확한 속성을 정하기 힘들때 간단하게 명시하기 위해 사용합니다.

### keyof

```tsx
interface ProductOption {
  id: number;
  optionName: string;
  additionalFee: number;
}

type ProductOptionKey = keyof ProductOption; // "id"|"optionName"|addtionalFee"
```

키를 이용하여 어떤 값을 처리할 때 유용합니다.
예를 들어 객체에 존재하는 키의 이름으로 어떤 처리를 할 때 잘못된 값을 넣게 되면 타입스크립트에서 경고를 띄워줍니다.

```tsx
type ProductOption = {
  id: number;
  optionName: string;
  additionalFee: number;
};

type ProductOptionKey = keyof ProductOption;

const key: ProductOptionKey = 'id'; //제대로 동작한다.
const key2: ProductOptionKey = 'userId'; //타입에러 발생!
```

### async/await 사용하기

```tsx
interface Product {
  id: number;
  productName: string;
  price: number;
  stockCount: number;
  thumbnailImg: string;
  option: ProductOption[];
  discountRate: 0;
  shippingFee: 1500;
  detailInfoImage: string[];
  viewCount: number;
  pubDate: string;
  modDate: string;
}
interface ProductOption {
  id: number;
  optionName: string;
  additionalFee: number;
}

// async-await
async function fetchData(id: number): Promise<Product> {
  const result = await fetch('https://test.api.weniv.co.kr/mall/1');
  const productData: Product = await result.json();
  return productData;
}
```

### 타입단언

타입스크립트의 타입추론만으로는 애매한 경우가 있습니다. `as` 키워드를 이용합니다

```tsx
document.querySelector('input')!.addEventListener('onChange', (e) => {
  console.log(e.target!.value);
});
```

::img{width="600" alt="타입단언을 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-29.png"}

onChange이벤트를 통해 인풋요소가 가지고 있는 값을 가지고 오려고 합니다. 타입스크립트에서 추론한 타입은 EventTarget입니다. EventTarget은 e.target이 가질 수 있는 가장 일반적인 타입을 선정한 것 입니다. 따라서 EventTarget은 div도 될 수 있고, button도 될 수 있습니다.
이렇게 추론된 EventTarget이라는 타입은 value를 가지고 있지 않습니다. div나 button에는 value라는 속성이 없을 수 있기 때문입니다.

그럼 value를 사용하고 싶으면 어떻게 해야할까요? 바로 e.target이 inputElement라고 간주하도록 만들면 됩니다.

```tsx
document.querySelector('input')!.addEventListener('onChange', (e) => {
  const target = e.target as HTMLInputElement;
  console.log(target.value);
});
```

이렇게 HTMLInputElement라는 타입이다! 라고 단언을 하게 된 것 입니다.

::img{width="600" alt="타입단언을 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-30.png}

타입단언을 통해 의도와 다르게 추론된 타입을 임의로 특정 타입으로 명시하여 사용하도록 만들면
위와 같이 원하는 타입에 해당되는 속성을 사용 할 수 있습니다.

<aside>
💡

as를 너무 남발하면 타입스크립트를 사용하는 의미가 퇴색 될 수 있습니다.

개발단계에서 타입스크립트를 사용해 타입으로 인한 경고를 받아 안전한 개발을 할 수 있습니다. 하지만 as를 남발하면 타입으로 인한 경고를 무시하게 됩니다. 이런 케이스가 많아지면 any를 사용하는것과 크게 다르지 않게 됩니다.

</aside>

- 퀴즈
  as를 사용하지 않고 타입경고를 없애봅시다!
  - 정답
    ```tsx
    document.querySelector('input')!.addEventListener('change', (e) => {
      const target = e.target;
      if (target instanceof HTMLInputElement) {
        console.log(target.value);
      }
    });
    ```

### Record타입

`Record` 타입은 특정 키-값 쌍을 정의하는 데 사용됩니다. 키(Key)의 타입과 값(Value)의 타입을 지정할 수 있습니다.

```tsx
type Product = {
  name: string;
  price: number;
};

const productCatalog: Record<string, Product> = {
  'product-1': { name: 'Apple', price: 1 },
  'product-2': { name: 'Orange', price: 2 },
};
```

위 코드에서 `Record<string, Product>`는 키로 `string` 타입을 사용하고, 값으로는 `Product` 타입을 가집니다.

### Partial 타입

`Partial`은 타입의 모든 속성을 선택적으로 만들어줍니다. 즉, 객체의 모든 속성이 없어도 허용됩니다.

```tsx
interface User {
  id: number;
  name: string;
  email: string;
}

const updateUser = (user: Partial<User>) => {
  console.log(user);
};

updateUser({ id: 1 });
```

`Partial<User>`는 `User` 인터페이스의 모든 속성을 선택적으로 변환하므로, `id`만 전달해도 타입 에러가 발생하지 않습니다.

<aside>
💡

이러한 유틸리티 타입들은 코드 재사용성 및 유지보수성을 높이는 데 매우 유용합니다.
partial과 반대로 모든 속성을 필수로 적용시켜야 하는 타입을 만들때는 Required라는 유틸리티 타입을 사용합니다. `Required<타입>` 이렇게 씁니다.

</aside>
