---
chapter: 타입스크립트 문법
title: 타입스크립트 추가문법
date: 2024-09-23
---

## 타입스크립트 조금 더 써보기

### Non-Null-Assertion

null이 아님을 확신할 때 사용합니다.

```tsx
const $div = document.querySelector('div');
```

`querySelector`를 이용하여 div를 찾는 코드입니다. div를 찾고 안에있는 텍스트를 꺼내고 싶습니다.

::img{width="600" alt="null일 수 있는 값에 대한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-27.png"}

해당 코드에서 검색을 했지만 아무것도 나오지 않는다면 null을 반환합니다. 이로인해 innerText를 쓰고싶지만 $div가 null일 수 있다고 타입스크립트가 경고를 보여줍니다.
이를 해결하기 위해서는

```tsx
if ($div == null) {
  console.log('div가 없다.');
} else {
  $div.innerText;
}
```

이런 형태의 코드를 작성하면 경고가 사라집니다.(이전에 언급한 타입가드!)
하지만 우리가 작성한 프로젝트에서는 null이 나올 일이 전혀 없다고 가정하겠습니다.
그렇다면 위 코드는 그다지 쓸모가 없어 보이네요.

이럴때 사용하는 것이 `!` 를 이용한 연산자입니다. js에서 옵셔널체이닝을 기억하시나요? null이나 undefined가 아니라면 다음 속성 또는 메서드로 이어주는 문법이었죠. 비슷하다고 생각하시면 됩니다.

해당 문법은 무조건 이어진다! 라고 타입스크립트에게 알려주는 문법입니다.

```tsx
const $div = document.querySelector('div');
$div!.innerText;
```

이렇게 작성하면 타입에러가 사라지는 것을 보실 수 있습니다.

### 인덱스 시그니처

```tsx
interface User {
    id:number;
    name:string;
    [key:string]:string; //key대신 이름 마음대로 해도됨
}
const user:User={
    id:1;
    name:"gary";
    info:"안녕하세요";
}
```

위 코드에서 이상한 것을 느끼셨다면 훌륭합니다. info라는 속성이 없었는데 작성을 하고 있습니다.
인덱스 시그니처는 속성이 어떤 타입인지 알고 있고 값이 어떤 타입인지 알고 있지만 속성의 이름이 명확하지 않을때 해당 속성의 이름을 동적으로 작성하고 싶을 때 사용합니다.

```tsx
interface User = {
    id:number;
    name:string;
}
const user:User={
    id:1;
    name:"gary";
    info:"안녕하세요;
}
```

::img{width="600" alt="인덱스 시그니처를 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-28.png"}

만약 이와 같이 되어 있다면. info라는 속성이 존재하지 않는다는 위협적인 경고를 보게 됩니다.
명확한 속성을 정하기 힘들때 간단하게 명시하기 위해 사용합니다.

### keyof

```tsx
interface ProductOption {
  id: number;
  optionName: string;
  additionalFee: number;
}

type ProductOptionKey = keyof ProductOption; // "id"|"optionName"|addtionalFee"
```

키를 이용하여 어떤 값을 처리할 때 유용합니다.
예를 들어 객체에 존재하는 키의 이름으로 어떤 처리를 할 때 잘못된 값을 넣게 되면 타입스크립트에서 경고를 띄워줍니다.

```tsx
type ProductOption = {
  id: number;
  optionName: string;
  additionalFee: number;
};

type ProductOptionKey = keyof ProductOption;

const key: ProductOptionKey = 'id'; //제대로 동작한다.
const key2: ProductOptionKey = 'userId'; //타입에러 발생!
```

### async/await 사용하기

```tsx
interface Product {
  id: number;
  productName: string;
  price: number;
  stockCount: number;
  thumbnailImg: string;
  option: ProductOption[];
  discountRate: 0;
  shippingFee: 1500;
  detailInfoImage: string[];
  viewCount: number;
  pubDate: string;
  modDate: string;
}
interface ProductOption {
  id: number;
  optionName: string;
  additionalFee: number;
}

// async-await
async function fetchData(id: number): Promise<Product> {
  const result = await fetch('https://test.api.weniv.co.kr/mall/1');
  const productData: Product = await result.json();
  return productData;
}
```

### 타입단언

타입스크립트의 타입추론만으로는 애매한 경우가 있습니다. `as` 키워드를 이용합니다

```tsx
document.querySelector('input')!.addEventListener('onChange', (e) => {
  console.log(e.target!.value);
});
```

::img{width="600" alt="타입단언을 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-29.png"}

onChange이벤트를 통해 인풋요소가 가지고 있는 값을 가지고 오려고 합니다. 타입스크립트에서 추론한 타입은 EventTarget입니다. EventTarget은 e.target이 가질 수 있는 가장 일반적인 타입을 선정한 것 입니다. 따라서 EventTarget은 div도 될 수 있고, button도 될 수 있습니다.
이렇게 추론된 EventTarget이라는 타입은 value를 가지고 있지 않습니다. div나 button에는 value라는 속성이 없을 수 있기 때문입니다.

그럼 value를 사용하고 싶으면 어떻게 해야할까요? 바로 e.target이 inputElement라고 간주하도록 만들면 됩니다.

```tsx
document.querySelector('input')!.addEventListener('onChange', (e) => {
  const target = e.target as HTMLInputElement;
  console.log(target.value);
});
```

이렇게 HTMLInputElement라는 타입이다! 라고 단언을 하게 된 것 입니다.

::img{width="600" alt="타입단언을 사용한 경고" src="/Images/basecamp-typescript/chapter02/chapter-02-2-30.png}

타입단언을 통해 의도와 다르게 추론된 타입을 임의로 특정 타입으로 명시하여 사용하도록 만들면
위와 같이 원하는 타입에 해당되는 속성을 사용 할 수 있습니다.

<aside>
💡

as를 너무 남발하면 타입스크립트를 사용하는 의미가 퇴색 될 수 있습니다.

개발단계에서 타입스크립트를 사용해 타입으로 인한 경고를 받아 안전한 개발을 할 수 있습니다. 하지만 as를 남발하면 타입으로 인한 경고를 무시하게 됩니다. 이런 케이스가 많아지면 any를 사용하는것과 크게 다르지 않게 됩니다.

</aside>

- 퀴즈
  as를 사용하지 않고 타입경고를 없애봅시다!
  - 정답
    ```tsx
    document.querySelector('input')!.addEventListener('change', (e) => {
      const target = e.target;
      if (target instanceof HTMLInputElement) {
        console.log(target.value);
      }
    });
    ```

## 유틸리티 타입

### Partial 타입

`Partial`은 타입의 모든 속성을 선택적으로 만들어줍니다. 즉, 객체의 모든 속성이 없어도 허용됩니다.

```tsx
interface User {
  id: number;
  name: string;
  email: string;
}

const updateUser = (user: Partial<User>) => {
  console.log(user);
};

updateUser({ id: 1 });
```

`Partial<User>`는 `User` 인터페이스의 모든 속성을 선택적으로 변환하므로, `id`만 전달해도 타입 에러가 발생하지 않습니다.

### Pick타입

`Pick` 타입은 특정 타입에서 원하는 속성만 선택하여 새로운 타입을 만들 때 사용합니다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

type ProductInfo = Pick<Product, 'name' | 'price'>;

const product: ProductInfo = {
  name: 'Apple',
  price: 1000,
};
```

### Omit타입

`Omit` 타입은 특정 타입에서 원치 않는 속성을 제거하여 새로운 타입을 만들 때 사용합니다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
}

type ProductInfo = Omit<Product, 'id' | 'stock'>;

const product: ProductInfo = {
  name: 'Apple',
  price: 1000,
};
```

### Exclude타입

`Exclude` 타입은 첫 번째 타입에서 두 번째 타입에 포함된 타입을 제외한 타입을 만들 때 사용합니다.

```tsx
// 'a'|'b' | 'c'에서 두번째에 해당하는 'a'를 제외한 'b' | 'c'가 됩니다.
type T0 = Exclude<'a' | 'b' | 'c', 'a'>;
```

### Extract타입

`Extract` 타입은 첫 번째 타입에서 두 번째 타입에 포함된 타입만을 추출하여 새로운 타입을 만들 때 사용합니다.

```tsx
// 'a'|'b' | 'c'에서 두번째에 해당하는 'a'만 추출하여 'a'가 됩니다.
type T0 = Extract<'a' | 'b' | 'c', 'a'>;
```

### Readonly타입

`Readonly` 타입은 모든 속성을 읽기 전용으로 만들 때 사용합니다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
}

const product: Readonly<Product> = {
  id: 1,
  name: 'Apple',
  price: 1000,
};

product.name = 'Banana'; // 타입 에러 발생
```

### Required타입

`Required` 타입은 모든 속성을 필수로 만들 때 사용합니다.

```tsx
interface Product {
  id?: number;
  name?: string;
  price?: number;
}

// 에러 발생
const product2: Required<Product> = {
  id: 1,
};

// 정상 작동
const product: Required<Product> = {
  id: 1,
  name: 'Apple',
  price: 1000,
};
```

### Record타입

`Record` 타입은 특정 키-값 쌍을 정의하는 데 사용됩니다. 키(Key)의 타입과 값(Value)의 타입을 지정할 수 있습니다.

```tsx
type Product = {
  name: string;
  price: number;
};

const productCatalog: Record<string, Product> = {
  'product-1': { name: 'Apple', price: 1 },
  'product-2': { name: 'Orange', price: 2 },
};
```

위 코드에서 `Record<string, Product>`는 키로 `string` 타입을 사용하고, 값으로는 `Product` 타입을 가집니다.
