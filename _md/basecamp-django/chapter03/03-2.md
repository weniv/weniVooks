---
chapter: Model과 DataBase
title: Django ORM 실습
date: 2024-07-23
---
# 1. Django ORM QuerySet

Django의 `ORM`은 개발자가 **데이터베이스 쿼리**를 쉽게 다룰 수 있게 해주는 도구입니다. 여기서 `쿼리`는 데이터베이스에 하는 질문입니다. 우리가 쿼리로 질문을 하면, 데이터베이스는 그에 대한 답을 줍니다. 예를 들어, "모든 상품의 이름을 알려줘"라고 물으면 데이터베이스는 상품 이름 목록을 답으로 줍니다.      
이 질문을 하려면 SQL이라는 문법을 알아야합니다. 하지만 장고에서는 이 SQL을 몰라도, 질문을 할 수 있도록 만들었습니다.
우리가 파이썬으로 질문하면, 이 질문을 ORM이라는 번역기가 SQL로 변환하여 질문해줍니다.
:::figure
::img{alt="" src="/images/basecamp-django/chapter03/02-1.png"}
::figcaption[Django ORM 작동 예시]
:::
ORM을 사용하면, 개발자는 SQL을 직접 작성할 필요가 없고, 데이터베이스 종류가 바뀌어도 Python 코드를 수정할 필요가 없다는 장점이 있습니다. 실습을 통해 django의 ORM 쿼리에 대해 알아봅시다.

# 2. ORM 실습 준비
Django ORM을 실습하기 위해 `Django 쉘`을 사용합니다.

1. 터미널에 아래 명령어를 입력합니다.
   ```
   python manage.py shell
   ```
2. 명령어 실행 후 터미널 창에 `>>>` 모양이 나타나는 것을 확인해 주세요. `>>>`이 나타나면, 쉘에 진입했다는 뜻입니다. ORM 실습에서는 `>>>`모양 옆에 명령어를 입력하면 됩니다.
3. 쉘 사용을 중지하려면 `exit()`을 입력합니다.

# 3. 기본 Query
기본적인 쿼리에 대해서 이야기하기 전에, `객체`가 무엇인지 먼저 알아봅시다. 간단하게 말해서 `객체`는 우리가 다루는 데이터 한 묶음을 의미합니다. 블로그를 예시로 들어보겠습니다. 우리가 블로그의 구성을 생각해보면 전체 블로그 글의 목록, 하나하나의 블로그 글, 글의 제목, 내용, 댓글 등으로 구성이 될 것 입니다. 여기서 객체는 하나하나의 블로그 글 이라고 생각하면 됩니다. 이 글이 모인 목록은 데이터베이스가 되고, 글에 속해있는 제목, 내용, 댓글은 속성이 됩니다.

쉘에서 모델을 사용하기 위해 `models.py`에서 모델을 불러옵니다.   
```python
#ORM 쿼리 실습을 위해서는 이전 3-1 실습에서 만든 모델이 있어야 합니다!
from blog.models import Post
```
```python
# 모든 Post 객체 가져오기
all_posts = Post.objects.all()

# all_posts의 타입 확인
print(type(all_posts))

# all_posts의 사용 가능한 메서드와 속성 확인
print(dir(all_posts))
```
`all()` 메서드는 모든 객체를 반환합니다. `type()`과 `dir()` 함수는 Python 내장 함수로, 객체의 타입과 사용 가능한 속성 및 메서드를 확인하는 데 사용됩니다.

# 4. CRUD
CRUD는 데이터베이스의 **기본적인 데이터 처리 기능**을 나타내는 약어로, 다음과 같은 `네 가지` 핵심 작업을 의미합니다.
1. **Create (생성)**: 새로운 데이터를 만들어 데이터베이스에 추가합니다.
2. **Read (읽기)**: 데이터베이스에서 정보를 조회하거나 검색합니다.
3. **Update (갱신)**: 기존의 데이터를 수정하여 업데이트합니다.
4. **Delete (삭제)**: 데이터베이스에서 기존 데이터를 제거합니다.

이 네 가지 기능은 대부분의 데이터베이스 관리 시스템과 웹 애플리케이션에서 기본적으로 제공되는 핵심 기능입니다.
CRUD 작업을 통해 데이터를 효과적으로 관리하고 조작할 수 있습니다. 아래에서 더 자세히 알아봅시다.

## 4.1 Read 연산
Read는 데이터베이스에서 **정보를 조회하거나 검색**하는 기능입니다.

```python
# ID의 순서대로 정렬
latest_posts = Post.objects.all().order_by('id')

# ID의 역순으로 정렬 (최신 글이 위에 오도록)
latest_posts = Post.objects.all().order_by('-id')

# 원하는 하나의 Post 객체 가져오기
specific_post = Post.objects.get(id=1)

# 조건에 맞는 Post 객체 모두 가져오기
filtered_posts = Post.objects.filter(title__contains='Django')
```
`order_by`를 통해서, 데이터를 정렬할 수 있습니다.
`get()`은 선택한 하나의 객체를 반환합니다.
`filter()`는 조건에 맞는 모든 객체를 쿼리셋으로 반환합니다.

쿼리셋은 **인덱싱**과 **슬라이싱**이 가능하지만, **음수 인덱싱**은 지원되지 않습니다.

### 4.1.1 get과 filter의 차이
Django에서 데이터를 찾을 때 `all()`, `get()`, `filter()` 세 가지 방법을 주로 사용합니다. 
세가지 모두 Django ORM에서 데이터를 조회할 용도로 사용하기에 비슷해 보이지만 중요한 차이가 있습니다.
아래의 그림을 보면서 함께 알아봅시다.
::img{alt="" src="/images/basecamp-django/chapter03/02-2.png"}
첫번째로 `all()`은 **조건 없이, 있는 모든 데이터**를 가져옵니다. DB에게 모든 학생의 정보 모두 달라고 요청하는 것입니다.

두번째로 `get()`은 **딱 하나의 결과**만을 찾습니다. 예를 들어, `get(id=00)`은 ID가 00인 난성호 학생의 정보를 가져옵니다.
"학번이 00번인 학생은 반드시 있어. 그 학생 정보 줘!"라고 확신을 가지고 DB에게 요청하는 것입니다. 
하지만 이 확신 때문에, `get()`은 **만약 요청하는 데이터가 없거나 여러개가 있다면 오류를 발생**시킵니다.

마지막으로 `filter()`는 **조건에 맞는 모든 것**을 찾아줍니다. 위의 이미지처럼 `filter(학년=3)`은 3학년인 오효림과 평하진의 정보를 가져옵니다.
"3학년 학생들 있으면 명단 좀 줘볼래?"라고 DB에게 부드럽게 요청하는 것과 비슷합니다.
filter()는 결과가 있든 없든, 하나이든 여러 개이든 상관없이 조용히 결과를 제공합니다. 조건에 맞는 데이터가 없다면, 빈 목록을 줍니다.

`all()`은 모든 데이터를, `get()`은 반드시 존재해야 하는 하나의 데이터를, `filter()`는 조건에 맞는 데이터가 있으면 찾아주는 방식으로 데이터를 조회합니다.
이 차이를 알고, 상황에 맞게 알맞은 방법을 사용하면 됩니다.

### 4.1.2 주요 필터 조건
아래는 ORM 쿼리에서 사용하는 연산자입니다.
- `__eq`: 같음 (=)
- `__ne`: 같지 않음 (<>)
- `__lt`: 작음 (<)
- `__le`: 작거나 같음 (<=)
- `__gt`: 큼 (>)
- `__ge`: 크거나 같음 (>=)      

연산자의 사용 예시와 추가적으로 자주 사용되는 조건들 입니다.
```python
# ID가 3보다 작은 Post 객체들
posts = Post.objects.filter(id__lt=3) 

# 제목에 'Django'가 포함된 Post 객체들
django_posts = Post.objects.filter(title__contains='Django')

# 대소문자 상관없이 정확하게 일치하는 항목 찾기
User.objects.filter(username__iexact='john')
```
`__contains`는 조건이 포함된 객체를 찾습니다. `__iexact`는 대소문자 상관없이 정확하게 일치하는 것을 찾습니다.
이런 연산자들과 조건을 통해서 필터를 사용 할 수 있습니다.

## 4.2 Create 연산
Create는 **새로운 데이터**를 생성해서, 데이터베이스에 **추가**하는 기능입니다.
```python
# 새 Post 객체 생성 및 저장
new_post = Post.objects.create(title="새 글", content="내용")

# 또는
new_post = Post(title="새 글", content="내용")
new_post.save()
```

## 4.3 Delete 연산
Delete는 데이터베이스에서 **기존 데이터를 제거**하는 기능입니다.

```python
# 특정 Post 객체 삭제
post_to_delete = Post.objects.get(id=3)
post_to_delete.delete()

# 조건에 맞는 모든 Post 객체 삭제
Post.objects.filter(title__contains='임시').delete()
```
특정 객체를 하나씩 삭제할 수도 있고, 여러 객체를 한번에 삭제할 수도 있습니다.

## 4.4 Update 연산
Update는 기존의 데이터를 **수정하여 업데이트**하는 기능입니다.
```python
post_to_update = Post.objects.get(id=1)
post_to_update.title = "수정된 제목"
post_to_update.save()
```
:::div{.callout}
수정 후에는 반드시 `.save()`를 해주어야 DB에 반영이 됩니다.
:::
# 5. 참고 사항
ORM 쿼리셋에 대해서 더 궁금한 사항이 있다면, 아래의 장고 공식 문서를 참고하세요.
::a[Django 공식 문서- Making queries]{class='btn-link' href="https://docs.djangoproject.com/en/5.0/topics/db/queries/" target="\_blank"}