---
chapter: Model과 DataBase
title: DB 모델 관계 실습
date: 2024-08-02
---
데이터베이스에서 **모델 관계**는 서로 다른 테이블 간의 연결을 의미하며, 이는 데이터의 구조와 의미를 정의하고 일관성을 유지하는 데 중요한 역할을 합니다. Django에서는 주로 `일대다(1:N)`, `다대다(N:M)`, `일대일(1:1)` 세 가지 유형의 관계를 다룹니다.
실습을 통해 이러한 각 관계 유형을 Django에서 어떻게 구현하고 활용하는지 자세히 알아보겠습니다.     

# 1. 개발 환경 설정
아래 코드를 복사해서, 작업할 폴더의 터미널에 `shift + insert`합니다. 
```bash
mkdir db
cd db
python -m venv venv
.\venv\Scripts\activate
pip install django
pip install pillow
django-admin startproject tutorialdjango .
python manage.py migrate
python manage.py startapp blog
```
`db` 폴더를 생성하고, 가상환경 설치, `django`,`pillow` 라이브러리 설치, blog앱 생성까지 완료되었습니다.

# 2. settings.py 수정
이제는 `settings.py`를 한번에 수정해 봅시다.
```python
#tutorialdjango > settings.py
ALLOWED_HOSTS = ['*']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',
]

LANGUAGE_CODE = "ko-kr"
TIME_ZONE = "Asia/Seoul"

STATIC_URL = "static/"
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

MEDIA_ROOT = BASE_DIR / "media"
MEDIA_URL = "/media/"
```
`LANGUAGE_CODE`와 `TIME_ZONE` 설정은 한국어와 한국 시간대를 사용하도록 하는 것 입니다.
장고에서 static과 media를 사용할 수 있도록, 설정을 수정해 줍니다.
```bash
mkdir static
mkdir media
```
프로젝트 디렉토리에 media와 static 폴더도 생성해주세요.

# 3. model.py 수정
```python
#blog > models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(
        upload_to='blog/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='blog/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)

    def __str__(self):
        return self.title
```
Post 모델은 블로그 게시물의 구조를 정의하며, 제목(title), 내용(content), 대표 이미지(head_image), 첨부 파일(file_upload), 생성 시간(created_at), 수정 시간(updated_at) 등의 필드를 포함합니다. 이때 대표 이미지와 첨부 파일은 각각 `blog/images/연/월/일/`과 `blog/files/연/월/일/` 형식의 폴더에 저장됩니다. 한 폴더 내에 너무 많은 파일들이 있으면, 특정 파일을 찾기 어려워지고 시스템 성능에도 악영향을 미칠 수 있습니다. 그것을 방지하기 위해 자세한 경로를 사용합니다.

# 4. 관리자 페이지 수정 및 슈퍼유저 생성
`blog/admin.py` 파일을 수정합니다.
```python
#blog > admin.py
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```
`Post` 모델을 Django 관리자 페이지에 등록합니다. 이제 관리자 인터페이스에서 게시물을 쉽게 생성, 조회, 수정, 삭제할 수 있게 됩니다.
데이터베이스에 변경사항을 적용하고 슈퍼유저를 생성합니다.
```bash
python manage.py makemigrations
python manage.py migrate
python manage.py createsuperuser
```

# 5. url.py 수정
- tutorialdjango > urls.py
```python
#tutorialdjango > urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path("admin/", admin.site.urls),
    path("blog/", include("blog.urls")),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```
- blog > urls.py
```python
#blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog_list, name='blog_list'),
    path('<int:pk>/', views.blog_detail, name='blog_detail'),
]
```
# 6. view.py 수정
- blog > view.py
```python
#blog > view.py
from django.shortcuts import render
from .models import Post

def blog_list(request):
    posts = Post.objects.all()
    return render(request, 'blog/blog_list.html', {'posts':posts})

def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    return render(request, "blog/blog_detail.html", {"post": post})
```
# 7. templates 수정
```
db/
├── media/
├── templates/
├── static/
└── blog/
    └── template/
        └── blog/
            ├── blog_list.html
            └── blog_detail.html
```
blog 앱 안에 `template` 폴더를 만들고,
`blog_list.html`파일과 `blog_detail.html`파일을 빈 상태로 만들어 주세요.
# 8. 서버 실행 및 테스트
```bash
python manage.py runserver
```
2. 관리자 페이지(`http://127.0.0.1:8000/admin/`)에 접속해서 블로그 포스트 3개를 만듭니다.

# 9. 데이터베이스 기초
데이터베이스에서 모델 관계는 서로 다른 테이블 간의 연결을 의미합니다. 이는 데이터의 구조와 의미를 정의하고 일관성을 유지하는 데 중요한 역할을 합니다.
## 9.1 데이터베이스 주요 용어
데이터베이스를 다루는 아주 간단한 용어 몇 가지만 소개하고 넘어가겠습니다. 
| 데이터베이스 관계도 | ERD | 
| ------------------------------------------ | ------------------------------------------ |
| ![](/images/basecamp-django/chapter03/04-1.png) | ![](/images/basecamp-django/chapter03/04-2.png) |
1. **관계형 데이터베이스(Relational Database)**: 데이터를 표 형태의 구조(테이블)로 저장하고 관리하는 데이터베이스 시스템입니다. 각 테이블은 서로 관계를 가질 수 있어, 복잡한 데이터 구조를 효율적으로 표현하고 관리할 수 있습니다
2. **엔티티(Entity)**: 이미지에서 볼 수 있듯이, 엔티티는 데이터베이스에서 **하나의 독립적인 객체나 개념**을 나타냅니다. 예를 들어, 학생 정보를 담고 있는 `테이블`이 하나의 엔티티가 됩니다. 이 테이블에는 학번, 이름, 주소, 전화번호 등의 정보가 포함되어 있습니다.
3. **기본키(Primary Key)**: 이미지에서 '학번' 열이 기본키로 표시되어 있습니다. 기본키는 각 행를 고유하게 식별하는 속성으로, 여기서는 2401, 2402 등의 학번이 각 학생을 구별하는 고유한 식별자 역할을 합니다.
4. **외래키(Foreign Key)**: 이미지의 아래쪽 테이블에서 '학번' 열이 외래키로 사용되고 있습니다. 이 외래키는 위쪽 테이블의 기본키를 참조하여, 두 테이블 간의 관계를 설정합니다. 예를 들어, 학생의 신청과목 정보가 학번을 통해 학생 정보와 연결됩니다.
5. **ERD(Entity-Relationship Diagram)**: 엔티티 간의 관계를 시각적으로 표현한 다이어그램입니다. ERD를 통해 데이터베이스의 구조와 엔티티 간의 관계를 한눈에 파악할 수 있습니다. 

## 9.2 모델 관계 유형
Django에서는 주로 `일대다(1:N)`, `다대다(N:M)`, `일대일(1:1)` 세 가지 유형의 관계를 다룹니다.            
`일대다(1:N)` 관계의 예로는 **학교와 학생의 관계**를 들 수 있습니다. 한 학교에는 여러 학생이 있지만 각 학생은 하나의 학교에만 속하는 것처럼, '일(1)' 쪽의 하나의 레코드가 '다(N)' 쪽의 여러 레코드와 연결될 수 있습니다. Django에서는 이를 `ForeignKey` 필드를 사용하여 구현합니다.     
`다대다(N:M)` 관계는 **학생과 수업의 관계**로 설명할 수 있습니다. 한 학생이 여러 수업을 들을 수 있고 한 수업에 여러 학생이 참여할 수 있듯이, 양쪽 모델의 인스턴스가 서로 여러 개의 인스턴스와 연결될 수 있습니다. Django에서는 이러한 관계를 `ManyToManyField`를 사용하여 구현합니다.       
마지막으로 `일대일(1:1)` 관계는 **사용자와 학번의 관계**를 예로 들 수 있습니다. 각 사용자는 하나의 번호만을 가지며 학번은 하나의 사용자에만 속하는 것처럼, 한 모델의 각 인스턴스가 다른 모델의 인스턴스와 단 하나씩만 연결됩니다. Django에서는 이를 `OneToOneField`를 사용하여 구현합니다.     
| 일대다(1 : N) | 다대다(N : M) | 일대일(1 : 1) |
| ------------------------------------------ | ------------------------------------------ | ------------------------------------------ |
| ![](/images/basecamp-django/chapter03/04-3.png) | ![](/images/basecamp-django/chapter03/04-4.png) | ![](/images/basecamp-django/chapter03/04-5.png) |

# 10. 글쓴이(Author) 추가하기
게시물의 글쓴이를 나타낼 수 있게, author을 추가해봅시다. 생각해 보면, 글쓴이 한명은 여러 글을 쓸 수 있지만 글 하나가 여러 글쓴이를 가질 수는 없습니다. 그러니 1 : n 관계에 사용하는 ForeingnKey를 이용해 `models.py`를 수정해봅시다.
```python
#blog > models.py
from django.db import models
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(upload_to="blog/images/%Y/%m/%d/", blank=True)
    file_upload = models.FileField(upload_to="blog/files/%Y/%m/%d/", blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE)

    def __str__(self):
        return self.title
```
이때 주의해야 할 점이 있습니다.
**1 : N 관계에서 ForeignKey는 항상 N 쪽에 작성합니다.** 예를 들어, 한 사용자가 여러 게시물을 작성할 수 있으므로, ForeignKey는 게시물 모델에 둡니다. 이렇게 하면 각 게시물은 자신의 작성자를 쉽게 참조할 수 있고, 한 사용자의 모든 게시물을 효율적으로 찾을 수 있습니다.        
반대로 ForeignKey를 사용자 모델에 두면 여러 문제가 발생합니다. 예를 들어, 한 사용자가 100개의 게시물을 작성했다고 가정해 봅시다. 이 경우 사용자 모델에 100개의 게시물 참조를 저장해야 하며, 새 게시물을 작성할 때마다 사용자 정보를 수정해야 합니다. 또한 사용자가 작성할 수 있는 게시물 수에 제한이 생기고, 특정 게시물의 작성자를 찾으려면 모든 사용자 정보를 검색해야 하는 비효율이 발생합니다. 이런 이유로 ForeignKey는 항상 '다수(N)' 쪽인 게시물 모델에 두는 것이 바람직합니다.

모델을 수정했으니 `makemigrations -> migrate`를 해줍니다.
```
python manage.py makemigrations
python manage.py migrate
```
이때 `makemigrations`을 하면, 아래와 같은 알림 사항이 뜹니다.
::img{alt="" src="/images/basecamp-django/chapter03/04-6.png"}
`post` 모델에 `author` 필드를 새로 넣으려고 하는데, `author` 필드는 반드시 값이 있어야 합니다.
그런데 이미 있던 게시물들은 author 정보가 없기 때문에 생긴 문제입니다.
이때 Django는 이 문제를 해결할 두 가지 방법을 제안하는데,
1) 지금 모든 기존 게시물에 대해 임시로 같은 값을 넣는 방법
2) 일단 멈추고 코드에서 기본값을 정해주는 방법 입니다.      

1번을 입력하면 새로운 필드에 대한 기본값을 입력하라는 프롬프트가 나타납니다.
이때 `>>>` 프롬프트에 `1`을 입력하면, 데이터베이스의 User 모델에서 ID가 1인 사용자가 모든 기존 게시물의 author로 설정됩니다.
::img{alt="" src="/images/basecamp-django/chapter03/04-7.png"}
위 이미지 처럼 Author이 추가된 것을 볼 수 있습니다.

## 10.1 CASCADE 실습
아래는 수정한 models.py 에서 추가된 코드입니다.
```python
author = models.ForeignKey(User, on_delete=models.CASCADE)
```
이 코드는 유저를 삭제했을 때 이 유저와 연관된 게시물을 함께 삭제하겠다는 의미입니다.
다른 유저 계정을 생성해서, 실행이 되는지 테스트 해봅시다.

우선 서버를 키고, 관리자페이지 > 사용자 추가를 클릭해서 새로운 유저를 만들어 줍니다. 임의로 `leehojun2`라는 유저를 생성했습니다.
`사용자(들)`을 클릭해보면, 유저가 한명 더 생성된 것을 확인할 수 있습니다.
::img{width="800" alt="" src="/images/basecamp-django/chapter03/04-8.png"}

게시물을 3개 더 작성해 줍니다. 이때 Author은 이미지와 같이 새로 만든 유저로 설정해 주세요.
::img{width="800" alt="" src="/images/basecamp-django/chapter03/04-9.png"}

게시물이 6개가 되었습니다. 이제 유저를 삭제해보겠습니다. `사용자(들)`에서 삭제할 유저를 선택하고, 액션에서 삭제 선택, 실행을 누르면 유저가 삭제됩니다.
::img{width="800" alt="" src="/images/basecamp-django/chapter03/04-10.png"}
Post를 확인해보면, `leejojun2`으로 만든 게시물이 삭제된 것을 확인 할 수 있습니다.

`blog_list.html`파일을 수정해, blog 페이지에서 게시물이 잘 보이는지 확인해봅시다.
- templates > blog > blog_list.html
```
<!-- templates > blog > blog_list.html -->
{% for i in posts %}
    <h1>{{ i.title }}</h1>
    <p>{{ i.content }}</p>
    <p>{{ i.author }}</p>
    <hr>
{% endfor %}
```
:::div{.callout}
유저가 삭제되었을 때, 게시글을 보존하고 싶다면, 글쓴이를 빈칸으로 만들 수 있습니다.
아래 코드 처럼 on_delete을 `models.CASCADE`대신 `models.SET_NULL`로 설정하면 author가 빈칸이 됩니다.
```python
author = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
```
`on_delete=models.SET_NULL`을 사용하고 싶으면, `null=True`과 같이 이 필드에 null값이 들어 갈 수 있게 설정해야합니다.
:::

# 11. 태그, 댓글 기능 추가하기
이번에는 **태그**와 **댓글**을 추가해 봅시다. 
`태그`에 대해서 생각해보면, 한 게시물은 여러개의 태그를 가질 수 있고, 한 태그는 여러 게시물에 속할 수 있습니다. 그러니 게시물과 태그는 `다대다(N : M)`관계를 이룹니다.
`댓글`은 하나의 게시물에서 여러 댓글을 가질 수 있습니다. 하지만 댓글은 하나의 게시물에만 속합니다. 그러니 게시물과 댓글은 `일대다(1 : N)`관계를 가집니다.
앞서 실습했던 것과 같이 일대다 관계에는 `ForeingnKey`를 다대다 관계에는 `ManyToManyField`를 사용합니다.     
## 11.1 models.py 수정하기
우선 models.py를 수정해 태그와 댓글 모델을 추가합니다.
- models.py
```python
#blog > models.py
from django.db import models
from django.contrib.auth.models import User

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(
        upload_to='blog/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='blog/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    author = models.ForeignKey(
        User, on_delete=models.CASCADE
    )
    # tags필드를 추가합니다. 
    tags = models.ManyToManyField('Tag', blank=True)

    def __str__(self):
        return self.title

#새로운 Comment모델을 추가합니다.
class Comment(models.Model):
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    post = models.ForeignKey(
        Post, on_delete=models.CASCADE, related_name='comments'
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE
    )

    def __str__(self):
        return self.message
    
class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name
```
Post 모델에 tags 필드를 추가하여 Tag 모델과 다대다 관계를 설정합니다.
Comment 모델을 새로 생성하고, post 필드를 통해 Post 모델과 일대다 관계를 설정했습니다.
::img{width="800" alt="" src="/images/basecamp-django/chapter03/04-16.png"}
이때 Comment 모델에서 `related_name='comments'`를 사용하여 Post 모델에서 연결된 댓글들을 쉽게 접근할 수 있게 했습니다.
여기서 `related_name`은 Post에서 Comment를 부를 때 사용할 이름입니다. 템플릿 문법에서 아래와 같이 호출됩니다.
`{% for comment in post.Comment.all %}`

모델을 변경했으므로 이를 데이터베이스에 반영해야 합니다. 
```bash
python manage.py makemigrations
python manage.py migrate
```
## 11.2 admin.py 수정하기
새로 만든 모델들을 관리자 페이지에서 관리할 수 있도록 admin.py 파일을 수정합니다.
- admin.py
```python
#blog > admin.py
from django.contrib import admin
from .models import Post, Comment, Tag

admin.site.register(Post)
admin.site.register(Comment)
admin.site.register(Tag)
```
이제 서버를 키고, 관리자 페이지에서 변경사항을 확인해봅시다.
::img{width="800" alt="" src="/images/basecamp-django/chapter03/04-12.png"}
왼쪽 상단 위에 Comments와 Tags가 추가된 것을 볼 수 있습니다.
또 새 글을 작성할 때 태그를 선택할 수 있도록 추가되었습니다.        
댓글과 태그을 달아보세요. 이제 관리자 페이지에서 작성한 댓글과 태그를 blog 사이트에서 볼수 있도록 만들어 봅시다.

## 11.3 템플릿 파일 수정하기
블로그 목록과 상세 페이지에서 태그와 댓글을 표시하도록 템플릿을 수정합니다.
- blog_list.html
```html
<!-- blog_list.html -->
{% for post in posts %}
    <h1>{{ post.title }}</h1>
    <p>{{ post.content }}</p>
    <p>{{ post.author }}</p>
    {% for comment in post.comments.all %}
        <p>{{ comment.message }}</p>
    {% endfor %}
    {% for tag in post.tags.all %}
        <p>{{ tag.name }}</p>
    {% endfor %}
    <hr>
{% endfor %}
```
댓글이나 태그를 가져올때 다음과 같은 코드는 사용하지 않습니다.
```html
<p>{{ post.comments }}</p>
<p>{{ post.tags }}</p>
```
대신 아래의 코드를 사용해야 합니다.
```html
{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}
{% for tag in post.tags.all %}
    <p>{{ tag.name }}</p>
{% endfor %}
```
Django에서 `post.comments`나 `post.tags`를 직접 사용하면 실제 데이터를 보여주지 않습니다. 비유하자면 책이 꽂혀있는 책장을 가리키기만 하는 것과 같아서, 책의 내용을 볼 수 없습니다. 그래서 `.all()`을 사용합니다. 
`{% for comment in post.comments.all %}`는 "책장에서 모든 책을 꺼내 하나씩 읽어보자"와 같습니다.
이렇게 하면 실제 댓글이나 태그 데이터를 가져와서 보여줄 수 있습니다.
- blog_detail.html
```html
<!-- blog_detail.html -->
<h1>{{ post.title }}</h1>
<p>{{ post.author }}</p>
<p>{{ post.content }}</p>

{% for tag in post.tags.all %}
    <p>{{ tag.name }}</p>
{% endfor %}

{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}
```
::img{width="" alt="" src="/images/basecamp-django/chapter03/04-13.png"}
blog 상세페이지 화면입니다.
위에서 부터 태그와, 댓글, 댓글을 작성할 수 있는 폼까지 있는 것을 확인 할 수 있습니다.

# 12 태그 모아보기 기능 추가하기
태그를 클릭하면, 태그가 달린 게시물을 모아서 볼 수 있도록 만들어봅시다.
## 12.1 urls.py 수정하기
우선 tag별로 모아서 볼 수 있도록, url패턴을 추가해줍니다.
```python
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("tag/<str:tag>/", views.blog_tag, name="blog_tag"),
]
```
## 12.2 views.py 수정하기
tag url에 들어가면 실행될 view함수를 정의합니다.
```python
# views.py
from django.shortcuts import render
from .models import Post, Comment, Tag

def blog_list(request):
    posts = Post.objects.all()
    return render(request, "blog/blog_list.html", {"posts": posts})

def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    if request.method == "POST":
        author = request.user
        message = request.POST["message"]
        c = Comment.objects.create(author=author, message=message, post=post)
        c.save()
    return render(request, "blog/blog_detail.html", {"post": post})

def blog_tag(request, tag):
    posts = Post.objects.filter(tags__name__iexact=tag)
    return render(request, "blog/blog_list.html", {"posts": posts})
```
```python
def blog_tag(request, tag):
    posts = Post.objects.filter(tags__name__iexact=tag)
    return render(request, "blog/blog_list.html", {"posts": posts})
```
ORM 쿼리의 필터 기능을 이용해서, 클릭한 태그와 일치하는 태그를 가진 모든 게시물을 찾아서 보여줍니다.
## 12.3 템플릿 수정하기
태그를 클릭하면 해당 태그의 게시물 목록으로 이동할 수 있도록 템플릿을 수정합니다.
```html
<!-- blog_detail.html -->
<h1>{{ post.title }}</h1>
<p>{{ post.content }}</p>
<p>{{ post.author }}</p>

{% for tag in post.tags.all %}
    <a href="/blog/tag/{{ tag.name }}">#{{ tag.name }}</a>
{% endfor %}

{% for comment in post.comments.all %}
    <p>{{ comment.message }}</p>
{% endfor %}

<form action="" method="post">
    {% csrf_token %}
    <input type="text" name="message">
    <input type="submit">
</form>
```
## 12.4 실행 및 테스트
서버를 열고 블로그 상세페이지에서 태그를 클릭해 잘 작동하는지 테스트해봅시다.
아래는 실제 화면 입니다.
| 블로그 상세 페이지 | 태그 페이지 | 
| ------------------------------------------ | --------------------------------------------------------- |
| ![](/images/basecamp-django/chapter03/04-14.png) | ![](/images/basecamp-django/chapter03/04-15.png) |

태그를 클릭하면, 그 태그가 포함된 게시물만 보여주는 것을 확인할 수 있습니다.