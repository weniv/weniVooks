---
chapter: Model과 DataBase
title: CRUD 구현, 이미지 파일 실습
date: 2024-07-30
---
Django로 웹사이트를 만들 때 가장 기본이 되는 CRUD기능을 실제로 구현해보겠습니다. 
이 기능들을 직접 만들어보면, 웹사이트가 어떻게 데이터를 다루는지, 그리고 어떻게 동작하는지 더 쉽게 이해할 수 있습니다. 
앞서 만든 프로젝트를 수정해서, CRUD과정을 Django로 어떻게 만드는지 함께 알아보겠습니다.

# 1. 게시물 생성
먼저 게시물을 생성하는 기능을 추가해 봅시다. 관리자페이지(admin)에서 직접 생성할 수도 있지만, 이 실습에서는 url을 통해서 생성해보도록 하겠습니다.

## 1.1 blog앱의 urls.py 수정
```python
# blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/<str:title>/", views.blog_create, name="blog_create"),
    path("test/", views.blog_test, name="test"),
]
```
`path("create/<str:title>/", views.blog_create, name="blog_create")` 부분을 추가합니다.         
`blog/create/게시글 제목`으로 url을 작성하면, view함수가 실행됩니다.

## 1.2 blog앱의 views.py 수정
```python
# blog > views.py
from django.shortcuts import render, redirect
from .models import Post

def blog_list(request):
    blogs = Post.objects.all()
    context = {"db": blogs}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    blog = Post.objects.get(pk=pk)
    context = {"db": blog}
    return render(request, "blog/blog_detail.html", context)

def blog_create(request, title):
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")

def blog_test(request):
    return render(request, "blog/blog_test.html")
```
위에는 전체 코드 입니다.

```python
def blog_create(request, title): 
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")
```
view.py에 blog_create 함수를 추가합니다. 

url 링크를 입력하게 되면 blog_create 함수가 실행됩니다.
blog_create 함수에는 객체를 생성하는 ORM쿼리가 있어, 입력한 이름을 제목으로 가진 게시물이 생성됩니다.

# 2. 게시물 삭제
게시물 생성과 마찬가지로, url을 통해서 게시물을 삭제할 수 있게 만들어봅시다. 물론 관리자페이지에서도 가능합니다.

## 2.1 blog앱의 urls.py 수정
```python
# blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/<str:title>/", views.blog_create, name="blog_create"),
    path("delete/<int:pk>/", views.blog_delete, name="blog_delete"),
]
```
`path("delete/<int:pk>/", views.blog_delete, name="blog_delete")` 부분이 추가됩니다.              
blog/delete/게시글 제목을 입력하면, blog_delete함수가 실행됩니다.

## 2.2 blog앱의 views.py 수정
```python
# blog > views.py
from django.shortcuts import render, redirect
from .models import Post

def blog_list(request):
    blogs = Post.objects.all()
    context = {"db": blogs}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    blog = Post.objects.get(pk=pk)
    context = {"db": blog}
    return render(request, "blog/blog_detail.html", context)

def blog_create(request, title):
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")

def blog_delete(request, pk):
    q = Post.objects.get(pk=pk)
    q.delete()
    return redirect("blog_list")
```
위 코드는 전체 코드 입니다.         
아래 코드가 추가되었습니다.
```python
def blog_delete(request, pk):
    q = Post.objects.get(pk=pk)
    q.delete()
    return redirect("blog_list")
```
# 3. 서버 실행 및 작동 테스트
서버를 실행하고 아래 링크를 입력해 봅시다.

`http://127.0.0.1:8000/blog/create/orm/`        
`http://127.0.0.1:8000/blog/create/jeju/`       
`http://127.0.0.1:8000/blog/create/hello/`      
`http://127.0.0.1:8000/blog/delete/hello/`      
`http://127.0.0.1:8000/blog/delete/orm/`        

생성과 삭제가 잘 되는 것을 확인해주세요.

# 4. 미디어 파일

웹 애플리케이션에서 이미지와 같은 미디어 파일을 다루는 것은 매우 중요한 기능입니다. Django에서는 이러한 미디어 파일을 효과적으로 관리할 수 있는 도구를 제공합니다. 이번에는 블로그 게시물에 이미지를 추가하고 관리하는 방법에 대해 알아보겠습니다.

먼저, 이미지 처리를 위해 Pillow 라이브러리를 설치해야 합니다. Pillow는 Python에서 이미지를 처리하는 데 널리 사용되는 라이브러리입니다.
<!-- 03-1장에서 개발환경을 설정할때 이미 설치 했지만, 하지 못했을 수 있으니~ -->
```
pip install pillow
```

이제 블로그 게시물 모델에 이미지 필드를 추가해보겠습니다.

```python
# blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    main_image = models.ImageField(upload_to='blog/', blank=True, null=True) 
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title
```

여기서 `main_image` 필드는 `ImageField`로 정의되어 있습니다. `upload_to='blog/'`는 업로드된 이미지가 'blog/' 폴더에 저장될 것임을 지정합니다. `blank=True`와 `null=True`는 이 필드가 선택적임을 나타냅니다. 즉, 모든 게시물에 이미지가 반드시 있어야 하는 것은 아닙니다.

모델을 변경했으므로 데이터베이스에 이 변경사항을 적용해야 합니다.

```
python manage.py makemigrations
python manage.py migrate
```

다음으로, 프로젝트의 settings.py 파일에 미디어 파일 관련 설정을 추가합니다.

```python
STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
```

이 설정은 정적 파일과 미디어 파일의 URL과 저장 위치를 지정합니다.

그리고 프로젝트의 urls.py 파일에 미디어 파일을 서빙하기 위한 URL 패턴을 추가합니다.

```python
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path("blog/", include("blog.urls")),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

이제 템플릿에서 이미지를 표시할 수 있습니다. blog_detail.html 템플릿을 다음과 같이 수정합니다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <title>blog_detail</title>
</head>
<body>
    <h1>blog_detail</h1>
    <h2>{{ object.title }}</h2>
    <p>{{ object.content }}</p>
    <p>{{ object.created_at }}</p>
    <p>{{ object.updated_at }}</p>
    {% if object.main_image %}
        <img src="{{ object.main_image.url }}" alt="">
    {% endif %}
    <a href="{% url 'blog_list' %}">목록</a>
</body>
</html>
```
이제 관리자 페이지에서 이미지가 있는 게시물을 생성해보세요. 생성된 게시물의 상세 페이지에서 이미지가 표시되는 것을 확인할 수 있습니다.

만약 이미지가 보이지 않는다면, 파일이 제대로 저장되었는지 확인해보세요.
`'media/blog/'` 폴더에 이미지 파일이 있어야 합니다.
같은 이름의 파일을 여러 번 업로드하면 Django는 자동으로 파일 이름에 난수를 추가하여 저장합니다.

이렇게 Django에서 미디어 파일을 다루는 기본적인 방법에 대해 알아보았습니다. 이를 통해 블로그 게시물에 이미지를 추가하고 표시할 수 있게 되었습니다.

# 5. 검색 기능 구현
- view.py 수정
```python
#views.py
from django.shortcuts import render
from .models import Post
from django.db.models import Q

def blog_list(request):
    if request.GET.get("q"):
        q = request.GET.get("q")
        blogs = Post.objects.filter(
            Q(title__icontains=q) | Q(content__icontains=q)
        ).distinct()
    else:
        blogs = Post.objects.all()
    context = {
        "object_list": blogs,
    }
    return render(request, "blog/blog_list.html", context)
```
request.GET.get("q")를 사용하여 검색어를 가져옵니다. 이는 URL의 쿼리 파라미터에서 'q' 값을 찾는 것입니다.
Django의 Q 객체를 사용하여 복잡한 쿼리를 생성합니다.
`Q(title__icontains=q) | Q(content__icontains=q)`는 제목 또는 내용에 검색어가 포함된 게시물을 찾습니다.
distinct()를 사용하여 중복된 결과를 제거합니다.

- 템플릿에서 검색 폼 추가 (blog_list.html)
```html
<h1>게시판</h1>
<form action="" method="get">
    <input name="q" type="search">
    <button type="submit">검색</button>
</form>
<ul>
    {% for blog_detail in object_list %}
    <li>
        <a href="{% url 'blog_detail' blog_detail.id %}">{{ blog_detail.title }}</a>
        <p>{{blog_detail.content}}</p>
        {% if blog_detail.main_image %}
            <img src="{{ blog_detail.main_image.url }}" alt="" style="width: 100px;">
        {% endif %}
    </li>
    {% endfor %}
</ul>
```
이 템플릿은 검색 폼과 검색 결과를 표시합니다. 폼의 method="get"은 검색어를 URL의 쿼리 파라미터로 전송합니다.

만약 검색 기능에서 오류가 발생한다면, 다음 사항들을 확인해보세요.
1. URL 설정: 검색 기능이 올바른 URL과 연결되어 있는지 확인합니다.
2. 폼 이름: 템플릿의 input 태그 name이 'q'인지 확인합니다.
3. 모델 필드명: Post 모델의 필드 이름이 'title'과 'content'인지 확인합니다.
4. 대소문자 구분: icontains를 사용하여 대소문자를 구분하지 않도록 했는지 확인합니다.
5. 데이터베이스 연결: 데이터베이스 연결에 문제가 없는지 확인합니다.