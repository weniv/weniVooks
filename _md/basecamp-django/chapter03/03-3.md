---
chapter: Model과 DataBase
title: CRUD와 이미지 업로드
date: 2024-07-30
---
웹사이트에서 CRUD와 검색은 아주 기본적인 기능입니다. 이런 기본적인 기능들은 거의 모든 웹사이트에서 사용하고 있고, 이를 효과적으로 구현하는 것이 웹 개발의 기초가 될 수 있습니다. 이 실습을 통해 이러한 핵심 기능들을 직접 구현해봄으로써, 여러분은 Django를 사용한 웹 개발의 기초를 탄탄히 다지고 더 복잡한 프로젝트를 위한 견고한 기반을 마련할 수 있을 것입니다.
# 1. 게시물 생성
먼저 게시물을 생성하는 기능을 추가해 봅시다. 
관리자 페이지에서 직접 생성할 수도 있지만, 이 실습에서는 url을 통해서 생성해보도록 하겠습니다.
## 1.1 blog앱의 urls.py 수정
```python
# blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/<str:title>/", views.blog_create, name="blog_create"),
]
```
urls.py파일에 url패턴을 추가합니다.
`path("create/<str:title>/", views.blog_create, name="blog_create")` 부분입니니다.     

## 1.2 blog앱의 views.py 수정
url을 추가했다면, 그에 맞는 view함수가 필요합니다.
```python
def blog_create(request, title): 
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")
```
create url에 접속하면 실행되는 `blog_create`함수를 추가합니다.
blog_create 함수의 내용을 보면, 입력한 title을 객체로 생성하는 ORM쿼리가 있습니다. 
이 쿼리로 입력한 이름을 제목으로 가진 게시물이 생성됩니다.
이제부터 `blog/create/게시글 제목`으로 url을 작성하면 게시물이 생성됩니다.      
아래는 전체 코드입니다.
```python
# blog > views.py
from django.shortcuts import render, redirect
from .models import Post

def blog_list(request):
    blogs = Post.objects.all()
    context = {"db": blogs}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    blog = Post.objects.get(pk=pk)
    context = {"db": blog}
    return render(request, "blog/blog_detail.html", context)

def blog_create(request, title):
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")

def blog_test(request):
    return render(request, "blog/blog_test.html")
```
## 1.3 서버 실행 및 테스트
이제 서버를 실행하고 아래 링크를 입력합니다.     
`http://127.0.0.1:8000/blog/create/orm/`        
`http://127.0.0.1:8000/blog/create/jeju/`       
`http://127.0.0.1:8000/blog/create/hello/`      

입력한 텍스트의 이름을 가진 페이지가 생성되는 지 확인해봅시다!

# 2. 게시물 삭제
게시물 생성과 마찬가지로, url을 통해서 게시물을 삭제할 수 있게 만들어봅시다. 물론 관리자 페이지에서도 가능합니다.

## 2.1 blog앱의 urls.py 수정
```python
# blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/<str:title>/", views.blog_create, name="blog_create"),
    path("delete/<int:pk>/", views.blog_delete, name="blog_delete"),
]
```
`path("delete/<int:pk>/", views.blog_delete, name="blog_delete")` 부분을 추가합니다.         

## 2.2 blog앱의 views.py 수정
삭제 기능에 맞는 view함수도 필요합니다. views.py파일에 blog_delete함수를 추가해줍니다.
```python
def blog_delete(request, pk):
    q = Post.objects.get(pk=pk)
    q.delete()
    return redirect("blog_list")
```
`Post.objects.get(pk=pk)`으로 객체를 가져와서, `delete()`로 객체를 삭제합니다.
아래는 전체 코드입니다.
```python
# blog > views.py
from django.shortcuts import render, redirect
from .models import Post

def blog_list(request):
    blogs = Post.objects.all()
    context = {"db": blogs}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    blog = Post.objects.get(pk=pk)
    context = {"db": blog}
    return render(request, "blog/blog_detail.html", context)

def blog_create(request, title):
    contents = f"hello world {title}"
    q = Post.objects.create(title=title, contents=contents)
    q.save()
    return redirect("blog_list")

def blog_delete(request, pk):
    q = Post.objects.get(pk=pk)
    q.delete()
    return redirect("blog_list")
```
## 2.3 서버 실행 및 작동 테스트
이제 서버를 실행하고 아래 링크를 입력합니다.   
`http://127.0.0.1:8000/blog/delete/hello/`      
`http://127.0.0.1:8000/blog/delete/orm/`        

게시물이 삭제가 잘 되는 것을 확인해주세요.

# 3. 이미지 업로드 실습

웹 애플리케이션에서 이미지와 같은 미디어 파일을 다루는 것은 매우 중요한 기능입니다. Django에서는 이러한 미디어 파일을 효과적으로 관리할 수 있는 도구를 제공합니다. 이번에는 블로그 게시물에 이미지를 추가하고 관리하는 방법에 대해 알아보겠습니다.      
이전 장에서 개발 환경을 설정할 때 Pillow를 이미 설치했습니다. 혹시 설치하지 않았거나 확실하지 않다면, 다음 명령어를 실행하여 Pillow를 설치해주시면 됩니다.
```bash
pip install pillow
```
## 3.1 models.py 수정
이미지 파일을 업로드 할 수 있도록, 우선 모델에 이미지 필드를 추가합니다.
```python
# blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    main_image = models.ImageField(upload_to='blog/', blank=True, null=True) 
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title
```
이 코드에서 `main_image`는 `ImageField`로 정의되어 있습니다.
`upload_to='blog/'`는 업로드된 이미지가 'blog/' 폴더에 저장될 것임을 지정합니다.
`blank=True`와 `null=True`는 이 필드가 선택적임을 나타냅니다. 즉, 모든 게시물에 이미지가 반드시 있어야 하는 것은 아닙니다.

모델을 변경했으므로 데이터베이스에 이 변경사항을 적용해야 합니다. 아래 명령어를 입력해 변경사항을 적용합니다.
```bash
python manage.py makemigrations
python manage.py migrate
```
## 3.2 settings.py 수정
다음으로 settings.py 파일에 미디어 파일 설정을 추가합니다.

```python
STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
```

## 3.3 media 폴더 생성
static 폴더를 만들때처럼, media 폴더도 만들어야 합니다.
프로젝트의 가장 상위 폴더에 static, media 폴더를 만들어주세요.
```
mysite/
├── blog/
├── templates/
├── media/
└── static/
```
## 3.4 서버 실행 및 작동 테스트
지금까지 한것들을 모두 저장하고, 서버를 실행해봅시다. 
관리자페이지에 들어가서 이미지를 포함한 게시물을 3개 만들어 주세요.

## 3.5 URL.py 수정
프로젝트의 urls.py 파일에 미디어 파일을 서빙하기 위한 URL 패턴을 추가합니다.

```python
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path("blog/", include("blog.urls")),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```
```
from django.conf import settings
from django.conf.urls.static import static
```
장고에서 사용자가 업로드한 미디어 파일을 서빙하기 위해서는 urlpatterns에 패턴을 추가해야 합니다. 이를 통해 웹 브라우저에서 업로드된 파일에 접근할 수 있습니다.
`settings.MEDIA_URL`는 올린 미디어 파일을 웹 상에서 볼때 사용되는 url 경로입니다.
`document_root=settings.MEDIA_ROOT`는 업로드된 미디어 파일이 실제 저장된 컴퓨터 상의 폴더 위치입니다. 
<!-- 우리가 만든 media폴더입니다. -->

## 3.6 템플릿 수정
관리자 페이지에서 올린 파일을 템플릿상에서 볼 수 있도록 템플릿을 수정합니다.
- blog_detail.html
```html
<!-- templates > blog > blog_detail.html -->
 <h1>게시판</h1>
<form action="" method="get">
    <input name="q" type="search">
    <button type="submit">검색</button>
</form>
<ul>
    {% for blog_detail in db %}
    <li>
        <a href="{% url 'blog_detail' blog_detail.id %}">{{ blog_detail.title }}</a>
        <p>{{blog_detail.contents}}</p>
    </li>
    {% endfor %}
</ul>
```
## 3.7 서버 실행 및 작동 테스트
이제 서버를 실행해서 작동이 되는지 확인해봅시다.
생성된 게시물의 상세 페이지에서 이미지가 표시되는 것을 확인할 수 있습니다.

만약 이미지가 보이지 않는다면, 파일이 제대로 저장되었는지 확인해보세요.
`'media/blog/'` 폴더에 이미지 파일이 있어야 합니다.
같은 이름의 파일을 여러 번 업로드하면 Django는 자동으로 파일 이름에 난수를 추가하여 저장합니다.

# 4. 검색 기능 구현
- view.py 수정
```python
#views.py
from django.shortcuts import render
from .models import Post
from django.db.models import Q

def blog_list(request):
    if request.GET.get("q"):
        q = request.GET.get("q")
        blogs = Post.objects.filter(
            Q(title__icontains=q) | Q(content__icontains=q)
        ).distinct()
    else:
        blogs = Post.objects.all()
    context = {
        "object_list": blogs,
    }
    return render(request, "blog/blog_list.html", context)
```
request.GET.get("q")를 사용하여 검색어를 가져옵니다. URL의 쿼리 파라미터에서 'q' 값을 찾는 것입니다.
Django의 Q 객체를 사용하여 복잡한 쿼리를 생성합니다.
`Q(title__icontains=q) | Q(content__icontains=q)`는 제목 또는 내용에 검색어가 포함된 게시물을 찾습니다.
distinct()를 사용하여 중복된 결과를 제거합니다.
<!-- Q 설명 -->

- 템플릿에서 검색 폼 추가 (blog_list.html)
```html
<h1>게시판</h1>
<form action="" method="get">
    <input name="q" type="search">
    <button type="submit">검색</button>
</form>
<ul>
    {% for blog_detail in object_list %}
    <li>
        <a href="{% url 'blog_detail' blog_detail.id %}">{{ blog_detail.title }}</a>
        <p>{{blog_detail.content}}</p>
        {% if blog_detail.main_image %}
            <img src="{{ blog_detail.main_image.url }}" alt="" style="width: 100px;">
        {% endif %}
    </li>
    {% endfor %}
</ul>
```
<!-- 이 템플릿은 검색 폼과 검색 결과를 표시합니다. 폼의 method="get"은 검색어를 URL의 쿼리 파라미터로 전송합니다.

만약 검색 기능에서 오류가 발생한다면, 다음 사항들을 확인해보세요.
1. URL 설정: 검색 기능이 올바른 URL과 연결되어 있는지 확인합니다.
2. 폼 이름: 템플릿의 input 태그 name이 'q'인지 확인합니다.
3. 모델 필드명: Post 모델의 필드 이름이 'title'과 'content'인지 확인합니다.
4. 대소문자 구분: icontains를 사용하여 대소문자를 구분하지 않도록 했는지 확인합니다.
5. 데이터베이스 연결: 데이터베이스 연결에 문제가 없는지 확인합니다. -->