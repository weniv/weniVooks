---
chapter: Form과 인증
title: django의 Form 시스템
date: 2024-08-06
---
django에서 폼(form)은 사용자가 제공하는 데이터를 안전하게 입력받고 자동으로 검사하는 도구입니다. 이 폼은 텍스트, 숫자, 이메일 등 다양한 유형의 데이터를 처리할 수 있는 여러 필드 타입을 제공합니다. 결과적으로 장고 폼은 복잡한 데이터 처리 로직을 단순화하여 웹 개발을 더욱 쉽고 효율적으로 만듭니다. 직접 장고 폼을 만들어보면서 실습해 봅시다.

# 1. 프로젝트 설정 및 기본 구조 만들기
## 1.1 프로젝트 생성 및 가상환경 설정
아래 코드를 복사해서, 작업할 폴더의 터미널에 `shift + insert`합니다. 
```bash
mkdir mysite
cd mysite
python -m venv venv
.\venv\Scripts\activate
pip install django
pip install pillow
pip freeze > requirements.txt
django-admin startproject tutorialdjango .
python manage.py migrate
python manage.py startapp blog
```
`mysite` 폴더를 생성하고, 가상환경 설치, `django`,`pillow` 라이브러리 설치, blog앱 생성까지 완료되었습니다.
`pip freeze > requirements.txt`는 `requirements`파일을 만들어 줍니다.
`requirements`파일은 가상환경에 설치한 라이브러리와 그 버전을 모두 가지고 있습니다.
나중에 이 `requirements`파일로 다른 가상환경에 설치 할 수도 있습니다.

:::div{.callout}
아래는 방금 생성된 `requirements`파일입니다.
만약 새로운 가상환경에서 프로젝트를 시작할 때 설정해야 할 라이브러리가 너무 많으면 관리하기가 어려워집니다. 하지만 requirements 파일을 사용하면 필요한 모든 라이브러리를 한 번에 쉽게 설치할 수 있어서 매우 편리합니다. 또 팀 프로젝터에서도 매우 유용합니다. 모든 팀원이 이 파일을 통해 동일한 개발 환경을 쉽게 만들 수 있습니다.
```
asgiref==3.8.1
Django==5.1
pillow==10.4.0
sqlparse==0.5.1
typing_extensions==4.12.2
tzdata==2024.1
```
`pip install -r requirements.txt` 명령어로 설치 할 수 있습니다.
:::

## 1.2 기본 설정
`tutorialdjango/settings.py` 파일을 열어서, `ALLOWED_HOSTS`, `INSTALLED_APPS`를 수정하고, static파일과 media파일을 사용할 수 있게 합니다.

```python
#tutorialdjango > settings.py
ALLOWED_HOSTS = ["*"]

INSTALLED_APPS = [
    ...
    "blog",
]

STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
```
아래 명령어를 이용해서 static, media 폴더 생성합니다.
```bash
mkdir static
mkdir media
```
## 1.3 URL 설정
- 앱이름: blog 

| URL | views 함수이름 | html 파일이름 | 비고 |
|-----|---------------|---------------|------|
| blog/ | blog_list | blog_list.html | 블로그 글 목록 | 
| 'blog/<int:pk>/' | blog_detail | blog_detail.html | 블로그 상세 글 읽기 |
| 'blog/create/' | blog_create | blog_create.html | 블로그 글 작성 |

1. `tutorialdjango/urls.py` 파일을 다음과 같이 수정합니다.
```python
#tutorialdjango > urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("admin/", admin.site.urls),
    path("blog/", include("blog.urls")),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

```
2. blog 앱에 blog/urls.py 파일을 생성하고 다음 내용을 추가합니다.
```python
# blog > urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/", views.blog_create, name="blog_create"),
]
```
# 2. 기본 뷰 및 템플릿 구현
## 2.1 View
```python
from django.shortcuts import render
from django.db.models import Q
from .models import Post
from django.shortcuts import redirect
# from .forms import PostForm

def blog_list(request):
    if request.GET.get("q"):
        db = Post.objects.filter(
            Q(title__contains=request.GET.get("q"))
            | Q(contents__contains=request.GET.get("q"))
        ).distinct()
    else:
        db = Post.objects.all()
    context = {"object_list": db}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    context = {"object": post}
    return render(request, "blog/blog_detail.html", context)

def blog_create(request):
    if request.method == "POST":
        title = request.POST.get("title")
        contents = request.POST.get("contents")
        q = Post.objects.create(title=title, contents=contents)
        q.save()
        return redirect("blog_list")
    return render(request, "blog/blog_create.html")
```
## 2.2 Template
blog앱 안에 templates > blog 폴더를 생성해서 아래와 같은 파일을 만들어 줍니다. 빈 파일로 두어도 좋습니다.
```
blog > templates > blog > blog_list.html
blog > templates > blog > blog_detail.html
blog > templates > blog > blog_create.html
```
:::div{.callout}
**명령어로 파일 생성하는 방법**     
터미널을 키고, 아래 명령어로 파일 생성이 가능합니다.
1. **window**인 경우
- cmd
```
echo.>blog_list.html
echo.>blog_detail.html
echo.>blog_create.html
```
- powershell
```shell
New-Item -Path . -Name "blog_list.html" -ItemType "file" -Value ""
New-Item -Path . -Name "blog_detail.html" -ItemType "file" -Value ""
New-Item -Path . -Name "blog_create.html" -ItemType "file" -Value ""
```
2. **맥북이나 리눅스 계열 노트북, git bash**인 경우
```bash
touch blog_list.html blog_detail.html blog_create.html
```
:::
- blog_list.html
```html
<!-- blog/blog_list.html -->
<h1>게시판</h1>
<form action="" method="get">
    <input type="search" name="q">
    <button type="submit">검색</button>
</form>
<ul>
    {% for post in object_list %}
    <li>
        <a href="{% url 'blog_detail' post.id %}">{{ post.title }}</a>
        <p>{{ post.contents }}</p>
    </li>
    {% endfor %}
</ul>
```
- blog_detail.html
```html
<!-- blog/blog_detail.html -->
<h1>게시판</h1>
<p>{{ object.title }}</p>
<p>{{ object.contents }}</p>
<p>{{ object.created_at }}</p>
<p>{{ object.updated_at }}</p>
<p>{{ object.id }}</p>
{% if object.main_image %}
<img src="{{ object.main_image.url }}" alt="">
{% endif %}
<a href="{% url 'blog_list' %}">뒤로가기</a>
```
# 3. 모델 및 관리자 페이지 설정
## 3.1 모델 정의
```python
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    contents = models.TextField()
    main_image = models.ImageField(upload_to="blog/%Y/%m/%d/", blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title
```
## 3.2 관리자 페이지 설정
1. admin.py 수정
```python
# blog > admin.py
from django.contrib import admin
from .models import Post

admin.site.register(Post)
```
2. 관리자 계정 생성
```bash
python manage.py createsuperuser
```
## 3.3 데이터베이스 마이그레이션
```bash
python manage.py makemigrations
python manage.py migrate
```
## 3.4 실행 및 테스트ㄷㅇ
```
python manage.py runserver
```
서버를 실행하고, 관리자 페이지에서 새 게시물 3개를 생성해주세요.

# 4. Form
## 4.1 blog_create.html 추가
```html
<form action="" method="post">
    {% csrf_token %}
    title: <input type="text" name="title"><br>
    contents: <input type="text" name="contents"><br>
    <button type="submit">저장</button>
</form>
```
`폼(Form)`은 웹 페이지에서 사용자로부터 입력을 받기 위한 HTML 요소입니다. 이는 마치 식당에서 사용하는 주문서와 같습니다.        
폼의 주요 속성을 살펴보면, 먼저 `action` 속성은 폼 데이터를 **어느 URL로 전송**할지 지정합니다. 이 속성이 비어있다면(action=""), 현재 페이지의 URL로 데이터를 전송합니다. 주문서로 비유하면, 주문서 위에 "주방으로 보내주세요"라고 적혀있는 것과 같습니다.      
`method` 속성은 **데이터 전송 방식**을 나타냅니다. 주로 **GET**과 **POST** 두 가지 방식이 사용됩니다.       
`GET 방식`은 **URL에 데이터를 포함**하여 전송하며 주로 검색이나 데이터 조회에 사용됩니다. `POST 방식`은 **요청 본문에 데이터를 포함**하여 전송하며, 주로 데이터 생성이나 수정에 사용됩니다. 예를 들어, GET은 주문을 큰 소리로 외치는 것과 같고, POST는 종업원에게 조용히 주문서를 건네는 것과 같습니다.     
보안을 위해 `csrf_token`이 사용됩니다. 이는 **Cross-Site Request Forgery 공격**을 방지하기 위한 보안 토큰으로, {% csrf_token %} 템플릿 태그를 통해 폼에 추가됩니다. 이는 마치 레스토랑에서 주문할 때 받는 번호표와 같습니다. 번호표로 진짜 손님의 주문임을 확인하듯, 이 토큰으로 올바른 요청인지 확인합니다.

## 4.2 forms.py 사용
지금은 view에서 모든 입력 데이터를 처리하고 있어, 코드가 반복되고, 복잡합니다. forms.py를 사용하면 데이터 검증과 처리를 체계적으로 관리할 수 있어, view의 코드 작성이 편해집니다. blog앱에서 forms.py 파일을 생성해줍니다. 
```python
from django import forms

class PostForm(forms.Form):
    title = forms.CharField()
    contents = forms.CharField()
```
## 4.3 views.py 수정
form을 새로 만들었으니, views.py를 수정해줍니다.
```python
from django.shortcuts import render
from django.db.models import Q
from .models import Post
from django.shortcuts import redirect
from .forms import PostForm
 
def blog_list(request):
    if request.GET.get("q"):
        db = Post.objects.filter(
            Q(title__contains=request.GET.get("q"))
            | Q(contents__contains=request.GET.get("q"))
        ).distinct()
    else:
        db = Post.objects.all()
    context = {"object_list": db}
    return render(request, "blog/blog_list.html", context)
 
def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    context = {"object": post}
    return render(request, "blog/blog_detail.html", context)
  
def blog_create(request):
    form = PostForm()
    context = {"form": form}
    return render(request, "blog/blog_create.html", context)
```
PostForm을 새로 임포트하고, blog_create를 수정합니다.
```python
# views.py
from .forms import PostForm
```
```python
# views.py
def blog_create(request):
    form = PostForm()
    context = {"form": form}
    return render(request, "blog/blog_create.html", context)
```
## 4.4 blog_create.html 수정
```html
<form action="{% url 'blog_create' %}" method="post">
    {# 해킹 공격 방어를 위한 토큰입니다. #}
    {% csrf_token %}
    {{ form }} 
    <button type="submit">저장</button>
</form>
```
수정 전 HTML에서는 title과 contents를 직접 받아왔지만, Django의 폼 기능을 사용하면 더 간편하고 다양한 방식으로 폼을 렌더링할 수 있습니다. 아래는 기본 폼 구조와 다양한 렌더링 방식의 예시입니다.
1. `{{ form }}` : 기본 렌더링
2. `{{ form.as_p }}` : 각 필드를 p 태그로 감싸기
3. `{{ form.as_div }}` : 각 필드를 div 태그로 감싸기
4. `<ul>{{ form.as_ul }}</ul>` : 각 필드를 ul 태그로 감싸기, 자주 사용됩니다.
5. `<ol>{{ form.as_ol }}</ol>` : 각 필드를 ol 태그로 감싸기, 잘 사용되지 않습니다.
6. `<table>{{ form.as_table }}</table>` : 각 필드를 테이블 행으로 표시
7. `{{ form.title }}, {{ form.contents }}` : 필드 개별 렌더링

예를 들어 아래 코드처럼 테이블 행으로 감싼다면, 
```html
<form action="{% url 'blog_create' %}" method="post">
    {# 해킹 공격 방어를 위한 토큰입니다. #}
    {% csrf_token %}
    <table>
    {{ form.as_table }} 
    </table>
    <button type="submit">저장</button>
</form>
```
아래 이미지처럼 table 형식으로 렌더링 된것을 볼 수 있습니다.
::img{width="" alt="" src="/images/basecamp-django/chapter04/01-1.png"}

## 4.5 form, view 수정
```python
# forms.py에서 우리가 작성한 models와 forms를 연결하는 작업
from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    title = forms.CharField()
    contents = forms.CharField()

    class Meta:
        model = Post
        fields = ["title", "contents"]
```
```python
from django.shortcuts import render
from django.db.models import Q
from .models import Post
from django.shortcuts import redirect
from .forms import PostForm
 
def blog_list(request):
    if request.GET.get("q"):
        db = Post.objects.filter(
            Q(title__contains=request.GET.get("q"))
            | Q(contents__contains=request.GET.get("q"))
        ).distinct()
    else:
        db = Post.objects.all()
    context = {"object_list": db}
    return render(request, "blog/blog_list.html", context)
 
def blog_detail(request, pk):
    post = Post.objects.get(pk=pk)
    context = {"object": post}
    return render(request, "blog/blog_detail.html", context)
  
def blog_create(request):
    if request.method == "GET":
        form = PostForm()
        context = {"form": form}
        return render(request, "blog/blog_create.html", context)
    elif request.method == "POST":
        form = PostForm(request.POST)
        if form.is_valid():
            post = form.save()
            # detail로 가야한다!
            # return redirect('blog_detail', pk=post.pk)
            return redirect("blog_list")
        else:
            context = {"form": form}
            return render(request, "blog/blog_create.html", context)
```
`return redirect("blog_list")` create 에서 입력을 하고 난 후 blog_list 페이지로 이동
`return redirect('blog_detail', pk=post.pk)` 코드를 이렇게 바꾸면 blog_detail 페이지로 이동
# 5. 에러메세지

```python
# forms.py 
from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    title = forms.CharField(max_length=10)
    contents = forms.CharField(widget=forms.Textarea)

    class Meta:
        model = Post
        fields = ["title", "contents"]
```
글자제한을 주고 실행 -> 개발자 도구에서 수정
::img{width="" alt="" src="/images/basecamp-django/chapter04/01-2.png"}
::img{width="" alt="" src="/images/basecamp-django/chapter04/01-3.png"}

```python
# => blog > views.py error 추가

def blog_create(request):
    if request.method == "GET":
        form = PostForm()
        context = {"form": form}
        return render(request, "blog/blog_create.html", context)
    elif request.method == "POST":
        form = PostForm(request.POST)
        if form.is_valid():
            post = form.save()
            # detail로 가야한다!
            return redirect("blog_detail", pk=post.pk)
            # return redirect("blog_list")
        else:
            context = {
                "form": form,
                "error": "입력이 잘못되었습니다. 알맞은 형식으로 다시 입력해주세요!",
            }
            return render(request, "blog/blog_create.html", context)
```
```html
# blog > templates > blog > create.html

<p style="color:red;">{{ error }}</p>
<form action="{% url 'blog_create'%}" method="post">
    {% csrf_token %}
    {{ form }}
    <button type="submit">저장</button>
</form>
```
::img{width="" alt="" src="/images/basecamp-django/chapter04/01-4.png"}
이렇게 에러문구가 뜨는 것을 확인할 수 있습니다.

# 6. 삭제하기 버튼 추가

```python
# blog > blog_detail.html

<h1>게시판</h1>

<p>{{ object.title }}</p>
<p>{{ object.contents }}</p>
<p>{{ object.created_at }}</p>
<p>{{ object.updated_at }}</p>
<p>{{ object.id }}</p>
{% if object.main_image %}
<img src="{{ object.main_image.url }}" alt="">
{% endif %}
<a href="{% url 'blog_list' %}">뒤로가기</a>

<form action="{% url 'blog_delete' object.id %}" method="post">
    {% csrf_token %}
    <button type="submit">삭제하기</button>
</form>
```

```python
# blog > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"),
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
    path("create/", views.blog_create, name="blog_create"),
    path("<int:pk>/delete/", views.blog_delete, name="blog_delete"),
]
```
- view.py 추가
```python
# blog > views.py
def blog_delete(request, pk):
    post = Post.objects.get(pk=pk)
    post.delete()
    return redirect("blog_list")
```
::img{width="" alt="" src="/images/basecamp-django/chapter04/01-5.png"}

# 7. 이미지 필드 추가
<!-- fields = '__all__'  : 이 코드를 쓰면 모든 필드를 한번에 볼 수 있음. 그러나 사용자에게 보이지않아야할 필드가 있을 수 있으니 권고하지 않음.
하나씩 명시하기. -->