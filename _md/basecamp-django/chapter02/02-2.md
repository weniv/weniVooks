---
chapter: URL처리와 템플릿 태그
title: URL처리와 템플릿 태그 실습 2
date: 2024-07-11
---
# 1. Django 앱 생성

1. `main`, `blog` 앱을 생성합니다.
   ```
   python manage.py startapp main
   python manage.py startapp blog
   ```

2. `tutorialdjango > settings.py` 파일을 열어, ALLOWED_HOSTS 리스트에 "*"을 입력하고,
INSTALLED_APPS 리스트에는 `'main'`,'`blog'`을 추가합니다. 
    
   ```python
   # tutorialdjango > settings.py
   ALLOWED_HOSTS = ["*"]
   INSTALLED_APPS = [
       ...
       'main',
       'blog',
   ]
   ```

# 2. URL 설정

## 2.1 메인 urls.py 설정
```
'about/'
'contact/'
'blog/'
'blog/<int:pk>/'

# URL 구조 작성
앱이름: main
URL             views 함수이름	 html 파일이름	    비고
''              index           index.html
'about/'        about
'contact/'      contact

앱이름: blog
URL             views 함수이름  html 파일이름     비고
'blog/'         blog_list      blog_list.html	
'blog/<int:pk>' blog_detail    blog_detail.html  게시물이 없을 경우에는 404로 연결
```
```python
# tutorialdjango > urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("main.urls")),
    path("blog/", include("blog.urls")),
]
```
`include`는 다른 URLconf (URL configuration) 모듈을 참조할 때 사용합니다.

:::div{.callout}
각 앱의 폴더에는 urls.py가 없습니다! 각 폴더마다 urls.py을 만들면 됩니다.
:::

## 2.2 main 앱 urls.py 설정
```python
# main > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path("", views.index, name="index"),
    path("about/", views.about, name="about"),
    path("contact/", views.contact, name="contact"),
]
```
`path("contact/", views.contact, name="contact")`       
path의 세번째 파라미터인 name은 URL의 고유 별칭입니다. 
템플릿 태그를 사용할 때, name을 이용해 이 URL에 접근할 수 있습니다. name을 어떻게 사용하는지에 대해서는 아래에서 설명하겠습니다.     

## 2.3 blog 앱 urls.py 설정
```python
# blog > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path("", views.blog_list, name="blog_list"), 
    path("<int:pk>/", views.blog_detail, name="blog_detail"),
]
```
blog > urls.py 에서의 기본 url은 'blog/'입니다. 위의 tutorialdjango > urls.py에 작성했던 `path("blog/", include("blog.urls"))` 에 연결된 것을 알 수 있습니다.

# 3. view.py 설정

## 3.1 main 앱 views.py

```python
# main > views.py

from django.shortcuts import render

def index(request):
    return render(request, "main/index.html")

def about(request):
    return render(request, "main/about.html")

def contact(request):
    return render(request, "main/contact.html")
```
템플릿 폴더를 앱 내부가 아닌 앱과 같은 선상에 두었기 때문에
경로를 작성할 때 html파일의 폴더 작성을 생략하면 오류가 발생할 수 있습니다.
만약 여러 앱에 index.html이라는 파일이 있다고 했을 때, 장고는 알파벳 순으로 폴더를 읽어나가기 때문에 다른 index.html이 연결 될 수 있습니다.
그래서 경로의 폴더명을 함께 작성하는 것을 권고드립니다.



## 3.2 blog 앱 views.py

```python
# blog > views.py

from django.shortcuts import render

blog_database = [
    {
        "id": 1,
        "title": "제목1",
        "content": "내용1",
        "created_at": "2021-02-22",
        "updated_at": "2021-02-22",
        "author": "홍길동",
        "category": "일상",
        "tag": ["태그1", "태그2"],
        "view_count": 0,
        "thumbnail": "https://picsum.photos/200/300",
        "like_count": 3,
        "like_user": [10, 20, 21],
    },
    {
        "id": 2,
        "title": "제목2",
        "content": "내용2",
        "created_at": "2021-02-23",
        "updated_at": "2021-02-23",
        "author": "김철수",
        "category": "일기",
        "tag": ["태그1", "태그3"],
        "view_count": 0,
        "thumbnail": "https://picsum.photos/200/300",
        "like_count": 10,
        "like_user": [10, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    },
    {
        "id": 3,
        "title": "제목3",
        "content": "내용3",
        "created_at": "2021-02-24",
        "updated_at": "2021-02-24",
        "author": "이영희",
        "category": "맛집",
        "tag": ["태그1", "태그3"],
        "view_count": 0,
        "thumbnail": "https://picsum.photos/200/300",
        "like_count": 20,
        "like_user": [10, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    },
    {
        "id": 4,
        "title": "제목4",
        "content": "내용4",
        "created_at": "2021-02-25",
        "updated_at": "2021-02-25",
        "author": "박민수",
        "category": "여행",
        "tag": ["태그1", "태그3"],
        "view_count": 0,
        "thumbnail": "https://picsum.photos/200/300",
        "like_count": 30,
        "like_user": [10, 20, 21, 22, 23, 24, 25, 26, 27, 28],
    },
]

def blog_list(request):
    # blogs = Blog.objects.all() # 실제로는 이렇게 데이터베이스에서 가져옴
    context = {"object_list": blog_database}
    return render(request, "blog/blog_list.html", context)

def blog_detail(request, pk):
    # blog = Blog.objects.get(pk=pk) # 실제로는 이렇게 데이터베이스에서 가져옴
    context = {"object": blog_database[pk - 1]}
    return render(request, "blog/blog_detail.html", context)
```

# 4. 템플릿 설정

앱 폴더 안에 templates 폴더를 생성하는 것이 아닌, 앱폴더와 같은 위치에 templates 폴더를 만들어야합니다.

```
mysite/
├── main/
├── blog/
└── templates/
        └── blog/
            ├── blog_list.html
            └── blog_detail.html
```
이렇게 html 파일을 만들어 주세요.
- templates > blog > blog_list.html
- templates > blog > blog_detail.html

## 4.1 템플릿 설정 변경
기본 템플릿 폴더를 변경합니다. 앞으로는 mysite > templates라는 폴더에서 통합 관리합니다. 
폴더의 위치가 달라졌으니, 설정이 달라져야합니다. `settings.py`의 `TEMPLATES`안에 있는 `DIRS`의 경로를 `[BASE_DIR / "templates"]` 로 수정해 줍니다.

```python
# tutorialdjango > settings.py

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"], #이 부분 입니다.
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]
```
템플릿 폴더를 앱 내부에 두는 것과 바깥쪽에 두는 것은 서로 장단점이 다릅니다.
앱 내부에 둔다면, 모듈화하기에 편할 수 있으나 유지보수를 하기에는 어렵습니다.
바깥쪽에 둔다면 유지보수에 편하지만, 모듈화 하기에 어렵습니다.
## 4.2 템플릿 내용

- blog_list.html

```html
<!-- templates/blog/blog_list.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <h1>bloglist</h1>
    <ul>
        {% for blog in object_list %}
        <li>
            {{ forloop.counter }}
            {# 주석입니다. 'url 'blog_detail' blog.id' 와 같은 형태는 urls.py에서 blog_detail이라는 name을 가진 url을 찾습니다. 그걸로만 연결을 해주는데 뒤에 값이 들어가야 할 경우, 파라미터가 있는 경우! 뒤에 띄어쓰기로 아규먼트를 넣어줄 수 있습니다. 결국에는 blog.id가 blog_detail에 pk로 들어가는 것입니다. #}
            <a href="{% url 'blog_detail' blog.id %}">{{ blog.title }}</a>
        </li>
        {% endfor %}
    </ul>
</body>
</html>
```
blog_list.html에 아래 코드가 있습니다. 이때 'blog_detail'가 urls.py에서 작성했던 name입니다.

```html
<a href="{% url 'blog_detail' blog.id %}">{{ blog.title }}</a>
```

위와 같이 이 name를 가진 URL 패턴을 찾아 현재 블로그 객체의 id 값(글 번호)을 넣어 URL을 완성합니다. 예를 들어 blog.id가 5라면 'blog/5/'와 같은 URL이 만들어집니다. 이 URL을 <a href="..."> 링크에 넣어 사용자가 클릭하면 해당 id의 블로그 글 상세 페이지로 이동하게 됩니다. 이때 이 링크의 텍스트가 `blog.title` 입니다. 

- blog_detail.html
```html
<!-- templates > blog > blog_detail.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blogdetail</title>
</head>
<body>
    <h1>blogdetail</h1>
    <h2>{{ object.title }}</h2>
    <p>{{ object.content }}</p>
    <p>{{ object.created_at }}</p>
    <p>{{ object.updated_at }}</p>
    <a href="{% url 'blog_list' %}">목록</a>
</body>
</html>
```

# 5. 템플릿 상속
웹사이트를 만들다 보면 모든 페이지에 반복되는 요소들이 있습니다. 웹사이트들을 보면 있는 메뉴들이나, 페이지 끝에 있는 설명란 같은 것들은 반복되는 요소들 입니다. 이런 요소들을 페이지마다 일일이 작성하면 어떻게 될까요? 시간도 많이 걸리고, 나중에 이 부분을 수정해야 할 때는 모든 페이지를 하나하나 고쳐야 해서 정말 큰 일이 됩니다. 예를 들어, 메뉴에 새 항목을 하나 추가하려면 수백 개의 페이지를 모두 수정해야 할 수도 있습니다. 이런 문제를 해결하기 위해 템플릿 상속이라는 방법을 사용합니다. 템플릿 상속을 이용하면 공통된 부분은 한 번만 작성하고, 각 페이지에서는 변경되는 부분만 작성하면 됩니다. 이렇게 하면 작업 시간도 줄이고, 수정할 때도 한 곳만 바꾸면 모든 페이지에 적용되어 관리가 훨씬 쉬워집니다.

<!-- * 부모코드(상속해주는 코드)

{% block 자식이름 %}
{% endblock %}

* 자식코드(상속받는 코드)
{% extends '부모html파일명' %}
{% block 자식이름 %}
... 실제 사용할 자식 코드 ...
{% endblock %} -->

::img{alt="" src="/images/basecamp-django/chapter02/02-1.png"}
1. templates 폴더에 base > base.html 파일을 만들어 주세요.

```html
<!-- templates > base > base.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weniv blog</title>
</head>
<body>
    <header>
        <h1>weniv blog</h1>
        <nav>
            <ul>
                <li>메뉴1</li>
                <li>메뉴2</li>
                <li>메뉴3</li>
            </ul>
        </nav>
    </header>

    <main>
        {% block contents %} 
        <p>test 이어서 써집니다1</p>
        <p>test 이어서 써집니다2</p>
        {% endblock %}
    </main>

    {% block binky %}
    {% endblock %}

    <footer>
        <p>저작권은 weniv에게 있습니다.</p>
    </footer>

    {% block mura %}
    {% endblock %}
</body>
</html>
```

2. templates 폴더에 blog > blog_list.html, blog_detail.html 파일을 수정해주세요.
- blog_list.html
```html
<!-- templates > blog > blog_list.html -->
{% extends 'base/base.html '%}

{% block contents %}
<h1>bloglist</h1>
<ul>
    {% for blog in blog_list %}
    <li>
        {{ forloop.counter }}
        <a href="{% url 'blog_detail' blog.id %}">{{ blog.title }}</a>
    </li>
    {% endfor %}
</ul>
{% endblock %}

{% block binky %}
<h2>binky test</h2>
{% endblock %}

{% block mura %}
<script>
    console.log('mura test');
</script>
{% endblock %}
```
- blog_detail.html
```html
<!-- templates > blog > blog_detail.html -->
{% extends 'base/base.html '%}

{% block contents %}
<h1>blogdetail</h1>
<h2>{{ blog.title }}</h2>
<p>{{ blog.content }}</p>
<p>{{ blog.created_at }}</p>
<p>{{ blog.updated_at }}</p>
<a href="{% url 'blog_list' %}">목록</a>
{% endblock %}
```

자식코드에서 블록의 위치가 어디에 있는지에 상관 없이
최종적으로 보여지는 템플릿은 부모 코드의 템플릿으로 보여집니다.

# 6. static 파일

1. 프로젝트 최상위에 'static' 폴더를 생성합니다.
2. 'static' 폴더 안에 'css'와 'js' 폴더를 만듭니다.
3. 각 폴더에 'custom.css'와 'custom.js' 파일을 생성합니다.

최종적으로 아래와 같은 구조가 됩니다.

```
mysite/
├── main/
├── blog/
├── templates/
└── static/
    ├── css/
    │   └── custom.css
    └── js/
        └── custom.js
```

## 6.1. static 설정
`settings.py`의 설정을 변경해 줘야합니다.
`STATICFILES_DIRS = [BASE_DIR / "static"]` 코드를 추가합니다.

- settings.py 
```python
# tutorialdjango > settings.py 
STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / "static"] #이 부분 입니다.
```
## 6.2 css, js 파일 생성

```css
h1, h2{
    color: green
}
```

```js
console.log('Hello, World!');
```

## 6.3 static 파일 적용

1. templates > base.html 파일 맨 위에 {% load static %} 를 추가합니다.
2. {% static '파일경로' %} 형식으로 파일 경로를 수정해 줍니다.

- base.html
```html
<!-- templates > base.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weniv blog</title>
    <link rel="stylesheet" href="css/custom.css"> 
    <!-- css 경로 수정 -->
    <link rel="stylesheet" href="{% static 'css/custom.css' %}">
</head>
<body>
    <header>
        <h1>weniv blog</h1>
        <nav>
            <ul>
                <li>메뉴1</li>
                <li>메뉴2</li>
                <li>메뉴3</li>
            </ul>
        </nav>
    </header>

    <main>
        {% block contents %}
        <p>test 이어서 써집니다1</p>
        <p>test 이어서 써집니다2</p>
        {% endblock %}
    </main>

    {% block binky %}
    {% endblock %}

    <footer>
        <p>저작권은 weniv에게 있습니다.</p>
    </footer>

    {% block mura %}
    {% endblock %}
    <script src="js/custom.js"></script>
    <!-- js 경로 수정-->
    <script src="{% static 'js/custom.js' %}"></script>
</body>
</html>
```

:::div{.callout}
상대 경로로 되어 있는 기존의 모든 파일 경로를 {% static %} 형식으로 바꿔줘야 합니다. 
- 상대경로 : 현재 위치를 기준으로 파일이나 폴더의 위치를 나타내는 경로 `./images/cat.jpg`
- 절대경로 : 최상위 폴더부터 시작하는 전체 경로 `https://example.com/images/cat.jpg`

주로 수정해야 할 부분으로 아래 4가지가 있습니다.
1. `<script>` 태그의 src 속성
2. `<img>` 태그의 src 속성
3. CSS의 background-image: url() 부분
4. `<link>` 태그의 href 속성

만약 수정해야 할 파일이 많다면, 자동화 스크립트(gen.py)를 만드는 것도 좋은 방법입니다. 하드코딩(예: /static/css/styles.css)도 작동하지만, 유지보수를 위해 **{% static %}** 사용을 권장합니다.
:::

# 7. 실행 및 테스트

1. 서버를 실행합니다.
   ```
   python manage.py runserver
   ```
2. 브라우저에서 URL을 테스트해보세요.