---
chapter: URL 처리와 템플릿
title: View와 템플릿
date: 2024-07-11
---
# 1. View 소개

Django에서 View는 음식점의 주방장과 같습니다. 손님(사용자)이 메뉴(웹 페이지)를 주문하면, 주방장(View)은 그 주문을 받아 이해합니다.
그 다음 필요한 재료(데이터)를 냉장고(데이터베이스)에서 꺼내와 요리(데이터 처리)를 합니다.
완성된 요리(처리된 정보)를 예쁘게 플레이팅(HTML 페이지 생성)하여 웨이터(서버)를 통해 손님에게 제공합니다.
이처럼 View는 사용자의 요청부터 응답까지의 전체 과정을 관리하는 웹사이트의 '주방장' 역할을 수행합니다.

## 1.1 함수형 View와 클래스형 View

Django에서는 두 가지 유형의 View를 사용할 수 있습니다. 함수형 View와 클래스형 View입니다.

### 1.1.1 함수형 View
함수형 View는 가장 기본적이고 직관적인 형태의 View입니다. 이는 HTTP 요청 객체를 인자로 받아 HTTP 응답 객체를 반환하는 Python 함수입니다. 함수형 View는 간단한 로직부터 복잡한 처리까지 다양한 상황에 사용할 수 있습니다.

```python
from django.http import HttpResponse
from django.shortcuts import render

# 간단한 HttpResponse 사용
def hello_world(request):
    return HttpResponse("Hello, World!")

# render 함수를 사용한 템플릿 렌더링
def greet_user(request):
    context = {'username': 'John Doe'}
    return render(request, 'greetings.html', context)
```
함수형 View는 코드가 간결하고 이해하기 쉬워 초보자들이 Django를 배우기 시작할 때 흔히 접하는 형태입니다. 또한, render 함수를 사용하여 템플릿과 쉽게 연동할 수 있어 동적인 웹 페이지를 생성하는 데에도 적합합니다. 간단한 페이지부터 데이터를 처리하고 표시하는 복잡한 페이지까지, 함수형 View는 다양한 상황에서 유연하게 사용될 수 있습니다.

### 1.1.2 클래스형 View

클래스형 View는 View를 만드는 또 다른 방법입니다. 함수 대신 클래스를 사용하여 View를 정의합니다. 클래스는 레고 블록처럼 미리 만들어진 기능들을 조립하여 사용할 수 있게 해줍니다.

클래스형 View는 부모 클래스의 기능을 물려받아 코드를 재사용할 수 있고, Django가 제공하는 View 클래스들을 활용해 원하는 기능을 쉽게 추가할 수 있습니다. 이런 이유로 복잡한 웹 페이지를 만들 때 특히 유용합니다. 이렇게 클래스형 View는 코드를 체계적으로 관리하면서도 유연하게 웹 페이지의 기능을 구현할 수 있게 해줍니다. 아래는 클래스형 view의 간단한 예시입니다.

```python
from django.views import View
from django.http import HttpResponse

class HelloWorldView(View):
    def get(self, request):
        return HttpResponse("안녕하세요!")
    
    def post(self, request):
        return HttpResponse("데이터를 받았습니다!")
```
위 예시에서 HelloWorldView 클래스는 GET 요청이 오면 "안녕하세요!"라고 응답하고, POST 요청이 오면 "데이터를 받았습니다!"라고 응답합니다.
처음에는 함수형 View보다 복잡해 보일 수 있지만, 큰 프로젝트를 할 때 코드를 더 체계적으로 관리할 수 있게 해줍니다.

## 1.2 render 함수
Django의 View에서 핵심적인 역할을 하는 것이 바로 `render()` 함수입니다. 이 함수는 마치 요리사가 여러 재료를 조합하여 맛있는 요리를 만드는 것과 유사합니다. render() 함수는 여러 요소를 결합하여 사용자에게 보여줄 최종 웹 페이지를 생성합니다. render() 함수의 사용 예시입니다
```python
from django.shortcuts import render

def blog_list(request):
    context = {"object_list": blog_database}
    return render(request, "blog/blog_list.html", context)
```

::img{width = 700 alt="" src="/images/basecamp-django/chapter02/04-1.png"}

render() 함수를 사용할 때는 최소한 두 가지 인자가 필요합니다. request와 template_name입니다. request는 사용자의 요청 정보를 담고 있는 객체이고, template_name은 사용할 HTML 템플릿 파일의 경로입니다. 필수인 두 인자를 제외하고, context, status 같은 선택 인자들이 있습니다. 위 코드에서 사용한 context는 템플릿에 전달할 딕셔너리 형식의 데이터 입니다. 자세한 사항은 아래 공식 문서를 참고해 주세요.     
아래는 render() 함수의 작동 과정입니다. 

::img{alt="" src="/images/basecamp-django/chapter02/04-2.png"}

우선 request에서는 사용자로부터 받은 요청 정보를 분석합니다. 두번째로 지정된 HTML 템플릿 파일을 불러옵니다. 그 다음으로 선택 인자인 context를 템플릿에 넣고, 완성된 웹 페이지가 들어있는 response(응답)을 만듭니다. response는 자동으로 사용자의 브라우저로 전송되어, 사용자는 완성된 웹 페이지를 볼 수 있게 됩니다.

::a[Django 공식 문서- render]{class='btn-link' href="https://docs.djangoproject.com/ko/5.0/topics/http/shortcuts/#django.shortcuts.render" target="\_blank"}

# 2. URL과 View의 연결

Django에서 URL과 View를 연결하는 것은 urls.py 파일에서 이루어집니다. 이 파일에서 URL 패턴과 해당 패턴을 처리할 View를 매핑합니다.

```python
from django.urls import path
from . import views

urlpatterns = [
    path('blog/', blog_list, name='blog_list'),
]
```
이렇게 설정하면 '/blog/' URL로 접근했을 때 blog_list 함수가 실행됩니다.

# 3. Template

Template은 Django에서 웹 페이지를 만들기 위한 '틀'이나 '양식'이라고 생각하면 됩니다. 마치 편지지와 같습니다. 편지지에는 받는 사람, 본문, 보내는 사람 등을 쓸 수 있는 공간이 미리 마련되어 있죠. Django의 Template도 이와 비슷하게 웹 페이지의 기본 구조와 디자인이 미리 준비되어 있고, 실제 내용(사용자 이름, 게시글 등)이 들어갈 자리만 비워둡니다. Django는 이 비워둔 자리에 필요한 정보를 채워 넣어 완성된 웹 페이지를 만듭니다. 이 방식을 사용하면 같은 모양의 페이지를 쉽게 여러 개 만들 수 있고, 전체 디자인을 바꿀 때도 Template만 수정하면 되어 매우 효율적입니다.

## 3.1 Template 상속
템플릿 상속은 웹사이트의 일관된 구조를 유지하면서 각 페이지의 특정 내용을 효율적으로 관리할 수 있게 해줍니다. 기본 템플릿(부모)에서 공통 구조를 정의하고, 각 페이지(자식 템플릿)에서 이를 확장하여 사용합니다. 상속을 통해 코드 중복을 줄이고, 전체 사이트의 디자인을 쉽게 변경할 수 있으며, 각 페이지의 고유한 내용을 유연하게 추가할 수 있습니다. 아래 템플릿을 예시로 설명을 이어나가보겠습니다.

1. 부모 템플릿 (base.html) 예시

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weniv blog</title>
</head>
<body>
    <header>
        <h1>weniv blog</h1>
        <nav>
            <ul>
                <li>메뉴1</li>
                <li>메뉴2</li>
                <li>메뉴3</li>
            </ul>
        </nav>
    </header>
 
    <main>
        {% block contents %} 
        <p>test 이어서 써집니다1</p>
        <p>test 이어서 써집니다2</p>
        {% endblock %}
    </main>
 
    {% block binky %}
    {% endblock %}
 
    <footer>
        <p>저작권은 weniv에게 있습니다.</p>
    </footer>
 
    {% block mura %}
    {% endblock %}
</body>
</html>
```

2. 자식 템플릿 (blog_list.html):

```html
{% extends 'base/base.html '%}
 
{% block contents %}
<h1>bloglist</h1>
<ul>
    {% for blog in blog_list %}
    <li>
        {{ forloop.counter }}
        <a href="{% url 'blog_detail' blog.id %}">{{ blog.title }}</a>
    </li>
    {% endfor %}
</ul>
{% endblock %}
 
{% block binky %}
<h2>binky test</h2>
{% endblock %}
 
{% block mura %}
<script>
    console.log('mura test');
</script>
{% endblock %}
```

위 예시에서 `base.html`은 웹사이트의 전체적인 틀을 만들고, `blog_list.html`은 이 틀을 물려받아 특정 블록들(`contents`, `binky`, `mura`)을 채우고 있습니다.
이를 통해 공통 요소는 유지하면서 각 페이지의 고유한 내용을 쉽게 추가할 수 있습니다. 
템플릿 상속을 사용하기 위해서 **주의**해야 할 것이 몇 가지 있습니다.        
첫번째로는 `상속 선언` 입니다. 위와 같은 코드를 **자식 템플릿의 첫줄에 작성해주어야 합니다.** 자식 템플릿이 어떤 부모를 가졌는지 이야기해주는 것입니다.    
```python
{% extends 'base/base.html '%}
```    
두번째로는 `블록 정의` 입니다. 템플릿의 **부모코드와 자식코드 모두에게 같은 이름의 블록이 있어야 합니다.**
```python
{% block contents %}
<h2>Hello, world!</h2>
{% endblock %}
```
contents 블록이 부모 코드와 자식 코드, 두 코드에 있어야지만, 자식 코드의 내용이 부모 코드의 블록 부분에 들어갈 수 있습니다.
부모 코드의 블록에 이미 내용이 들어가 있는 상태에서, 자식 코드가 들어갈 경우에는 부모 템플릿의 원래 내용은 사라지고 자식 템플릿의 내용만 남게 됩니다.

## 3.2 Static 파일 관리

Static 파일은 웹사이트를 꾸미고 동작하게 만드는 고정된 파일들입니다. 예를 들어, 웹페이지의 스타일을 결정하는 CSS 파일, 동적인 기능을 추가하는 JavaScript 파일, 그리고 웹사이트에 표시되는 이미지 파일들이 있습니다.
static 파일은 도서관에서 책을 정리하는 것과 비슷합니다. 
모든 책(static 파일)을 종류별로 정리해두고, 필요할 때 쉽게 찾아 사용할 수 있게 하는 거죠.
아래는 static 파일의 예시입니다.

- static파일 예시
```html
{% load static %}
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weniv blog</title>
    <!-- css 경로 수정 -->
    <link rel="stylesheet" href="{% static 'css/custom.css' %}">
</head>
<body>
    <header>
        <h1>weniv blog</h1>
        <nav>
            <ul>
                <li>메뉴1</li>
                <li>메뉴2</li>
                <li>메뉴3</li>
            </ul>
        </nav>
    </header>
 
    <main>
        {% block contents %}
        <p>test 이어서 써집니다1</p>
        <p>test 이어서 써집니다2</p>
        {% endblock %}
    </main>
 
    {% block binky %}
    {% endblock %}
 
    <footer>
        <p>저작권은 weniv에게 있습니다.</p>
    </footer>
 
    {% block mura %}
    {% endblock %}
    <!-- js 경로 수정-->
    <script src="{% static 'js/custom.js' %}"></script>
</body>
</html>
```
Django에서 static 파일을 관리할 때에도 주의해야 할 사항들이 있습니다.       
첫번째로는 모든 템플릿 파일의 최상단에 `{% load static %} 태그`를 **추가**해야 합니다. Django에게 이 템플릿에서 static 파일을 사용할 것이라고 이야기하는 것입니다.        
두번째는 기존에 css, js, img 파일이 상대 경로로 지정되어 있다면, 이 경로를 `{% static '경로' %}` 형식으로 변경해야 합니다. 
```html
<link rel="stylesheet" href="{% static 'css/custom.css' %}">
<script src="{% static 'js/custom.js' %}"></script>
```
예를 들어, CSS 파일이나 js파일을 연결할 때 위와 같이 작성합니다.
마지막으로, 부모 템플릿에 static을 적용하면, 이를 상속받는 모든 자식 템플릿에도 자동으로 적용됩니다.