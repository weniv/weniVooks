---
chapter: 데이터 구조
title: DataFrame(데이터프레임)
date: 2024-07-23
---

# 1. DataFrame (데이터프레임) 이란?

`데이터프레임(DataFrame)`은 시리즈를 기반으로 여러 개의 행(Row)과 열(Column)로 이루어진 2차원 데이터 배열 구조입니다. 엑셀 스프레드시트와 유사한 테이블(표) 형태로 이루어져 있어 데이터를 다루기에 적합한 자료구조입니다.

DataFrame은 여러 개의 행(Row)과 열(Column)로 구성됩니다.

- 단일 열은 하나의 데이터 타입만 가질 수 있으며, 시리즈로 반환됩니다.
- 각 행에는 리스트와 같이 다양한 데이터 유형을 포함할 수 있습니다.

# 2. DataFrame 생성

`pl.DataFrame(데이터)` 를 사용하여 DataFrame을 생성할 수 있습니다. 데이터에는 딕셔너리, numpy 배열, 시리즈 데이터 형태가 들어갈 수 있습니다.

## 2.1 Dictionary로 생성하기

```python
from datetime import datetime
import polars as pl

data = {
    "integer": [1, 2, 3, 4, 5],
    "date": [
        datetime(2022, 1, 1),
        datetime(2022, 1, 2),
        datetime(2022, 1, 3),
        datetime(2022, 1, 4),
        datetime(2022, 1, 5),
    ],
    "float": [4.0, 5.0, 6.0, 7.0, 8.0],
    "string": ["a", "b", "c", "d", "e"],
}

# 데이터프레임 생성하기
df = pl.DataFrame(data)
print(df)
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

## 2.2 Series 리스트로 생성하기

```python
data = [
    pl.Series("col1", [1, 2], dtype=pl.Float32),
    pl.Series("col2", [3, 4], dtype=pl.Int64),
]
df2 = pl.DataFrame(data)
print(df2)
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1.0  ┆ 3    │
│ 2.0  ┆ 4    │
└──────┴──────┘
```

## 2.3 중첩 리스트로 생성하기

중첩리스트 형태로 데이터를 생성하고 schema 매개변수를 사용하여 열 이름 지정합니다.

```python
data = [[1, 2, 3], [4, 5, 6]]
df3 = pl.DataFrame(data, schema=["a", "b", "c"])
print(df3)
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
│ 4   ┆ 5   ┆ 6   │
└─────┴─────┴─────┘
```

중첩 리스트로 데이터 프레임을 생성할 경우 행을 먼저 채우고 열을 채우게 됩니다. 만약, 열을 기준으로 먼저 채우고 싶으시다면 `orient="col"` 속성을 주시면 됩니다.

```python
import numpy as np

data = np.array([(1, 2), (3, 4)], dtype=np.int64)
df6 = pl.DataFrame(data, schema=["a", "b"], orient="col")
print(df6)
```

- orient
  - col : 열을 기준으로 데이터를 넣습니다.
  - row(기본값) : 행을 기준으로 데이터를 넣습니다.

```
shape: (2, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
│ 2   ┆ 4   │
└─────┴─────┘
```

# 3. 데이터 타입

## 3.1 dtypes

데이터 타입은 데이터프레임을 출력할 때 헤더에서 확인할 수 있습니다. dtypes으로 데이터프레임 안에 있는 열의 데이터 타입(자료형)을 차례대로 확인할 수 있습니다.

```python
print(df.dtypes)
```

```
[Int64, Datetime(time_unit='us', time_zone=None), Float64, String]
```

## 3.2 schema

schema는 컬럼명과 데이터 타입을 같이 확인할 수 있으며, (컬럼명, 데이터 타입) 순서대로 튜플 형태로 출력됩니다.

```python
print(df.schema)
```

```
OrderedDict([('integer', Int64), ('date', Datetime(time_unit='us', time_zone=None)), ('float', Float64), ('string', String)])
```

데이터프레임 생성 시에 schema 매개변수를 사용하여 열의 타입을 지정할 수도 있습니다.

1. **{name:type}의 딕셔너리 형태**

   ```python
   data = {"col1": [0, 2], "col2": [3, 7]}
   df4 = pl.DataFrame(data, schema={"col1": pl.Float32, "col2": pl.Int64})
   print(df4)
   ```

   ```
   shape: (2, 2)
   ┌──────┬──────┐
   │ col1 ┆ col2 │
   │ ---  ┆ ---  │
   │ f32  ┆ i64  │
   ╞══════╪══════╡
   │ 0.0  ┆ 3    │
   │ 2.0  ┆ 7    │
   └──────┴──────┘
   ```

2. **(name:type) 리스트 형태**

   ```python
   df5 = pl.DataFrame(data, schema=[("col1", pl.Float32), ("col2", pl.Int64)])
   print(df5)
   ```

   ```
   shape: (2, 2)
   ┌──────┬──────┐
   │ col1 ┆ col2 │
   │ ---  ┆ ---  │
   │ f32  ┆ i64  │
   ╞══════╪══════╡
   │ 0.0  ┆ 3    │
   │ 2.0  ┆ 7    │
   └──────┴──────┘
   ```

schema를 사용하여 생성하실 때,

- 스키마에 제공된 컬럼명 수는 데이터 차원 수와 일치해야 합니다.
- 데이터 타입을 따로 지정하지 않거나 기본값인 None으로 설정한 컬럼들은 자동으로 타입을 설정합니다.
- 기본 데이터의 컬럼명과 일치하지 않는 열 이름 목록을 제공하면 제공된 컬럼명이 해당 목록을 덮어씁니다.

## 3.3 cast

딕셔너리 형태로 {컬럼명 : 데이터 타입} 주어 열을 지정된 데이터 타입으로 형변환합니다.

```python
# df.cast({"컬럼명": 데이터타입})
print(df.cast({"integer": pl.Float32, "float": pl.UInt8}))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ f32     ┆ datetime[μs]        ┆ u8    ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1.0     ┆ 2022-01-01 00:00:00 ┆ 4     ┆ a      │
│ 2.0     ┆ 2022-01-02 00:00:00 ┆ 5     ┆ b      │
│ 3.0     ┆ 2022-01-03 00:00:00 ┆ 6     ┆ c      │
│ 4.0     ┆ 2022-01-04 00:00:00 ┆ 7     ┆ d      │
│ 5.0     ┆ 2022-01-05 00:00:00 ┆ 8     ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

selectors로 모든 열을 한 번에 같은 데이터 타입으로 변환할 수도 있습니다.

```python
import polars.selectors as cs
print(df.cast({cs.numeric(): pl.UInt32, cs.temporal(): pl.String}))
```

```
shape: (5, 4)
┌─────────┬────────────────────────────┬───────┬────────┐
│ integer ┆ date                       ┆ float ┆ string │
│ ---     ┆ ---                        ┆ ---   ┆ ---    │
│ u32     ┆ str                        ┆ u32   ┆ str    │
╞═════════╪════════════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00.000000 ┆ 4     ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00.000000 ┆ 5     ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00.000000 ┆ 6     ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00.000000 ┆ 7     ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00.000000 ┆ 8     ┆ e      │
└─────────┴────────────────────────────┴───────┴────────┘
```

모든 열을 단일 데이터 타입으로 변환할 수 있습니다.

```python
print(df.cast(pl.String))
```

```
shape: (5, 4)
┌─────────┬────────────────────────────┬───────┬────────┐
│ integer ┆ date                       ┆ float ┆ string │
│ ---     ┆ ---                        ┆ ---   ┆ ---    │
│ str     ┆ str                        ┆ str   ┆ str    │
╞═════════╪════════════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00.000000 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00.000000 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00.000000 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00.000000 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00.000000 ┆ 8.0   ┆ e      │
└─────────┴────────────────────────────┴───────┴────────┘
```

데이터 타입과 일치하는 모든 열을 다른 데이터 타입으로 변환할 수도 있습니다.

```python
print(df.cast({pl.Datetime: pl.Date}))
```

```
shape: (5, 4)
┌─────────┬────────────┬───────┬────────┐
│ integer ┆ date       ┆ float ┆ string │
│ ---     ┆ ---        ┆ ---   ┆ ---    │
│ i64     ┆ date       ┆ f64   ┆ str    │
╞═════════╪════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 ┆ 8.0   ┆ e      │
└─────────┴────────────┴───────┴────────┘
```

strict 매개변수를 True(기본값)로 설정하면, 형변환을 수행할 수 없는 경우 오류를 출력합니다.

```python
print(df.cast({pl.String: pl.Datetime}, strict=True))
```

```
ComputeError: conversion from `str` to `datetime[μs]` failed in column 'string' for 5 out of 5 values: ["a", "b", … "e"]

You might want to try:
- setting `strict=False` to set values that cannot be converted to `null`
- using `str.strptime`, `str.to_date`, or `str.to_datetime` and providing a format string
```

만약, False로 설정할 경우, 오류가 나는 열의 값은 null로 반환됩니다.

```python
print(df.cast({pl.String: pl.Datetime}, strict=False))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬──────────────┐
│ integer ┆ date                ┆ float ┆ string       │
│ ---     ┆ ---                 ┆ ---   ┆ ---          │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ datetime[μs] │
╞═════════╪═════════════════════╪═══════╪══════════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ null         │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ null         │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ null         │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ null         │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ null         │
└─────────┴─────────────────────┴───────┴──────────────┘
```

# 4. 데이터 사전 분석

데이터프레임의 기본 정보를 간단히 살펴보도록 하겠습니다.

## 4.1 사전 분석에 사용할 함수

- **glimpse()**: DataFrame을 구성하는 행과 열에 대한 정보를 나타내 주는 함수
- **head(n), limit(n)** : DataFrame의 처음부터 n개의 행을 출력
- **tail(n)**: DataFrame의 마지막 n개의 행을 출력
- **describe()**: Series, DataFrame의 각 열에 대한 요약 통계
- **shape**: DataFrame의 크기(행/열 개수) 확인
- **height**: DataFrame의 행 개수 확인
- **width**: DataFrame의 열 개수 확인

## 4.2 데이터 확인

### 4.2.1 데이터 기본 정보 확인

glimpse() 함수는 DataFrame을 구성하는 행과 열에 대한 정보, 컬럼명, 데이터 유형, 그리고 각 컬럼의 몇 개의 데이터를 보여주어 기본 구조를 빠르게 파악하고 어떤 정보가 있는지 미리볼 수 있으므로 매우 유용합니다.

```python
print(df.glimpse())
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2, 3, 4, 5
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ float            <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ string           <str> 'a', 'b', 'c', 'd', 'e'

None
```

max_items_per_column 매개변수는 열당 표시할 최대 항목 수를 말하며, 기본값은 10개 입니다.

```python
print(df.glimpse(max_items_per_column=2))
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00
$ float            <f64> 4.0, 5.0
$ string           <str> 'a', 'b'

None
```

max_colname_length는 컬럼명을 표시할 때 사용되는 최대 길이를 지정하는 매개변수입니다. 만약, 문자열 길이가 최대 길이를 초과하게 되면 뒷 부분은 생략되어 표시됩니다.

```python
print(df.glimpse(max_colname_length=4))
```

```
Rows: 5
Columns: 4
$ int…          <i64> 1, 2, 3, 4, 5
$ date <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ flo…          <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ str…          <str> 'a', 'b', 'c', 'd', 'e'

None
```

위의 출력결과를 보면 마지막 출력에 None이라고 출력된 것을 볼 수 있습니다. return_as_string 매개변수가 True면 stdout으로 출력하는 대신 문자열로 출력하게 됩니다.

```python
print(df.glimpse(return_as_string=True))
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2, 3, 4, 5
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ float            <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ string           <str> 'a', 'b', 'c', 'd', 'e'
```

### 4.2.2 상단 값 데이터 확인

- **head(n), limit(n)**: DataFrame의 처음부터 n개의 행을 확인합니다.
- 기본적으로 데이터프레임의 처음 5행을 가져오고 출력하고 싶은 행의 수를 지정할 수 있습니다.
- 음수 값이 전달되면 마지막 절댓값 n행을 제외한 모든 행을 반환합니다.

```python
print(df.head())
# print(df.head(3))
# print(df.head(-3))
# print(df.limit())
# print(df.limit(3))
# print(df.limit(-3))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 4.2.3 하단 값 데이터 확인

- **tail(n)**: DataFrame의 마지막 n개의 행을 출력합니다.
- 기본적으로 데이터프레임의 마지막 5행을 가져오고 head와 마찬가지로 출력하고 싶은 행의 수를 지정할 수 있습니다.
- 음수 값이 전달되면 첫 번째 절댓값 n행을 제외한 모든 행을 반환합니다.

```python
print(df.tail())
# print(df.tail(3))
# print(df.tail(-3))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

## 4.3 데이터 형태

shape, height, width 함수로 DataFrame의 크기(행/열 개수) 확인할 수 있습니다.

```python
print(df.shape) # 데이터프레임 모양
```

```
(5, 4)
```

```python
print(df.height) # 행 개수
```

```
5
```

```python
print(df.width) # 열 개수
```

```
4
```

## 4.4 고유값 확인하기

approx_n_unique 함수를 사용하여 데이터프레임에 있는 각각의 컬럼에 고유한 값의 대략적인 개수를 확인할 수 있습니다. 이 함수는 HyperLogLog++ 알고리즘을 사용하여 빠르게 고유값의 개수를 추정합니다.

```python
print(df.select(pl.all().approx_n_unique()))
```

```
shape: (1, 4)
┌─────────┬──────┬───────┬────────┐
│ integer ┆ date ┆ float ┆ string │
│ ---     ┆ ---  ┆ ---   ┆ ---    │
│ u32     ┆ u32  ┆ u32   ┆ u32    │
╞═════════╪══════╪═══════╪════════╡
│ 5       ┆ 5    ┆ 5     ┆ 5      │
└─────────┴──────┴───────┴────────┘
```

## 4.5 기술통계량(요약 통계)

`Describe` 함수는 시리즈 또는 데이터프레임의 각 열에 대한 기술통계량(요약 통계)를 반환합니다.

```python
print(df.describe())
```

```
shape: (9, 5)
┌────────────┬──────────┬─────────────────────┬──────────┬────────┐
│ statistic  ┆ integer  ┆ date                ┆ float    ┆ string │
│ ---        ┆ ---      ┆ ---                 ┆ ---      ┆ ---    │
│ str        ┆ f64      ┆ str                 ┆ f64      ┆ str    │
╞════════════╪══════════╪═════════════════════╪══════════╪════════╡
│ count      ┆ 5.0      ┆ 5                   ┆ 5.0      ┆ 5      │
│ null_count ┆ 0.0      ┆ 0                   ┆ 0.0      ┆ 0      │
│ mean       ┆ 3.0      ┆ 2022-01-03 00:00:00 ┆ 6.0      ┆ null   │
│ std        ┆ 1.581139 ┆ null                ┆ 1.581139 ┆ null   │
│ min        ┆ 1.0      ┆ 2022-01-01 00:00:00 ┆ 4.0      ┆ a      │
│ 25%        ┆ 2.0      ┆ 2022-01-02 00:00:00 ┆ 5.0      ┆ null   │
│ 50%        ┆ 3.0      ┆ 2022-01-03 00:00:00 ┆ 6.0      ┆ null   │
│ 75%        ┆ 4.0      ┆ 2022-01-04 00:00:00 ┆ 7.0      ┆ null   │
│ max        ┆ 5.0      ┆ 2022-01-05 00:00:00 ┆ 8.0      ┆ e      │
└────────────┴──────────┴─────────────────────┴──────────┴────────┘
```

<aside>
👉 중앙값은 50% 백분위 수 값입니다.

</aside>

## 4.6 샘플(Sample)

sample을 사용하면 데이터프레임에서 임의의 n개의 행을 반환합니다.

```python
# df.sample(n)
# df.sample(fraction)
print(df.sample(3))
# print(df.sample(1.5))
```

- n : 반환 개수, fraction와 함께 사용할 수 없습니다.
- fraction : 반환할 항목의 분수값입니다. 기본값은 1이며, n과 함께 사용할 수 없습니다.

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
└─────────┴─────────────────────┴───────┴────────┘
```

with_replacement는 중복 추출 허용할지 설정할 수 있습니다. 기본값은 False이며, True로 설정하면 값이 두 번이상 샘플링 되도록 설정할 수 있습니다.

```python
print(df.sample(3, with_replacement=True))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
└─────────┴─────────────────────┴───────┴────────┘
```

shuffle은 추출된 샘플의 순서를 섞을지 여부를 선택합니다. shuffle를 True로 설정하면 샘플링된 행의 순서와 상관없이 출력되고, False(기본값)로 설정하면 반환되는 순서가 안정적이지도 않고 완전히 무작위적이지도 않습니다.

```python
print(df.sample(3, shuffle=True))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

seed는 난수 생성기입니다. 없음(기본값)으로 설정하면 각 샘플 작업에 대해 무작위 seed가 생성됩니다.

```python
print(df.sample(3, seed=2))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

# 5. DataFrame 데이터 조작

DataFrame의 각 셀에는 숫자, 문자열 등과 같은 다양한 형태의 데이터를 저장할 수 있으며, 행의 인덱스 값이나 열에 지정된 레이블을 사용하여 원하는 데이터를 쉽게 조회할 수 있습니다. 또한, 여러 가지 방법으로 데이터들을 조작하고 분석할 수 있습니다.

## 5.1 DataFrame의 Index(인덱스)

인덱스는 데이터프레임에서 각 `행의 위치`를 식별하는 레이블로, 인덱스를 사용하여 데이터를 빠르고 쉽게 접근할 수 있습니다.
Polars 데이터프레임은 묵시적 인덱스를 제공하는데, 이는 데이터프레임 생성 시 자동으로 부여되는 `RangeIndex`를 의미합니다.

### 5.1.1 인덱스(행)로 조회

데이터프레임에서 특정 행의 데이터를 추출할 때는 `정수형 인덱스`를 사용합니다. `df[정수형 인덱스]` 형식으로 원하는 행의 데이터를 가져올 수 있습니다.

```python
print(df[0]) # 첫 번째 행 조회
print(df[1:4]) # 2~4번째 행 조회
```

```
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

`df[0]`는 row(행) 데이터의 인덱스만 나와있으므로 df의 0번째 행의 값을 가져오게 됩니다. `df[1:4]`는 row 데이터의 인덱스 중 1 번째 ~ 3 번째 인덱스 값을 가지는 데이터를 가져오게 됩니다. 여기서 반환되는 데이터 타입은 dataframe(데이터프레임) 타입을 가지게 됩니다.

음수 인덱스로도 데이터를 가져올 수 있습니다.

```python
print(df[-3:])
print(df[::-1])
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.2 slice

데이터프레임 중 일부를 가지고 올 때 `인덱스 이름`을 이용하여 데이터를 추출하는 방법입니다. `slice[row index, column index]`를 이용해서 값을 가져올 수 있습니다.

```python
# df.slice("시작 인덱스", "길이")
print(df.slice(0,1))
print(df.slice(3)) # 길이를 설정하지 않는 경우, 오프셋에서 시작하는 모든 행이 선택
print(df.slice(-1,3))
```

```
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (2, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.3 gather_every

데이터프레임의 n번째 행을 모두 가져와 새 데이터프레임으로 반환합니다.

```python
# df.gather_every(n)
print(df.gather_every(2))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

offset 매개변수를 이용하여 시작 인덱스 설정할 수 있습니다.

```python
print(df.gather_every(2, offset=1))
```

```
shape: (2, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.4 row

지정된 인덱스나 조건을 기준으로 단일 행의 튜플 값을 반환합니다.

```python
# df.row("행 인덱스 값")
print(df.row(2))
```

```
(3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c')
```

컬럼명을 행 값에 매핑하여 딕셔너리로 반환하려면 named=True를 지정합니다. False로 지정할 경우 튜플(기본값)로 반환합니다.

```python
print(df.row(2, named=True))
```

```
{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}
```

일반 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

주어진 조건과 일치하는 행을 반환하려면 by_predicate를 사용합니다.

```python
print(df.row(by_predicate=(pl.col("string") == "b")))
```

```
(2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b')
```

by_predicate를 사용할 때 키워드로 제공해야 하며, 하나의 행이 아닌 다른 행이 반환되면 오류 조건이 됩니다. 행이 두 개 이상이면 TooManyRowsReturnedError가 발생하고, 행이 0이면 NoRowsReturnedError가 발생합니다. (둘 다 RowsError에서 상속됩니다)

```python
df[3,'string']='b'
print(df)
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

```python
print(df.row(by_predicate=(pl.col("string") == "b")))
```

```
TooManyRowsReturnedError: predicate <[(col("string")) == (String(b))]> returned 2 rows
```

```python
print(df.row(by_predicate=(pl.col("string") == "d")))
```

```
NoRowsReturnedError: predicate <[(col("string")) == (String(d))]> returned no rows
```

데이터 프레임을 반복할 때는 이 메서드를 사용하면 안 되며 행 반복이 필요한 경우 iter_rows()를 사용하시길 바랍니다.

### 5.1.5 rows

데이터프레임의 모든 데이터를 행 목록으로 반환합니다. 기본적으로 각 행은 프레임 열과 동일한 순서로 주어진 값의 튜플로 반환됩니다.

```python
print(df.rows())
```

```
[(1, datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'), (2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'), (3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c'), (4, datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b'), (5, datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')]
```

named=True로 설정하면 튜플 대신 딕셔너리로 반환합니다. 딕셔너리는 열 이름과 행 값을 매핑한 것입니다.

```python
print(df.rows(named=True))
```

```
[{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}, {'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}, {'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}, {'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}, {'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}]
```

일반 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

:::div{.callout}
데이터가 열 형태로 저장되므로 행 반복은 최적이 아니며, 잠재적으로 비용이 많이 들 수 있습니다. 가능하면 열 데이터를 처리하는 export/output 메서드 중 하나를 통해 내보내는 것을 추천드립니다. 또한, 모든 데이터를 한 번에 구체화하지 않으려면 iter_rows를 대신 rows를 사용하는 것도 고려해야 합니다. 두 메서드는 성능 차이가 거의 없지만 행을 일괄 처리하면 메모리를 줄일 수 있습니다.

:::

### 5.1.6 rows_by_key

특정 컬럼을 기준으로 행 그룹화하여 딕셔너리로 모든 데이터를 반환합니다.

```python
print(df.rows_by_key(key=["integer"]))
```

- key : 딕셔너리의 key로 사용할 컬럼명입니다.

```
defaultdict(<class 'list'>, {1: [(datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a')], 2: [(datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b')], 3: [(datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c')], 4: [(datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b')], 5: [(datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')]})
```

여러 열이 지정되면 키는 해당 값의 튜플이 되고, 그렇지 않으면 문자열이 됩니다.

```python
print(df.rows_by_key(key=["string",'integer']))
```

```
defaultdict(<class 'list'>, {(1, 'a'): [(datetime.datetime(2022, 1, 1, 0, 0), 4.0)], (2, 'b'): [(datetime.datetime(2022, 1, 2, 0, 0), 5.0)], (3, 'c'): [(datetime.datetime(2022, 1, 3, 0, 0), 6.0)], (4, 'b'): [(datetime.datetime(2022, 1, 4, 0, 0), 7.0)], (5, 'e'): [(datetime.datetime(2022, 1, 5, 0, 0), 8.0)]})
```

```python
print(df.rows_by_key(key=["string"], named=True))
```

- named : 컬럼명을 행 값에 매핑하여 튜플 대신 딕셔너리 행 그룹을 반환합니다.

```
defaultdict(<class 'list'>, {'a': [{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0}], 'b': [{'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0}, {'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0}], 'c': [{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0}], 'e': [{'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0}]})
```

키가 고유하다고 가정하여 행 그룹을 사전으로 반환합니다.

```python
print(df.rows_by_key(key=["integer"], unique=True))
```

- unique : 키가 고유함을 나타내며, 키에서 연결된 단일 행으로 1:1 매핑이 이루어지게 됩니다.

```
{1: (datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'), 2: (datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'), 3: (datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c'), 4: (datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b'), 5: (datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')}
```

```python
print(df.rows_by_key(key=["integer"], named=True, unique=True))
```

```
{1: {'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}, 2: {'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}, 3: {'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}, 4: {'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}, 5: {'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}}
```

키가 실제로 고유하지 않으면 주어진 키가 있는 마지막 행이 반환된다는 점에 유의하세요.

```python
print(df.rows_by_key(key=["string"], unique=True))
```

```
{'a': (1, datetime.datetime(2022, 1, 1, 0, 0), 4.0), 'b': (4, datetime.datetime(2022, 1, 4, 0, 0), 7.0), 'c': (3, datetime.datetime(2022, 1, 3, 0, 0), 6.0), 'e': (5, datetime.datetime(2022, 1, 5, 0, 0), 8.0)}
```

```python
print(df.rows_by_key(key=["string",'integer'], named=True, include_key=True))
```

- include_key : 연결된 데이터에 키 값을 인라인으로 포함하여 복합 키로 그룹화된 사전 행을 반환합니다(기본적으로 메모리/성능 최적화를 위해 키 값은 키에서 재구성할 수 있으므로 생략됨).

```
defaultdict(<class 'list'>, {('a', 1): [{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}], ('b', 2): [{'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}], ('c', 3): [{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}], ('b', 4): [{'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}], ('e', 5): [{'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}]})
```

:::div{.callout}
rows 메서드와 비슷하지만 행을 평면 목록으로 반환하는 대신 키 열의 값으로 그룹화하여 딕셔너리로 반환합니다. 모든 프레임 데이터를 사전으로 구체화하는 데 많은 비용이 들기 때문에 기본 연산 대신 사용해서는 안 되며, 값을 Python 데이터 구조나 Polars/Arrow로 직접 연산할 수 없는 다른 객체로 옮겨야 하는 경우에만 사용해야 합니다.

:::

### 5.1.7 iter_rows

데이터프레임의 행 값으로 구성된 이터레이터를 반환합니다. 모든 행을 구체화하지는 않습니다.

```python
print([row[0] for row in df.iter_rows()])
```

```
[1, 2, 3, 4, 5]
```

`named=True` 로 주시면 튜플(기본값) 대신 딕셔너리(명명된 경우)로 반환합니다. 딕셔너리는 컬럼명과 행 값을 매핑한 것입니다. 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

```python
print([row["float"] for row in df.iter_rows(named=True)])
```

```
[4.0, 5.0, 6.0, 7.0, 8.0]
```

기본값이 액세스 패턴에 적합하지 않다고 판단되는 매우 특정한 경우에만 buffer_size 매개변수를 수정합니다. 데이터를 반복하는 동안 내부적으로 버퍼링되는 행 수를 결정합니다. 버퍼를 사용하면 속도가 크게(~2~4배) 향상되므로 이 값을 0으로 설정하면 행 버퍼링이 비활성화됩니다.(권장하지 않음)

:::div{.callout}
데이터가 열 형태로 저장되므로 행 반복은 최적이 아닙니다. 가능하면 열 데이터를 처리하는 export/output 메서드 중 하나를 통해 내보내는 것을 추천드립니다.

:::

:::div{.callout}
iter_rows, rows, rows_by_key 메서드는 ns-정확도 시간 값이 있는 경우 Python은 기본적으로 최대 μs-정확도까지만 지원하므로 ns-정확도 값은 Python으로 변환할 때 마이크로초로 잘린다는 점에 유의해야 합니다. 이 문제가 사용 사례에 중요한 경우 다른 형식(예: Arrow 또는 NumPy)으로 내보내야 합니다.

:::

## 5.2 DataFrame의 Column(컬럼, 열)

데이터프레임의 컬럼은 각 데이터의 속성을 나타냅니다. 컬럼에 대한 정보를 알고 싶으면 `df.glimpse()`를 이용할 수 있고 각 칼럼을 선택하려면 `df[’컬럼 이름’]`을 이용하면 선택할 수 있습니다.

### 5.2.1 데이터 컬럼명 조회

컬럼명을 조회할 때에는 columns 메서드를 사용합니다.

```python
print(df.columns)
```

```
['integer', 'date', 'float', 'string']
```

컬럼명을 변경하고 싶은 경우에는 아래 코드와 같이 df.columns에 리스트 형태로 값을 주어 변경합니다.

```python
df.columns = ['id', 'date', 'score', 'grade']
print(df)
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ id  ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

또는, rename를 이용하여 딕셔너리에 key는 이전 컬럼명, value는 새로운 컬럼명으로 입력하여 특정 컬럼명을 변경할 수 있습니다.

```python
# df.rename({"기존 컬럼명":"새로운 컬럼명"})
print(df.rename({"id":"아이디"}))
```

```
shape: (5, 4)
┌────────┬─────────────────────┬───────┬───────┐
│ 아이디 ┆ date                ┆ score ┆ grade │
│ ---    ┆ ---                 ┆ ---   ┆ ---   │
│ i64    ┆ datetime[μs]        ┆ f64   ┆ str   │
╞════════╪═════════════════════╪═══════╪═══════╡
│ 1      ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2      ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3      ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4      ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5      ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└────────┴─────────────────────┴───────┴───────┘
```

```python
print(df.rename({"id":"아이디","date":"날짜"}))
```

```
shape: (5, 4)
┌────────┬─────────────────────┬───────┬───────┐
│ 아이디 ┆ 날짜                ┆ score ┆ grade │
│ ---    ┆ ---                 ┆ ---   ┆ ---   │
│ i64    ┆ datetime[μs]        ┆ f64   ┆ str   │
╞════════╪═════════════════════╪═══════╪═══════╡
│ 1      ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2      ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3      ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4      ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5      ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└────────┴─────────────────────┴───────┴───────┘
```

### 5.2.2 컬럼(열) 인덱스 조회

get_column_index 함수로 컬럼명으로 열의 인덱스를 찾을 수 있습니다.

```python
# df.get_column_index("컬럼명")
print(df.get_column_index("date"))
```

```
1
```

### 5.2.3 컬럼(열) 이름으로 조회

```python
print(df['id']) # 열 조회
print(df['id'][0])
print(df['id'][0:3])
print(df['id'][::-1])
```

```
shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
]
1
shape: (3,)
Series: 'id' [i64]
[
	1
	2
	3
]
shape: (5,)
Series: 'id' [i64]
[
	5
	4
	3
	2
	1
]
```

### 5.2.4 get_column

컬럼명을 입력하여 해당 열을 가져옵니다.

```python
# df.get_column("컬럼명")
print(df.get_column("id"))
```

```
shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
]
```

### 5.2.5 get_columns

데이터프레임의 각 열을 시리즈 리스트로 가져옵니다.

```python
print(df.get_columns())
```

```
[shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
], shape: (5,)
Series: 'date' [datetime[μs]]
[
	2022-01-01 00:00:00
	2022-01-02 00:00:00
	2022-01-03 00:00:00
	2022-01-04 00:00:00
	2022-01-05 00:00:00
], shape: (5,)
Series: 'score' [f64]
[
	4.0
	5.0
	6.0
	7.0
	8.0
], shape: (5,)
Series: 'grade' [str]
[
	"a"
	"b"
	"c"
	"b"
	"e"
]]
```

### 5.2.6 select, select_seq

데이터프레임에서 열을 선택합니다. select_seq 함수는 select와 비슷하게 동작하지만 병렬이 아닌 순차적으로 실행하기 때문에, 작업량이 적은 경우에 사용합니다.

```python
# df.select("컬럼명")
print(df.select("date"))
```

```
shape: (5, 1)
┌─────────────────────┐
│ date                │
│ ---                 │
│ datetime[μs]        │
╞═════════════════════╡
│ 2022-01-01 00:00:00 │
│ 2022-01-02 00:00:00 │
│ 2022-01-03 00:00:00 │
│ 2022-01-04 00:00:00 │
│ 2022-01-05 00:00:00 │
└─────────────────────┘
```

리스트에 여러개의 컬럼명을 작성하여 한번에 여러 열을 출력할 수 있습니다.

```python
print(df.select(["date", "grade"]))
```

pl.col() 함수를 사용하여 여러 열을 선택할 수도 있습니다.

```python
print(df.select(pl.col("date"), pl.col("grade")))
```

```
shape: (5, 2)
┌─────────────────────┬───────┐
│ date                ┆ grade │
│ ---                 ┆ ---   │
│ datetime[μs]        ┆ str   │
╞═════════════════════╪═══════╡
│ 2022-01-01 00:00:00 ┆ a     │
│ 2022-01-02 00:00:00 ┆ b     │
│ 2022-01-03 00:00:00 ┆ c     │
│ 2022-01-04 00:00:00 ┆ b     │
│ 2022-01-05 00:00:00 ┆ e     │
└─────────────────────┴───────┘
```

원하는 컬럼명을 지정할 수 있습니다.

```python
print(df.select(index=pl.col("id")))
```

```
shape: (5, 1)
┌───────┐
│ index │
│ ---   │
│ i64   │
╞═══════╡
│ 1     │
│ 2     │
│ 3     │
│ 4     │
│ 5     │
└───────┘
```

여러 출력이 있는 경우, onfig.set_auto_structify(True)을 활성화하여 Struct로 자동 인스턴스화할 수 있습니다.

```python
with pl.Config(auto_structify=True):
    print(df.select(is_odd=(pl.col(pl.Int64)),))
```

```
shape: (5, 1)
┌───────────┐
│ is_odd    │
│ ---       │
│ struct[1] │
╞═══════════╡
│ {1}       │
│ {2}       │
│ {3}       │
│ {4}       │
│ {5}       │
└───────────┘
```

### 5.2.7 iter_columns

DataFrame의 열에 대한 이터레이터를 반환합니다.

```python
print([s.name for s in df.iter_columns()])
```

```
['id', 'date', 'score', 'grade']
```

데이터프레임의 열을 수정하는 경우

```python
print(pl.DataFrame(column * 2 for column in df[['id','score']].iter_columns()))
```

만약, all()을 사용할 수 있다면 all()이 더 효율적입니다.

```python
print(df[['id','score']].select(pl.all() * 2))
```

```
shape: (5, 2)
┌─────┬───────┐
│ id  ┆ score │
│ --- ┆ ---   │
│ i64 ┆ f64   │
╞═════╪═══════╡
│ 2   ┆ 8.0   │
│ 4   ┆ 10.0  │
│ 6   ┆ 12.0  │
│ 8   ┆ 14.0  │
│ 10  ┆ 16.0  │
└─────┴───────┘
```

### 5.2.8 insert_column

원하는 열 인덱스 위치에 시리즈를 추가할 수 있습니다.

```python
s = pl.Series("age",[10,20,30,40,50])
# df.insert_column("인덱스","시리즈")
print(df.insert_column(1,s))
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

컬럼명이 있는 시리즈를 추가하려는 경우 에러가 납니다.

```python
s = pl.Series("age",[10,20,30,40,50])
print(df.insert_column(1,s))
```

```
DuplicateError: column with name "age" is already present in the DataFrame
```

### 5.2.9 with_columns, with_columns_seq

데이터프레임의 기존 열을 변경하거나 새로운 열을 추가합니다. 표현식의 작업량이 적은 경우에는 with_columns_seq를 사용하여 병렬로 실행되지 않고 순차적으로 실행되도록 합니다.

```python
print(df.with_columns((pl.col("age")**2).alias("age^2")))
```

```
shape: (5, 6)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ age^2 │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ i64   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 100   │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 400   │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 900   │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 1600  │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 2500  │
└─────┴─────┴─────────────────────┴───────┴───────┴───────┘
```

기존의 열과 추가된 열의 이름이 같은 경우 기존 열을 새로운 열의 값으로 변경합니다.

```python
print(df.with_columns(pl.col("age").cast(pl.Float64)))
```

```
shape: (5, 5)
┌─────┬──────┬─────────────────────┬───────┬───────┐
│ id  ┆ age  ┆ date                ┆ score ┆ grade │
│ --- ┆ ---  ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ f64  ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪══════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 10.0 ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 20.0 ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 30.0 ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 40.0 ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 50.0 ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴──────┴─────────────────────┴───────┴───────┘

```

쉼표(,)를 사용하여 여러 열을 추가할 수 있습니다.

```python
print(
    df.with_columns(
        (pl.col("age") ** 2).alias("age^2"),
        (pl.col("age") / 2).alias("age/2"),
        (pl.col("age") // 2).alias("age//2"),
    )
)
```

리스트로 전달하여 여러 열을 추가할 수도 있습니다.

```python
print(
    df.with_columns(
        [
            (pl.col("age") ** 2).alias("age^2"),
            (pl.col("age") / 2).alias("age/2"),
            (pl.col("age") // 2).alias("age//2"),
        ]
    )
)
```

```
shape: (5, 8)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────┬───────┬────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ age^2 ┆ age/2 ┆ age//2 │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---   ┆ ---   ┆ ---    │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ i64   ┆ f64   ┆ i64    │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════╪═══════╪════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 100   ┆ 5.0   ┆ 5      │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 400   ┆ 10.0  ┆ 10     │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 900   ┆ 15.0  ┆ 15     │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 1600  ┆ 20.0  ┆ 20     │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 2500  ┆ 25.0  ┆ 25     │
└─────┴─────┴─────────────────────┴───────┴───────┴───────┴───────┴────────┘
```

열을 추가할 때, 키워드 인수를 사용하여 쉽게 컬럼명을 지정할 수 있습니다.

```python
print(
    df.with_columns(
        # 컬럼명=식
        score_a=pl.col("age") * pl.col("score"),
        date2=pl.col("date").cast(pl.Date),
    )
)
```

```
shape: (5, 7)
┌─────┬─────┬─────────────────────┬───────┬───────┬─────────┬────────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ score_a ┆ date2      │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---     ┆ ---        │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ f64     ┆ date       │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═════════╪════════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 40.0    ┆ 2022-01-01 │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 100.0   ┆ 2022-01-02 │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 180.0   ┆ 2022-01-03 │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 280.0   ┆ 2022-01-04 │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 400.0   ┆ 2022-01-05 │
└─────┴─────┴─────────────────────┴───────┴───────┴─────────┴────────────┘
```

여러 출력이 있는 경우, Config.set_auto_structify(True): 설정을 활성화하여 Struct로 자동 인스턴스화할 수 있습니다.

```python
with pl.Config(auto_structify=True):
    print(
        df.with_columns(
            c=pl.col(["id", "age"]),
        )
    )
```

```
shape: (5, 6)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ c         │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---       │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ struct[2] │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ {1,10}    │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ {2,20}    │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ {3,30}    │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ {4,40}    │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ {5,50}    │
└─────┴─────┴─────────────────────┴───────┴───────┴───────────┘
```

:::div{.callout}
with_columns를 사용하면 새로운 데이터 프레임이 반환됩니다. 이때, 메모리 측면에서 기존 데이터 프레임의 새 복사본을 생성하지 않고 기존 데이터프레임에서 열만 새로 추가하여 불필요한 데이터 복사를 피합니다. 이는 메모리 사용을 최소화하고 성능을 향상시키는 데 도움이 됩니다.
Polars의 내부 구조를 보면 불변 데이터 프레임을 사용하며, 새로운 데이터 프레임을 만들 때 기존 데이터를 공유할 수 있는 방식으로 설계되어 있습니다. 따라서 데이터 프레임을 수정하거나 새 열을 추가하더라도, 전체 데이터 프레임을 복사하지 않고 필요한 부분만 처리하여 새로운 데이터 프레임을 생성합니다.

:::

### 5.2.10 replace_column

인덱스 위치에 있는 열 전체를 시리즈 값으로 변경합니다.

```python
s = pl.Series("a", [10, 20, 30, 40, 50])
# df.replace_column("열 인덱스", "대체할 시리즈")
print(df.replace_column(0, s))
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

### 5.2.11 with_row_index

데이터프레임의 첫 번째 열에 행 인덱스를 추가합니다. 인덱스 열의 타입은 정수형입니다.

```python
print(df.with_row_index())
```

```
shape: (5, 6)
┌───────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ index ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---   ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32   ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0     ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1     ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2     ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3     ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4     ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└───────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

인덱스 열의 컬럼명을 설정할 수도 있습니다.

```python
# df.with_row_index("인덱스 열 컬럼명")
print(df.with_row_index("id"))
```

```
shape: (5, 6)
┌─────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ id  ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32 ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0   ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1   ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2   ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3   ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4   ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

offset을 1000으로 설정하면 1000부터 인덱스를 시작합니다. offset은 음수일 수 없습니다.

```python
print(df.with_row_index("id", offset=1000))
```

```
shape: (5, 6)
┌──────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ id   ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---  ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32  ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 1000 ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1001 ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 1002 ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 1003 ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 1004 ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└──────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

int_range() 및 len() 을 사용하여 직접 인덱스를 만들 수도 있습니다.

```python
print(
    df.select(
        pl.int_range(pl.len(), dtype=pl.UInt32).alias("index"),
        pl.all(),
    )
)
```

```
shape: (5, 6)
┌───────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ index ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---   ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32   ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0     ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1     ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2     ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3     ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4     ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└───────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

## 5.3 DataFrame의 Data(데이터)

### 5.3.1 데이터 조회

행, 열을 둘 다 반영한 값을 가져올 수도 있습니다.

```python
print(df[0,'a']) # 행, 열
print(df[0,2])
print(df['a','score'])
```

```
10
2022-01-01 00:00:00
shape: (5, 2)
┌─────┬───────┐
│ a   ┆ score │
│ --- ┆ ---   │
│ i64 ┆ f64   │
╞═════╪═══════╡
│ 10  ┆ 4.0   │
│ 20  ┆ 5.0   │
│ 30  ┆ 6.0   │
│ 40  ┆ 7.0   │
│ 50  ┆ 8.0   │
└─────┴───────┘
```

`df[0, 'a']`는 row(행) 데이터의 인덱스 중 0 번째 행을 선택한다는 의미입니다. 그 행의 값 중 “a” column(컬럼, 열)을 가지는 값만 가지고 올 수 있습니다.

### 5.3.2 item

특정 데이터프레임의 값을 스칼라로 반환하거나 주어진 행/열에 있는 요소를 반환합니다. 행/열이 제공되지 않은 경우, 이는 df[0,0]과 같으며, 모양이 (1,1)인지 확인합니다. 행/열을 사용하면 df[행,열]과 같습니다.

```python
print(df.select((pl.col("score")).sum()).item())
```

```
30.0
```

```python
# df.item(행 인덱스, 열 인덱스)
print(df.item(1, 2))
```

```
2022-01-02 00:00:00
```

```python
# df.item(행 인덱스, 컬럼명)
print(df.item(2, "score"))
```

```
6.0
```

### 5.3.3 데이터 값 변경하기

행, 열 인덱스를 사용하여 해당 위치에 있는 값을 변경할 수 있습니다.

```python
df[1,1] = 3
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

다시 원래대로 돌려놓도록 하겠습니다.

```python
df[1,1] = 20
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

### 5.3.4 clone

데이터프레임을 복사할 때, `df_copy=df` 와 같이 복사하게 되면 같은 메모리 주소를 갖게 됩니다. 아래 코드를 보면 df_copy의 값을 3으로 바꾸었는데 df도 값이 바뀐것을 볼 수 있습니다.

```python
df_copy = df
df_copy[1,1] = 3
print("df",df)
print("df_copy",df_copy)
```

```
df shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
df_copy shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

다시 원래 값으로 변경한 뒤, clone 해 보도록 하겠습니다.

```python
df_copy[1,1] = 20
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

clone을 하면 데이터프레임의 복사본을 만듭니다. 이때 두 데이터프레임은 다른 메모리 주소를 가지므로 df_copy 값을 바꿔도 df에 적용되지 않는 것을 볼 수 있습니다.

```python
df_copy = df.clone()
df_copy[1,1] = 3
print("df",df)
print("df_copy",df_copy)
```

```
df shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
df_copy shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

:::div{.callout}
데이터 분석 시, 원본 데이터는 거의 건들이지 않는 것이 좋습니다. clone()을 이용해서 데이터 프레임 복사 후 분석하시는 것을 추천드립니다.

:::

## 5.4 데이터 생성

```python
%%writefile rawData.csv
사원번호,연차,입사연도,매출,순익
110,1,2015,1000000,100001
109,2,2016,2000000,200001
108,3,2017,3000000,300001
107,4,2018,4000000,400001
106,5,2019,8000000,800001
107,6,2020,16000000,1600001
```

```
Overwriting rawData.csv
```

## 5.5 데이터 읽기

CSV 파일 데이터를 읽어옵니다.

```python
print(pl.read_csv('rawData.csv'))
```

```
shape: (6, 5)
┌──────────┬──────┬──────────┬──────────┬─────────┐
│ 사원번호 ┆ 연차 ┆ 입사연도 ┆ 매출     ┆ 순익    │
│ ---      ┆ ---  ┆ ---      ┆ ---      ┆ ---     │
│ i64      ┆ i64  ┆ i64      ┆ i64      ┆ i64     │
╞══════════╪══════╪══════════╪══════════╪═════════╡
│ 110      ┆ 1    ┆ 2015     ┆ 1000000  ┆ 100001  │
│ 109      ┆ 2    ┆ 2016     ┆ 2000000  ┆ 200001  │
│ 108      ┆ 3    ┆ 2017     ┆ 3000000  ┆ 300001  │
│ 107      ┆ 4    ┆ 2018     ┆ 4000000  ┆ 400001  │
│ 106      ┆ 5    ┆ 2019     ┆ 8000000  ┆ 800001  │
│ 107      ┆ 6    ┆ 2020     ┆ 16000000 ┆ 1600001 │
└──────────┴──────┴──────────┴──────────┴─────────┘
```

# 6. 데이터 삭제

데이터프레임에서 값을 사용하는 방법은 여러 가지가 있습니다.

## 6.1 drop

`drop` 함수는 데이터프레임에서 지정한 열(컬럼)을 삭제할 때 사용하는 함수입니다.

```python
# drop(’컬럼명’)
print(df.drop('a'))
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ age ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

`df.drop('a')`을 이용해 ‘a’ 열을 삭제하였습니다. 만약 원본에 반영하고 싶다면 다시 df 변수에 저장해주어야 합니다. 실습 진행을 위해 실행시키지 않도록 하겠습니다.

```python
# df = df.drop('a')
# print(df)
```

여러 컬럼명을 연달아 작성하여 전달하거나 리스트 형태로 전달하여 여러개의 컬럼을 삭제할 수 있습니다.

```python
print(df.drop('a','score'))
# print(df.drop(['a','score']))
```

```
shape: (5, 3)
┌─────┬─────────────────────┬───────┐
│ age ┆ date                ┆ grade │
│ --- ┆ ---                 ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ str   │
╞═════╪═════════════════════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ e     │
└─────┴─────────────────────┴───────┘
```

polars 셀렉터를 사용하여 여러개의 숫자형 컬럼만 삭제할 수 있습니다.

```python
import polars.selectors as cs

print(df.drop(cs.numeric()))
```

```
shape: (5, 2)
┌─────────────────────┬───────┐
│ date                ┆ grade │
│ ---                 ┆ ---   │
│ datetime[μs]        ┆ str   │
╞═════════════════════╪═══════╡
│ 2022-01-01 00:00:00 ┆ a     │
│ 2022-01-02 00:00:00 ┆ b     │
│ 2022-01-03 00:00:00 ┆ c     │
│ 2022-01-04 00:00:00 ┆ b     │
│ 2022-01-05 00:00:00 ┆ e     │
└─────────────────────┴───────┘
```

## 6.2 drop_in_place

단일 열을 drop 후 원본에 반영한 뒤, 삭제된 열을 반환합니다.

```python
print(df.drop_in_place('a'))
```

```
shape: (5,)
Series: 'a' [i64]
[
	10
	20
	30
	40
	50
]
```

```python
print(df)
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ age ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

## 6.3 clear

동일한 컬럼명을 가진 데이터가 없거나(n=0) n행이 null로 채워진(n>0) 현재 데이터 프레임의 빈 복사본을 만듭니다.

```python
print(df2)
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1.0  ┆ 3    │
│ 2.0  ┆ 4    │
└──────┴──────┘
```

```python
print(df2.clear())
```

```
shape: (0, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
└──────┴──────┘
```

n은 지워진 데이터프레임에서 null로 채워진 행의 수로 데이터프레임의 현재 행 수보다 클 수 있습니다.

```python
print(df2.clear(n=2))
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ null ┆ null │
│ null ┆ null │
└──────┴──────┘
```

# 7. 결측치 처리

## 7.1 결측값 추가

null 값을 추가하는 방법에 대해 알아보도록 하겠습니다.

```python
df_null = pl.DataFrame({
    '이름': ['A', 'B', None],
    '나이': [25, 35, None],
    '성별': ['남', '여', '남'],
    '학점': [4.5, 4.0, None],
    '주소': [None, 'jeju', None],
})

print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
│ null ┆ null ┆ 남   ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

데이터 값 추가했던 것과 같이 None 값을 넣어줍니다.

```python
df_null[2,'성별'] = None
print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
│ null ┆ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

이번에는 NaN 값을 추가하는 방법에 대해 알아보도록 하겠습니다.

```python
df_nan = pl.DataFrame({
    '이름': ['A', 'B', 'C'],
    '나이': [25, 35, 40],
    '성별': ['남', '여', '남'],
    '학점': [4.5, 4.0, np.nan],
    '주소': ['seoul', 'jeju', 'busan'],
})

print(df_nan)
```

- np.nan: NaN으로 값을 채움

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40   ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

아래와 같이 값을 NaN으로 변경할 경우 NaN값이 아닌, null 값이 들어가게 됩니다. 이는 NaN이 실수형이기 때문에 타입이 맞지 않아 null 값으로 들어가게 됩니다.

```python
df_nan[1,1] = np.nan
print(df_nan)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ null ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40   ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

NaN 값을 추가할 때는 먼저 실수형으로 자료형을 변경한 뒤, NaN값으로 변경해주셔야 합니다.

```python
df_nan = df_nan.cast({'나이':pl.Float32})
df_nan[1,1] = np.nan
print(df_nan)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ f32  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25.0 ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ NaN  ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40.0 ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

## 7.2 결측치 확인

`null_count`는 데이터에 열별로 null 값의 개수가 몇개 있는지 확인할 수 있습니다.

```python
print(df_null.null_count()) # 결측값 개수 확인
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ u32  ┆ u32  ┆ u32  ┆ u32  ┆ u32  │
╞══════╪══════╪══════╪══════╪══════╡
│ 1    ┆ 1    ┆ 1    ┆ 1    ┆ 2    │
└──────┴──────┴──────┴──────┴──────┘
```

## 7.3 결측치 처리

### 7.3.1 결측치 삭제(drop_nulls)

`drop_nulls` 함수는 데이터프레임에서 결측값(null)을 포함한 행을 삭제할 때 사용하는 함수입니다.

```python
print(df_null.drop_nulls())
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

subset 매개변수를 사용하여 polars 셀렉터로 데이터 타입이 문자열인 열이고 null이 있는 경우 행을 삭제할 수 있습니다. 없음(기본값)으로 설정하면 모든 열에 있는 결측값을 확인하고 해당 행을 삭제합니다.

```python
print(df_null.drop_nulls(subset=cs.string()))
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

모든 행이 null인 경우, 해당 행을 삭제합니다.

```python
print(df_null.filter(~pl.all_horizontal(pl.all().is_null())))
```

```
shape: (2, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

모든 열이 null인 경우, 해당 열을 삭제합니다.

```python
df_null[1,'주소'] = None
print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ null │
│ null ┆ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

```python
print(df_null[[s.name for s in df_null if not (s.null_count() == df_null.height)]])
```

```
shape: (3, 4)
┌──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 │
│ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  │
╞══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  │
│ B    ┆ 35   ┆ 여   ┆ 4.0  │
│ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┘
```

### 7.3.2 결측치 채우기(fill_null, fill_nan)

fill_null을 사용하여 지정된 값이나 어떤 값을 채울지 전략을 세워 null 값을 채울 수 있습니다.

- value : null 값 대신 채울 값
- strategy : null 값을 채우는 데 사용되는 전략
  - None(기본값), forward, backward, min, max, mean, 0, 1
- limit : strategy에서 'forward' 또는 'backward'를 사용할 때 연속으로 채울 null 값의 개수
- matches_supertype : 채울 값의 타입이 다를 경우, 채울 값의 타입과 일치하도록 열의 타입을 채울 값의 타입으로 변경합니다. 기본값은 True이며, False로 설정할 경우 타입이 맞는 열에만 값이 채워지며, 타입이 맞지 않은 열은 null을 출력하게 됩니다.

```python
print(df_null.fill_null(99))
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ null │
│ null ┆ 99   ┆ null ┆ 99.0 ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="max"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.5  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="zero"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 0    ┆ 0.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="forward"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="forward", limit=1))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(9.9, matches_supertype=True))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ f64  ┆ f64  │
╞══════╪══════╡
│ 25.0 ┆ 4.5  │
│ 35.0 ┆ 4.0  │
│ 9.9  ┆ 9.9  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(9.9, matches_supertype=False))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ null ┆ 9.9  │
└──────┴──────┘
```

fill_nan을 사용하여 부동 소수점 NaN 값을 다른 값으로 채울 수 있습니다.

```python
print(df_nan.fill_nan(3.5))
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ f32  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25.0 ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ 3.5  ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40.0 ┆ 남   ┆ 3.5  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

:::div{.callout}
부동소수점 NaN(숫자 아님)은 누락된 값이 아니라는 점에 유의하셔야 합니다. 누락된 값을 대체하려면 fill_null()을 사용합니다.

:::

# 8. 데이터 필터

### filter

하나 이상의 조건을 기준으로 데이터프레임의 행을 필터링합니다. 필터링 결과는 논리형(True, Fasle) 시리즈로 True로 반환된 행은 행의 순서는 기존 데이터프레임과 같은 순서대로 유지되며, False로 반환된 행은 null을 포함하여 삭제됩니다.

```python
df = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6, 7, 8],
        "ham": ["a", "b", "c"],
    }
)
```

```python
# df.filter(필터링 할 조건)
print(df.filter(pl.col("foo") > 1))
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ b   │
│ 3   ┆ 8   ┆ c   │
└─────┴─────┴─────┘
```

조건을 여러개 두고 싶은 경우, `&(and, 그리고) 연산자`, `|(or, 또는) 연산자`와 결합하여 필터링 할 수 있습니다.

```python
df.filter((pl.col("foo") < 3) & (pl.col("ham") == "a"))
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘
```

```python
df.filter((pl.col("foo") == 1) | (pl.col("ham") == "c"))
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
│ 3   ┆ 8   ┆ c   │
└─────┴─────┴─────┘
```

쉼표(,)로 연결하여 & 연산자와 같이 여러 조건을 모두 만족하는 행을 출력할 수 있습니다.

```python
df.filter(
    pl.col("foo") <= 2,
    ~pl.col("ham").is_in(["b", "c"]),
)
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘
```

`컬럼명 = 값`으로 열을 필터링할 수 있습니다. pl.col(name).eq(value)와 동일하게 작동합니다.

```python
df.filter(foo=2, ham="b")
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ b   │
└─────┴─────┴─────┘
```

### is_duplicated

데이터 프레임에서 중복된 모든 행의 bool 값을 가져옵니다.

```python
df = pl.DataFrame(
    {
        "a": [1, 2, 3, 1],
        "b": ["x", "y", "z", "x"],
        "c": ["b", "b", "b", "b"],
    }
)

print(df)
```

```python
shape: (4, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
df.is_duplicated()
shape: (4,)
Series: '' [bool]
[
        true
        false
        false
        true
]
```

이 마스크를 사용하면 다음과 같이 중복된 선을 시각화할 수 있습니다.

```python
df.filter(df.is_duplicated())
shape: (2, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 1   ┆ x   │
│ 1   ┆ x   │
└─────┴─────┘
```

### is_unique

데이터프레임의 모든 고유한 행을 가지고 있는지 확인합니다.

```python
print(df.is_unique())
```

```python
shape: (4,)
Series: '' [bool]
[
	false
	true
	true
	false
]
```

고유값을 가진 행만 출력할 수 있습니다.

```python
print(df.filter(df.is_unique()))
```

```python
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

### unique

데이터프레임에서 중복된 행을 삭제합니다. 만약, 데이터프레임 또는 하위 집합에 List 유형의 열이 있는 경우 이 메서드는 실패합니다.

```python
print(df.unique())
```

```python
shape: (3, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

- subset : 중복 행을 식별할 때 고려할 열 이름 또는 선택기입니다. 없음(기본값)으로 설정하면 모든 열을 사용합니다.
- keep : {'first', 'last', 'any', 'none'} 중복 행 중 유지할 행.
  'any': 어떤 행이 유지되는지 보장하지 않습니다. 더 많은 최적화가 가능합니다. 'none': 중복 행을 유지하지 않습니다. 'first': 첫 번째 고유 행을 유지합니다. 'last': 마지막 고유 행을 유지합니다.
- **maintain_order** : 원래 데이터프레임과 동일한 순서를 유지합니다. 이 경우 계산 비용이 더 많이 듭니다. True로 설정하면 스트리밍 엔진에서 실행할 가능성이 차단됩니다.

```python
print(df.unique(subset=["b", "c"]))
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
print(df.unique(keep="last"))
```

```python
shape: (3, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ a   ┆ b   │
│ 1   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
print(df.unique(subset=["b", "c"], maintain_order=True))
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

<aside>
pandas의 drop_duplicates와 유사합니다.

</aside>

속성값 중에서 유일한 값 출력

```
print(df["a"].unique())
```

```
shape: (3,)
Series: 'a' [i64]
[
	1
	2
	3
]
```

### n_unique

고유한 행의 수 또는 고유한 행 부분 집합의 수를 반환합니다.

```python
df = pl.DataFrame(
    {
        "a": [1, 1, 2, 3, 4, 5],
        "b": [0.5, 0.5, 1.0, 2.0, 3.0, 3.0],
        "c": [True, True, True, False, True, True],
    }
)
print(df)
```

```python
shape: (6, 3)
┌─────┬─────┬───────┐
│ a   ┆ b   ┆ c     │
│ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ bool  │
╞═════╪═════╪═══════╡
│ 1   ┆ 0.5 ┆ true  │
│ 1   ┆ 0.5 ┆ true  │
│ 2   ┆ 1.0 ┆ true  │
│ 3   ┆ 2.0 ┆ false │
│ 4   ┆ 3.0 ┆ true  │
│ 5   ┆ 3.0 ┆ true  │
└─────┴─────┴───────┘
```

```python
print(df.n_unique())
```

```python
5
```

속성 값에 대한 빈도수 출력

```python
print(df['a'].n_unique())
```

```python
3
```

```python
# 단순 열
print(df.n_unique(subset=["b", "c"]))
```

```python
4
```

```python
# 표현식
df.n_unique(subset=[(pl.col("a") // 2),
                    (pl.col("c") | (pl.col("b") >= 2)),
                   ],
)
```

```python
3
```

- subset : 계산할 대상을 정의하는 하나 이상의 열/표현식

데이터 프레임 수준에서 작동하며, 표현식 수준에서 하위 집합에 대해 작업하려면 다음과 같이 구조 패킹을 대신 사용할 수 있습니다.

```python
expr_unique_subset = pl.struct("a", "b").n_unique()
```

대신 열별 고유 값의 수를 계산하려는 경우 표현식 수준 구문을 사용하여 해당 결과가 포함된 새 프레임을 반환할 수도 있습니다.

```python
df = pl.DataFrame(
    [[1, 2, 3], [1, 2, 4]], schema=["a", "b", "c"], orient="row"
)
df_nunique = df.select(pl.all().n_unique())
print(df_nunique)
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ u32 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 2   │
└─────┴─────┴─────┘
```

집계 컨텍스트에서 그룹별 고유 값을 반환하는 동등한 방법도 있습니다.

```python
df_agg_nunique = df.group_by("a").n_unique()
print(df_agg_nunique)
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 2   │
└─────┴─────┴─────┘
```

### is_empty

데이터 프레임에 행이 없는 경우 True를 반환합니다.

```python
df.is_empty()
```

```python
df.filter(pl.col("id") > 99).is_empty()
```

# 9. 데이터 정렬

## sort

지정된 컬럼명을 기준으로 데이터 프레임을 정렬합니다. 문자열로 입력할 경우 컬럼을 기준으로 정렬합니다.

```
import polars as pl

df = pl.DataFrame(
    {
        "a": [1, 2, None],
        "b": [6.0, 5.0, 4.0],
        "c": ["a", "c", "b"],
    }
)

# df.sort("컬럼명")
print(df.sort("a"))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ null ┆ 4.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

계산식을 기준으로도 정렬할 수 있습니다.

```
# df.sort("계산식")
print(df.sort(pl.col("a") + pl.col("b") * 2, nulls_last=True))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
└──────┴─────┴─────┘
```

- nulls_last : 정렬할 때 null 값을 마지막에 오도록 지정할 수 있습니다.
  - `nulls_last=True` : 모든 열에 적용되는 단일 부울 값 지정
  - `nulls_last=[True, False, True]` : 각 열에 대해 개별적으로 제어를 위해 부울 리스트 지정

이처럼 a, c 열만 nulls_last를 적용할 수 있습니다.

```
print(df.sort([pl.col("a"), pl.col("b"), pl.col("c")], nulls_last=[True, False, True]))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
└──────┴─────┴─────┘
```

리스트로 여러 컬럼명을 기준으로 정렬합니다.

```
print(df.sort(["c", "a"], descending=True))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ null ┆ 4.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
└──────┴─────┴─────┘
```

- descending : 내림차순으로 정렬합니다.

descending는 nulls_last과 마찬가지로 여러 열을 기준으로 정렬하는 경우 부울 리스트 전달하여 열별로 지정할 수 있습니다.

```
print(df.sort(["c", "a"], descending=[False, True]))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

또한 쉼표로 컬럼명을 입력하여 같은 방식으로 여러 열을 기준으로 정렬합니다.

```
df.sort("c", "a", descending=[False, True])
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

요소가 동일한 경우 순서를 유지하고 싶다면 maintain_order=True 를 합니다.

```python
import polars as pl

df = pl.DataFrame(
    {
        "a": [1, 2, None],
        "b": [6.0, 5.0, 5.0],
        "c": ["a", "b", "b"],
    }
)

print(df.sort("c", descending=True, maintain_order=True))
```

```python
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ b   │
│ null ┆ 5.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
└──────┴─────┴─────┘
```

multithreaded=True(기본값)인 경우 데이터 정렬 시 여러 스레드를 사용하여 병렬 처리하여 성능을 최적화 할 수 있습니다.

```python
print(df.sort("c", descending=True, multithreaded=True))
```

<aside>
**`multithreaded` 옵션은 언제 사용하는가?**

- 데이터셋이 매우 클 때
- 멀티코어 프로세서를 가지고 있을 때
- 데이터 정렬 작업이 시간이 많이 걸리는 경우 병렬 처리 혜택을 원할 때

작은 데이터 셋이나 디버깅을 쉽게 하고 싶은 경우에는 멀티 스레드를 사용하면 스레드를 생성하고 관리하는 오버헤드가 실제 정렬 시간보다 더 오래 걸릴 수 있습니다. 이럴 때는 단일 스레드를 사용하는 것이 더 효율적일 수 있습니다.

</aside>

## reverse

DataFrame을 반대로 뒤집습니다.

```python
df = pl.DataFrame(
    {
        "key": ["a", "b", "c"],
        "val": [1, 2, 3],
    }
)
df.reverse()
```

```python
shape: (3, 2)
┌─────┬─────┐
│ key ┆ val │
│ --- ┆ --- │
│ str ┆ i64 │
╞═════╪═════╡
│ c   ┆ 3   │
│ b   ┆ 2   │
│ a   ┆ 1   │
└─────┴─────┘
```

# 10. 문자열 처리 방법

```python
weather = pl.DataFrame(
    {
        "station": ["Station " + str(x) for x in range(1, 6)],
        "temperatures": [
            "20 5 5 E1 7 13 19 9 6 20",
            "18 8 16 11 23 E2 8 E2 E2 E2 90 70 40",
            "19 24 E9 16 6 12 10 22",
            "E2 E0 15 7 8 10 E1 24 17 13 6",
            "14 8 E0 16 22 24 E1",
        ],
    }
)
print(weather)
```

```python
weather['temperatures'].dtype
```

```python
out = weather.with_columns(
    pl.col("temperatures")
)
print(out)
```

```python
# df.columns.str.replace('바꿀값', '바꿀 문자열')
weather.with_columns(
    pl.col("temperatures").str.replace("E","W")
)
```

```python
# df.columns.str.replace('바꿀값', '바꿀 문자열')
weather.with_columns(
    weather['temperatures'].str.replace("E","W")
)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
    ).explode(
        "temperatures"
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
    ).with_columns(
        pl.col("temperatures").list.head(3).alias("top3"),
        pl.col("temperatures").list.slice(-3, 3).alias("bottom_3"),
        pl.col("temperatures").list.len().alias("obs"),
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
)
print(out)
```

```pytho
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
    .list.sum()
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
    .list.sum()
    .alias("errors")
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().str.contains("(?i)[a-z]"))
    .list.sum()
    .alias("errors")
)
print(out)
```

```python
weather_by_day = pl.DataFrame(
    {
        "station": ["Station " + str(x) for x in range(1, 11)],
        "day_1": [17, 11, 8, 22, 9, 21, 20, 8, 8, 17],
        "day_2": [15, 11, 10, 8, 7, 14, 18, 21, 15, 13],
        "day_3": [16, 15, 24, 24, 8, 23, 19, 23, 16, 10],
    }
)
print(weather_by_day)
```

```python
rank_pct = (pl.element().rank(descending=True) / pl.col("*").count()).round(2)

out = weather_by_day.with_columns(
    # create the list of homogeneous data
    pl.concat_list(pl.all().exclude("station")).alias("all_temps")
).select(
    # select all columns except the intermediate list
    pl.all().exclude("all_temps"),
    # compute the rank by calling `list.eval`
    pl.col("all_temps").list.eval(rank_pct, parallel=True).alias("temps_rank"),
)

print(out)
```

```python
array_df = pl.DataFrame(
    [
        pl.Series("Array_1", [[1, 3], [2, 5]]),
        pl.Series("Array_2", [[1, 7, 3], [8, 1, 0]]),
    ],
    schema={
        "Array_1": pl.Array(pl.Int64, 2),
        "Array_2": pl.Array(pl.Int64, 3),
    },
)
print(array_df)
```
