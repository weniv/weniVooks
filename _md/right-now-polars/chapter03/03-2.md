---
chapter: 데이터 구조
title: DataFrame(데이터프레임)
date: 2024-07-23
---

# 1. DataFrame (데이터프레임) 이란?

`데이터프레임(DataFrame)`은 시리즈를 기반으로 여러 개의 행(Row)과 열(Column)로 이루어진 2차원 데이터 배열 구조입니다. 엑셀과 유사한 테이블(표) 형태로 이루어져 있어 데이터를 다루기에 적합한 자료구조입니다.

DataFrame은 행의 인덱스 값이나 열에 지정된 레이블을 사용하여 데이터를 나타낼 수 있습니다. 단일 열은 하나의 데이터 유형만 가질 수 있으며, 시리즈로 반환됩니다. 또한, 각 행에는 리스트와 같이 다양한 데이터 유형을 포함할 수 있습니다.

# 2. DataFrame 생성

`pl.DataFrame(데이터)` 로 2차원 데이터를 생성한 후 DataFrame을 생성할 수 있습니다. 데이터에는 딕셔너리, numpy 배열, 시리즈 데이터 형태가 들어갈 수 있습니다.

## 2.1 Dictionary로 생성하기

```python
from datetime import datetime
import polars as pl

data = {
    "integer": [1, 2, 3, 4, 5],
    "date": [
        datetime(2022, 1, 1),
        datetime(2022, 1, 2),
        datetime(2022, 1, 3),
        datetime(2022, 1, 4),
        datetime(2022, 1, 5),
    ],
    "float": [4.0, 5.0, 6.0, 7.0, 8.0],
    "string": ["a", "b", "c", "d", "e"],
}

# 데이터프레임 생성하기
df = pl.DataFrame(data)
print(df)
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

## 2.2 Series 리스트로 생성하기

```python
data = [
    pl.Series("col1", [1, 2], dtype=pl.Float32),
    pl.Series("col2", [3, 4], dtype=pl.Int64),
]
df2 = pl.DataFrame(data)
print(df2)
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1.0  ┆ 3    │
│ 2.0  ┆ 4    │
└──────┴──────┘
```

## 2.3 중첩 리스트로 생성하기

중첩리스트 형태로 생성하고 스키마 설정하여 열 이름 지정합니다.

```python
data = [[1, 2, 3], [4, 5, 6]]
df3 = pl.DataFrame(data, schema=["a", "b", "c"])
print(df3)
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
│ 4   ┆ 5   ┆ 6   │
└─────┴─────┴─────┘
```

# 3. 데이터 타입

## 3.1 dtypes

데이터 타입은 데이터프레임을 출력할 때 헤더에서 확인할 수 있습니다. dtypes으로 데이터프레임 안에 있는 열의 데이터 타입(자료형)을 차례대로 확인할 수 있습니다.

```python
print(df.dtypes)
```

```
[Int64, Datetime(time_unit='us', time_zone=None), Float64, String]
```

## 3.2 schema

schema로도 컬럼명과 데이터 타입을 같이 확인할 수 있으며, 튜플 형태로 (컬럼명, 데이터 타입)으로 출력됩니다.

```python
print(df.schema)
```

```
OrderedDict([('integer', Int64), ('date', Datetime(time_unit='us', time_zone=None)), ('float', Float64), ('string', String)])
```

데이터프레임 생성 시에 스키마를 이용하여 열의 타입을 지정할 수도 있습니다.

1. **{name:type}의 딕셔너리 형태**

   - 데이터 타입이 None이면 자동으로 타입을 설정합니다.

   ```python
   data = {"col1": [0, 2], "col2": [3, 7]}
   df4 = pl.DataFrame(data, schema={"col1": pl.Float32, "col2": pl.Int64})
   print(df4)
   ```

   ```
   shape: (2, 2)
   ┌──────┬──────┐
   │ col1 ┆ col2 │
   │ ---  ┆ ---  │
   │ f32  ┆ i64  │
   ╞══════╪══════╡
   │ 0.0  ┆ 3    │
   │ 2.0  ┆ 7    │
   └──────┴──────┘
   ```

2. **(name:type) 리스트 형태**

   - 데이터 타입이 None이면 자동으로 타입을 설정합니다.

   ```python
   df5 = pl.DataFrame(data, schema=[("col1", pl.Float32), ("col2", pl.Int64)])
   print(df5)
   ```

   ```
   shape: (2, 2)
   ┌──────┬──────┐
   │ col1 ┆ col2 │
   │ ---  ┆ ---  │
   │ f32  ┆ i64  │
   ╞══════╪══════╡
   │ 0.0  ┆ 3    │
   │ 2.0  ┆ 7    │
   └──────┴──────┘
   ```

3. **열 이름을 리스트로 지정한 경우**

   - 자동으로 데이터 타입을 설정합니다.

   ```python
   import numpy as np

   data = np.array([(1, 2), (3, 4)], dtype=np.int64)
   df6 = pl.DataFrame(data, schema=["a", "b"], orient="col")
   print(df6)
   ```

   - orient
     - col(기본값) : 열을 기준으로 데이터를 넣습니다.
     - row : 행을 기준으로 데이터를 넣습니다.

   ```
   shape: (2, 2)
   ┌─────┬─────┐
   │ a   ┆ b   │
   │ --- ┆ --- │
   │ i64 ┆ i64 │
   ╞═════╪═════╡
   │ 1   ┆ 3   │
   │ 2   ┆ 4   │
   └─────┴─────┘
   ```

기본 데이터의 이름과 일치하지 않는 열 이름 목록을 제공하면 제공된 이름이 해당 목록을 덮어씁니다. 스키마에 제공된 이름의 수는 데이터 차원 수와 일치해야 합니다. 기본값으로 설정하면 `None` 데이터에서 스키마가 자동으로 설정됩니다.

## 3.3 cast

데이터프레임 열을 지정된 dtype으로 형변환합니다. 컬럼명이나 selectors로 열과 데이터 타입을 지정하여 변환합니다.

```python
# df.cast({"컬럼명": 데이터타입})
print(df.cast({"integer": pl.Float32, "float": pl.UInt8}))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ f32     ┆ datetime[μs]        ┆ u8    ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1.0     ┆ 2022-01-01 00:00:00 ┆ 4     ┆ a      │
│ 2.0     ┆ 2022-01-02 00:00:00 ┆ 5     ┆ b      │
│ 3.0     ┆ 2022-01-03 00:00:00 ┆ 6     ┆ c      │
│ 4.0     ┆ 2022-01-04 00:00:00 ┆ 7     ┆ d      │
│ 5.0     ┆ 2022-01-05 00:00:00 ┆ 8     ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

```python
import polars.selectors as cs
print(df.cast({cs.numeric(): pl.UInt32, cs.temporal(): pl.String}))
```

```
shape: (5, 4)
┌─────────┬────────────────────────────┬───────┬────────┐
│ integer ┆ date                       ┆ float ┆ string │
│ ---     ┆ ---                        ┆ ---   ┆ ---    │
│ u32     ┆ str                        ┆ u32   ┆ str    │
╞═════════╪════════════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00.000000 ┆ 4     ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00.000000 ┆ 5     ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00.000000 ┆ 6     ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00.000000 ┆ 7     ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00.000000 ┆ 8     ┆ e      │
└─────────┴────────────────────────────┴───────┴────────┘
```

모든 열을 단일 데이터 타입으로 변환할 수 있습니다.

```python
print(df.cast(pl.String))
```

```
shape: (5, 4)
┌─────────┬────────────────────────────┬───────┬────────┐
│ integer ┆ date                       ┆ float ┆ string │
│ ---     ┆ ---                        ┆ ---   ┆ ---    │
│ str     ┆ str                        ┆ str   ┆ str    │
╞═════════╪════════════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00.000000 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00.000000 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00.000000 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00.000000 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00.000000 ┆ 8.0   ┆ e      │
└─────────┴────────────────────────────┴───────┴────────┘
```

데이터 타입과 일치하는 모든 열을 다른 데이터 타입으로 변환할 수도 있습니다.

```python
print(df.cast({pl.Datetime: pl.Date}))
```

```
shape: (5, 4)
┌─────────┬────────────┬───────┬────────┐
│ integer ┆ date       ┆ float ┆ string │
│ ---     ┆ ---        ┆ ---   ┆ ---    │
│ i64     ┆ date       ┆ f64   ┆ str    │
╞═════════╪════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 ┆ 8.0   ┆ e      │
└─────────┴────────────┴───────┴────────┘
```

strict 매개변수를 True(기본값)로 설정하면, 형변환을 수행할 수 없는 경우 오류를 출력합니다.

```python
print(df.cast({pl.String: pl.Datetime}, strict=True))
```

```
ComputeError: conversion from `str` to `datetime[μs]` failed in column 'string' for 5 out of 5 values: ["a", "b", … "e"]

You might want to try:
- setting `strict=False` to set values that cannot be converted to `null`
- using `str.strptime`, `str.to_date`, or `str.to_datetime` and providing a format string
```

만약, False로 설정할 경우, 오류가 나는 열의 값은 null로 반환됩니다.

```python
print(df.cast({pl.String: pl.Datetime}, strict=False))
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬──────────────┐
│ integer ┆ date                ┆ float ┆ string       │
│ ---     ┆ ---                 ┆ ---   ┆ ---          │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ datetime[μs] │
╞═════════╪═════════════════════╪═══════╪══════════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ null         │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ null         │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ null         │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ null         │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ null         │
└─────────┴─────────────────────┴───────┴──────────────┘
```

# 4. 데이터 사전 분석

데이터프레임의 데이터를 보는 방법을 알아봅시다.

## 4.1 사전 분석에 사용할 함수

- **glimpse()**: DataFrame을 구성하는 행과 열에 대한 정보를 나타내 주는 함수
- **head(n), limit(n)** : DataFrame의 처음부터 n줄의 행을 출력
- **tail(n)**: DataFrame의 마지막 n줄의 행을 출력
- **describe()**: Series, DataFrame의 각 열에 대한 요약 통계
- **shape**: DataFrame의 크기(행/열 개수) 확인
- **height**: DataFrame의 행 개수 확인
- **width**: DataFrame의 열 개수 확인

## 4.2 데이터 확인

### 4.2.1 데이터 기본 정보 확인

glimpse를 사용하여 데이터프레임에 어떤 정보가 있는지 미리볼 수 있습니다. 컬럼명, 데이터 유형, 몇 개의 데이터가 표시됩니다.

```python
print(df.glimpse())
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2, 3, 4, 5
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ float            <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ string           <str> 'a', 'b', 'c', 'd', 'e'

None
```

max_items_per_column 매개변수는 열당 표시할 최대 항목 수를 말하며, 기본값은 10개 입니다.

```python
print(df.glimpse(max_items_per_column=2))
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00
$ float            <f64> 4.0, 5.0
$ string           <str> 'a', 'b'

None
```

max_colname_length 매개변수는 표시되는 열 이름의 최대 길이로 컬럼명이 최대 길이를 초과할 경우 뒷 부분은 잘리게 됩니다.

```python
print(df.glimpse(max_colname_length=4))
```

```
Rows: 5
Columns: 4
$ int…          <i64> 1, 2, 3, 4, 5
$ date <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ flo…          <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ str…          <str> 'a', 'b', 'c', 'd', 'e'

None
```

위의 출력결과를 보면 마지막 출력에 None이라고 출력된 것을 볼 수 있습니다. return_as_string 매개변수가 True면 stdout으로 출력하는 대신 문자열로 출력하게 됩니다.

```python
print(df.glimpse(return_as_string=True))
```

```
Rows: 5
Columns: 4
$ integer          <i64> 1, 2, 3, 4, 5
$ date    <datetime[μs]> 2022-01-01 00:00:00, 2022-01-02 00:00:00, 2022-01-03 00:00:00, 2022-01-04 00:00:00, 2022-01-05 00:00:00
$ float            <f64> 4.0, 5.0, 6.0, 7.0, 8.0
$ string           <str> 'a', 'b', 'c', 'd', 'e'
```

### 4.2.2 상단 값 데이터 확인

head와 limit 함수는 기본적으로 데이터프레임의 처음 5행을 가져옵니다. 아래 주석으로 된 코드와 같이 출력하고 싶은 행의 수를 지정할 수 있습니다.

```python
print(df.head())
# print(df.head(3))
# print(df.head(-3))
# print(df.limit())
# print(df.limit(3))
# print(df.limit(-3))
```

- **head(n), limit(n)**: DataFrame의 처음부터 n개의 행을 출력합니다. 음수 값이 전달되면 마지막 절댓값 n행을 제외한 모든 행을 반환합니다.

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 4.2.3 하단 값 데이터 확인

tail 함수는 데이터프레임의 마지막 5행을 가져옵니다. head와 마찬가지로 출력하고 싶은 행의 수를 지정할 수 있습니다.

```python
print(df.tail())
# print(df.tail(3))
# print(df.tail(-3))
```

- **tail(n)**: DataFrame의 마지막 n개의 행을 출력합니다. 음수 값이 전달되면 첫 번째 절댓값 n행을 제외한 모든 행을 반환합니다.

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

## 4.3 데이터 형태

shape, height, width 함수로 DataFrame의 크기(행/열 개수) 확인할 수 있습니다.

```python
print(df.shape) # 데이터프레임 모양
```

```
(5, 4)
```

```python
print(df.height) # 행 개수
```

```
5
```

```python
print(df.width) # 열 개수
```

```
4
```

## 4.4 고유값 확인하기

approx_n_unique 함수를 사용하여 데이터프레임에 있는 각각의 컬럼에 고유한 값의 대략적인 개수를 확인할 수 있습니다. 이 작업은 카디널리티 추정을 위해 HyperLogLog++ 알고리즘을 사용하여 수행됩니다.

```python
print(df.select(pl.all().approx_n_unique()))
```

```
shape: (1, 4)
┌─────────┬──────┬───────┬────────┐
│ integer ┆ date ┆ float ┆ string │
│ ---     ┆ ---  ┆ ---   ┆ ---    │
│ u32     ┆ u32  ┆ u32   ┆ u32    │
╞═════════╪══════╪═══════╪════════╡
│ 5       ┆ 5    ┆ 5     ┆ 5      │
└─────────┴──────┴───────┴────────┘
```

## 4.5 기술통계량(요약 통계)

`Describe` 함수는 시리즈 또는 데이터프레임의 각 열에 대한 기술통계량(요약 통계)를 반환합니다.

```python
print(df.describe())
```

```
shape: (9, 5)
┌────────────┬──────────┬─────────────────────┬──────────┬────────┐
│ statistic  ┆ integer  ┆ date                ┆ float    ┆ string │
│ ---        ┆ ---      ┆ ---                 ┆ ---      ┆ ---    │
│ str        ┆ f64      ┆ str                 ┆ f64      ┆ str    │
╞════════════╪══════════╪═════════════════════╪══════════╪════════╡
│ count      ┆ 5.0      ┆ 5                   ┆ 5.0      ┆ 5      │
│ null_count ┆ 0.0      ┆ 0                   ┆ 0.0      ┆ 0      │
│ mean       ┆ 3.0      ┆ 2022-01-03 00:00:00 ┆ 6.0      ┆ null   │
│ std        ┆ 1.581139 ┆ null                ┆ 1.581139 ┆ null   │
│ min        ┆ 1.0      ┆ 2022-01-01 00:00:00 ┆ 4.0      ┆ a      │
│ 25%        ┆ 2.0      ┆ 2022-01-02 00:00:00 ┆ 5.0      ┆ null   │
│ 50%        ┆ 3.0      ┆ 2022-01-03 00:00:00 ┆ 6.0      ┆ null   │
│ 75%        ┆ 4.0      ┆ 2022-01-04 00:00:00 ┆ 7.0      ┆ null   │
│ max        ┆ 5.0      ┆ 2022-01-05 00:00:00 ┆ 8.0      ┆ e      │
└────────────┴──────────┴─────────────────────┴──────────┴────────┘
```

:::div{.callout}
중앙값은 50% 백분위 수 값입니다.

:::

## 4.6 샘플(Sample)

sample을 사용하면 데이터프레임에서 임의의 n개의 행을 얻을 수 있습니다.

```python
# df.sample(n)
# df.sample(fraction)
print(df.sample(3))
# print(df.sample(1.5))
```

- n : 반환 개수, fraction와 함께 사용할 수 없습니다.
- fraction : 반환할 항목의 분수값입니다. 기본값은 1이며, n과 함께 사용할 수 없습니다.

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
└─────────┴─────────────────────┴───────┴────────┘
```

with_replacement를 기본값은 False이며, True로 설정하면 값이 두 번이상 샘플링 되도록 설정할 수 있습니다.

```python
print(df.sample(3, with_replacement=True))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
└─────────┴─────────────────────┴───────┴────────┘
```

shuffle를 True로 설정하면 샘플링된 행의 순서와 상관없이 출력됩니다. False(기본값)로 설정하면 반환되는 순서가 안정적이지도 않고 완전히 무작위적이지도 않습니다.

```python
print(df.sample(3, shuffle=True))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

seed는 난수 생성기입니다. 없음(기본값)으로 설정하면 각 샘플 작업에 대해 무작위 seed가 생성됩니다.

```python
print(df.sample(3, seed=2))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

# 5. DataFrame에 데이터 조작

데이터프레임의 데이터는 행과 열에 대한 값을 말합니다. 다양한 방법을 통해 데이터프레임의 값을 활용할 수 있습니다.

## 5.1 DataFrame의 Index(인덱스)

데이터프레임에는 행과 열에 대한 인덱스가 존재합니다. 인덱스란 각 `데이터의 위치`를 나타내며 이를 이용하면 데이터를 빠르고 쉽게 관리할 수 있습니다.

데이터프레임에도 `묵시적 인덱스`를 제공합니다. 묵시적 인덱스는 데이터 프레임을 생성하면 `RangeIndex`가 자동으로 생성되는 인덱스입니다.

### 5.1.1 인덱스(행)로 조회

데이터프레임 중 `정수형 인덱스`를 가지고 행에 있는 데이터 값을 추출하는 방법입니다. df[정수형 인덱스]를 이용해서 값을 가져올 수 있습니다.

먼저, 행의 인덱스 값만 이용해서 데이터프레임의 데이터를 가져와보도록 하겠습니다.

```python
print(df[0]) # 행 조회
print(df[1:4])
```

```
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

`df[0]`는 row(행) 데이터의 인덱스만 나와있으므로 df의 0번째 행의 값을 가져오게 됩니다. `df[1:4]`는 row 데이터의 인덱스 중 1 번째 ~ 3 번째 인덱스 값을 가지는 데이터를 가져오게 됩니다. 여기서 반환되는 데이터 타입은 dataframe(데이터프레임) 타입을 가지게 됩니다.

음수 인덱스로도 데이터를 가져올 수 있습니다.

```python
print(df[-3:])
print(df[::-1])
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.2 slice

데이터프레임 중 일부를 가지고 올 때 `인덱스 이름`을 이용하여 데이터를 추출하는 방법입니다. `slice[row index, column index]`를 이용해서 값을 가져올 수 있습니다.

```python
# df.slice("시작 인덱스", "길이")
print(df.slice(0,1))
print(df.slice(3)) # 길이를 설정하지 않는 경우, 오프셋에서 시작하는 모든 행이 선택
print(df.slice(-1,3))
```

```
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (2, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
shape: (1, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.3 gather_every

데이터프레임의 n번째 행을 모두 가져와 새 데이터프레임으로 반환합니다.

```python
# df.gather_every(n)
print(df.gather_every(2))
```

```
shape: (3, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

offset 매개변수를 이용하여 시작 인덱스 설정할 수 있습니다.

```python
print(df.gather_every(2, offset=1))
```

```
shape: (2, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ d      │
└─────────┴─────────────────────┴───────┴────────┘
```

### 5.1.4 row

지정된 인덱스나 조건을 기준으로 단일 행의 튜플 값을 반환합니다.

```python
# df.row("행 인덱스 값")
print(df.row(2))
```

```
(3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c')
```

컬럼명을 행 값에 매핑하여 딕셔너리로 반환하려면 named=True를 지정합니다. False로 지정할 경우 튜플(기본값)로 반환합니다.

```python
print(df.row(2, named=True))
```

```
{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}
```

일반 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

주어진 조건과 일치하는 행을 반환하려면 by_predicate를 사용합니다.

```python
print(df.row(by_predicate=(pl.col("string") == "b")))
```

```
(2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b')
```

by_predicate를 사용할 때 키워드로 제공해야 하며, 하나의 행이 아닌 다른 행이 반환되면 오류 조건이 됩니다. 행이 두 개 이상이면 TooManyRowsReturnedError가 발생하고, 행이 0이면 NoRowsReturnedError가 발생합니다. (둘 다 RowsError에서 상속됩니다)

```python
df[3,'string']='b'
print(df)
```

```
shape: (5, 4)
┌─────────┬─────────────────────┬───────┬────────┐
│ integer ┆ date                ┆ float ┆ string │
│ ---     ┆ ---                 ┆ ---   ┆ ---    │
│ i64     ┆ datetime[μs]        ┆ f64   ┆ str    │
╞═════════╪═════════════════════╪═══════╪════════╡
│ 1       ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a      │
│ 2       ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b      │
│ 3       ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c      │
│ 4       ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b      │
│ 5       ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e      │
└─────────┴─────────────────────┴───────┴────────┘
```

```python
print(df.row(by_predicate=(pl.col("string") == "b")))
```

```
TooManyRowsReturnedError: predicate <[(col("string")) == (String(b))]> returned 2 rows
```

```python
print(df.row(by_predicate=(pl.col("string") == "d")))
```

```
NoRowsReturnedError: predicate <[(col("string")) == (String(d))]> returned no rows
```

데이터 프레임을 반복할 때는 이 메서드를 사용하면 안 되며 행 반복이 필요한 경우 iter_rows()를 사용하시길 바랍니다.

### 5.1.5 rows

데이터프레임의 모든 데이터를 행 목록으로 반환합니다. 기본적으로 각 행은 프레임 열과 동일한 순서로 주어진 값의 튜플로 반환됩니다.

```python
print(df.rows())
```

```
[(1, datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'), (2, datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'), (3, datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c'), (4, datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b'), (5, datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')]
```

named=True로 설정하면 튜플 대신 딕셔너리로 반환합니다. 딕셔너리는 열 이름과 행 값을 매핑한 것입니다.

```python
print(df.rows(named=True))
```

```
[{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}, {'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}, {'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}, {'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}, {'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}]
```

일반 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

:::div{.callout}
데이터가 열 형태로 저장되므로 행 반복은 최적이 아니며, 잠재적으로 비용이 많이 들 수 있습니다. 가능하면 열 데이터를 처리하는 export/output 메서드 중 하나를 통해 내보내는 것을 추천드립니다. 또한, 모든 데이터를 한 번에 구체화하지 않으려면 iter_rows를 대신 rows를 사용하는 것도 고려해야 합니다. 두 메서드는 성능 차이가 거의 없지만 행을 일괄 처리하면 메모리를 줄일 수 있습니다.

:::

### 5.1.6 rows_by_key

특정 컬럼을 기준으로 행 그룹화하여 딕셔너리로 모든 데이터를 반환합니다.

```python
print(df.rows_by_key(key=["integer"]))
```

- key : 딕셔너리의 key로 사용할 컬럼명입니다.

```
defaultdict(<class 'list'>, {1: [(datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a')], 2: [(datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b')], 3: [(datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c')], 4: [(datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b')], 5: [(datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')]})
```

여러 열이 지정되면 키는 해당 값의 튜플이 되고, 그렇지 않으면 문자열이 됩니다.

```python
print(df.rows_by_key(key=["string",'integer']))
```

```
defaultdict(<class 'list'>, {(1, 'a'): [(datetime.datetime(2022, 1, 1, 0, 0), 4.0)], (2, 'b'): [(datetime.datetime(2022, 1, 2, 0, 0), 5.0)], (3, 'c'): [(datetime.datetime(2022, 1, 3, 0, 0), 6.0)], (4, 'b'): [(datetime.datetime(2022, 1, 4, 0, 0), 7.0)], (5, 'e'): [(datetime.datetime(2022, 1, 5, 0, 0), 8.0)]})
```

```python
print(df.rows_by_key(key=["string"], named=True))
```

- named : 컬럼명을 행 값에 매핑하여 튜플 대신 딕셔너리 행 그룹을 반환합니다.

```
defaultdict(<class 'list'>, {'a': [{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0}], 'b': [{'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0}, {'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0}], 'c': [{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0}], 'e': [{'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0}]})
```

키가 고유하다고 가정하여 행 그룹을 사전으로 반환합니다.

```python
print(df.rows_by_key(key=["integer"], unique=True))
```

- unique : 키가 고유함을 나타내며, 키에서 연결된 단일 행으로 1:1 매핑이 이루어지게 됩니다.

```
{1: (datetime.datetime(2022, 1, 1, 0, 0), 4.0, 'a'), 2: (datetime.datetime(2022, 1, 2, 0, 0), 5.0, 'b'), 3: (datetime.datetime(2022, 1, 3, 0, 0), 6.0, 'c'), 4: (datetime.datetime(2022, 1, 4, 0, 0), 7.0, 'b'), 5: (datetime.datetime(2022, 1, 5, 0, 0), 8.0, 'e')}
```

```python
print(df.rows_by_key(key=["integer"], named=True, unique=True))
```

```
{1: {'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}, 2: {'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}, 3: {'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}, 4: {'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}, 5: {'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}}
```

키가 실제로 고유하지 않으면 주어진 키가 있는 마지막 행이 반환된다는 점에 유의하세요.

```python
print(df.rows_by_key(key=["string"], unique=True))
```

```
{'a': (1, datetime.datetime(2022, 1, 1, 0, 0), 4.0), 'b': (4, datetime.datetime(2022, 1, 4, 0, 0), 7.0), 'c': (3, datetime.datetime(2022, 1, 3, 0, 0), 6.0), 'e': (5, datetime.datetime(2022, 1, 5, 0, 0), 8.0)}
```

```python
print(df.rows_by_key(key=["string",'integer'], named=True, include_key=True))
```

- include_key : 연결된 데이터에 키 값을 인라인으로 포함하여 복합 키로 그룹화된 사전 행을 반환합니다(기본적으로 메모리/성능 최적화를 위해 키 값은 키에서 재구성할 수 있으므로 생략됨).

```
defaultdict(<class 'list'>, {('a', 1): [{'integer': 1, 'date': datetime.datetime(2022, 1, 1, 0, 0), 'float': 4.0, 'string': 'a'}], ('b', 2): [{'integer': 2, 'date': datetime.datetime(2022, 1, 2, 0, 0), 'float': 5.0, 'string': 'b'}], ('c', 3): [{'integer': 3, 'date': datetime.datetime(2022, 1, 3, 0, 0), 'float': 6.0, 'string': 'c'}], ('b', 4): [{'integer': 4, 'date': datetime.datetime(2022, 1, 4, 0, 0), 'float': 7.0, 'string': 'b'}], ('e', 5): [{'integer': 5, 'date': datetime.datetime(2022, 1, 5, 0, 0), 'float': 8.0, 'string': 'e'}]})
```

:::div{.callout}
rows 메서드와 비슷하지만 행을 평면 목록으로 반환하는 대신 키 열의 값으로 그룹화하여 딕셔너리로 반환합니다. 모든 프레임 데이터를 사전으로 구체화하는 데 많은 비용이 들기 때문에 기본 연산 대신 사용해서는 안 되며, 값을 Python 데이터 구조나 Polars/Arrow로 직접 연산할 수 없는 다른 객체로 옮겨야 하는 경우에만 사용해야 합니다.

:::

### 5.1.7 iter_rows

데이터프레임의 행 값으로 구성된 이터레이터를 반환합니다. 모든 행을 구체화하지는 않습니다.

```python
print([row[0] for row in df.iter_rows()])
```

```
[1, 2, 3, 4, 5]
```

`named=True` 로 주시면 튜플(기본값) 대신 딕셔너리(명명된 경우)로 반환합니다. 딕셔너리는 컬럼명과 행 값을 매핑한 것입니다. 튜플을 반환하는 것보다 비용이 많이 들지만 컬럼명으로 값에 접근할 수 있습니다.

```python
print([row["float"] for row in df.iter_rows(named=True)])
```

```
[4.0, 5.0, 6.0, 7.0, 8.0]
```

기본값이 액세스 패턴에 적합하지 않다고 판단되는 매우 특정한 경우에만 buffer_size 매개변수를 수정합니다. 데이터를 반복하는 동안 내부적으로 버퍼링되는 행 수를 결정합니다. 버퍼를 사용하면 속도가 크게(~2~4배) 향상되므로 이 값을 0으로 설정하면 행 버퍼링이 비활성화됩니다.(권장하지 않음)

:::div{.callout}
데이터가 열 형태로 저장되므로 행 반복은 최적이 아닙니다. 가능하면 열 데이터를 처리하는 export/output 메서드 중 하나를 통해 내보내는 것을 추천드립니다.

:::

:::div{.callout}
iter_rows, rows, rows_by_key 메서드는 ns-정확도 시간 값이 있는 경우 Python은 기본적으로 최대 μs-정확도까지만 지원하므로 ns-정확도 값은 Python으로 변환할 때 마이크로초로 잘린다는 점에 유의해야 합니다. 이 문제가 사용 사례에 중요한 경우 다른 형식(예: Arrow 또는 NumPy)으로 내보내야 합니다.

:::

## 5.2 DataFrame의 Column(컬럼, 열)

데이터프레임의 컬럼은 각 데이터의 속성을 나타냅니다. 컬럼에 대한 정보를 알고 싶으면 `df.glimpse()`를 이용할 수 있고 각 칼럼을 선택하려면 `df[’컬럼 이름’]`을 이용하면 선택할 수 있습니다.

### 5.2.1 데이터 컬럼명 조회

컬럼명을 조회할 때에는 columns 메서드를 사용합니다.

```python
print(df.columns)
```

```
['integer', 'date', 'float', 'string']
```

컬럼명을 변경하고 싶은 경우에는 아래 코드와 같이 df.columns에 리스트 형태로 값을 주어 변경합니다.

```python
df.columns = ['id', 'date', 'score', 'grade']
print(df)
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ id  ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

또는, rename를 이용하여 딕셔너리에 key는 이전 컬럼명, value는 새로운 컬럼명으로 입력하여 특정 컬럼명을 변경할 수 있습니다.

```python
# df.rename({"기존 컬럼명":"새로운 컬럼명"})
print(df.rename({"id":"아이디"}))
```

```
shape: (5, 4)
┌────────┬─────────────────────┬───────┬───────┐
│ 아이디 ┆ date                ┆ score ┆ grade │
│ ---    ┆ ---                 ┆ ---   ┆ ---   │
│ i64    ┆ datetime[μs]        ┆ f64   ┆ str   │
╞════════╪═════════════════════╪═══════╪═══════╡
│ 1      ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2      ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3      ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4      ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5      ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└────────┴─────────────────────┴───────┴───────┘
```

```python
print(df.rename({"id":"아이디","date":"날짜"}))
```

```
shape: (5, 4)
┌────────┬─────────────────────┬───────┬───────┐
│ 아이디 ┆ 날짜                ┆ score ┆ grade │
│ ---    ┆ ---                 ┆ ---   ┆ ---   │
│ i64    ┆ datetime[μs]        ┆ f64   ┆ str   │
╞════════╪═════════════════════╪═══════╪═══════╡
│ 1      ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2      ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3      ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4      ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5      ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└────────┴─────────────────────┴───────┴───────┘
```

### 5.2.2 컬럼(열) 인덱스 조회

get_column_index 함수로 컬럼명으로 열의 인덱스를 찾을 수 있습니다.

```python
# df.get_column_index("컬럼명")
print(df.get_column_index("date"))
```

```
1
```

### 5.2.3 컬럼(열) 이름으로 조회

```python
print(df['id']) # 열 조회
print(df['id'][0])
print(df['id'][0:3])
print(df['id'][::-1])
```

```
shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
]
1
shape: (3,)
Series: 'id' [i64]
[
	1
	2
	3
]
shape: (5,)
Series: 'id' [i64]
[
	5
	4
	3
	2
	1
]
```

### 5.2.4 get_column

컬럼명을 입력하여 해당 열을 가져옵니다.

```python
# df.get_column("컬럼명")
print(df.get_column("id"))
```

```
shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
]
```

### 5.2.5 get_columns

데이터프레임의 각 열을 시리즈 리스트로 가져옵니다.

```python
print(df.get_columns())
```

```
[shape: (5,)
Series: 'id' [i64]
[
	1
	2
	3
	4
	5
], shape: (5,)
Series: 'date' [datetime[μs]]
[
	2022-01-01 00:00:00
	2022-01-02 00:00:00
	2022-01-03 00:00:00
	2022-01-04 00:00:00
	2022-01-05 00:00:00
], shape: (5,)
Series: 'score' [f64]
[
	4.0
	5.0
	6.0
	7.0
	8.0
], shape: (5,)
Series: 'grade' [str]
[
	"a"
	"b"
	"c"
	"b"
	"e"
]]
```

### 5.2.6 select, select_seq

데이터프레임에서 열을 선택합니다. select_seq 함수는 select와 비슷하게 동작하지만 병렬이 아닌 순차적으로 실행하기 때문에, 작업량이 적은 경우에 사용합니다.

```python
# df.select("컬럼명")
print(df.select("date"))
```

```
shape: (5, 1)
┌─────────────────────┐
│ date                │
│ ---                 │
│ datetime[μs]        │
╞═════════════════════╡
│ 2022-01-01 00:00:00 │
│ 2022-01-02 00:00:00 │
│ 2022-01-03 00:00:00 │
│ 2022-01-04 00:00:00 │
│ 2022-01-05 00:00:00 │
└─────────────────────┘
```

리스트에 여러개의 컬럼명을 작성하여 한번에 여러 열을 출력할 수 있습니다.

```python
print(df.select(["date", "grade"]))
```

pl.col() 함수를 사용하여 여러 열을 선택할 수도 있습니다.

```python
print(df.select(pl.col("date"), pl.col("grade")))
```

```
shape: (5, 2)
┌─────────────────────┬───────┐
│ date                ┆ grade │
│ ---                 ┆ ---   │
│ datetime[μs]        ┆ str   │
╞═════════════════════╪═══════╡
│ 2022-01-01 00:00:00 ┆ a     │
│ 2022-01-02 00:00:00 ┆ b     │
│ 2022-01-03 00:00:00 ┆ c     │
│ 2022-01-04 00:00:00 ┆ b     │
│ 2022-01-05 00:00:00 ┆ e     │
└─────────────────────┴───────┘
```

원하는 컬럼명을 지정할 수 있습니다.

```python
print(df.select(index=pl.col("id")))
```

```
shape: (5, 1)
┌───────┐
│ index │
│ ---   │
│ i64   │
╞═══════╡
│ 1     │
│ 2     │
│ 3     │
│ 4     │
│ 5     │
└───────┘
```

여러 출력이 있는 경우, onfig.set_auto_structify(True)을 활성화하여 Struct로 자동 인스턴스화할 수 있습니다.

```python
with pl.Config(auto_structify=True):
    print(df.select(is_odd=(pl.col(pl.Int64)),))
```

```
shape: (5, 1)
┌───────────┐
│ is_odd    │
│ ---       │
│ struct[1] │
╞═══════════╡
│ {1}       │
│ {2}       │
│ {3}       │
│ {4}       │
│ {5}       │
└───────────┘
```

### 5.2.7 iter_columns

DataFrame의 열에 대한 이터레이터를 반환합니다.

```python
print([s.name for s in df.iter_columns()])
```

```
['id', 'date', 'score', 'grade']
```

데이터프레임의 열을 수정하는 경우

```python
print(pl.DataFrame(column * 2 for column in df[['id','score']].iter_columns()))
```

만약, all()을 사용할 수 있다면 all()이 더 효율적입니다.

```python
print(df[['id','score']].select(pl.all() * 2))
```

```
shape: (5, 2)
┌─────┬───────┐
│ id  ┆ score │
│ --- ┆ ---   │
│ i64 ┆ f64   │
╞═════╪═══════╡
│ 2   ┆ 8.0   │
│ 4   ┆ 10.0  │
│ 6   ┆ 12.0  │
│ 8   ┆ 14.0  │
│ 10  ┆ 16.0  │
└─────┴───────┘
```

### 5.2.8 insert_column

원하는 열 인덱스 위치에 시리즈를 추가할 수 있습니다.

```python
s = pl.Series("age",[10,20,30,40,50])
# df.insert_column("인덱스","시리즈")
print(df.insert_column(1,s))
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

컬럼명이 있는 시리즈를 추가하려는 경우 에러가 납니다.

```python
s = pl.Series("age",[10,20,30,40,50])
print(df.insert_column(1,s))
```

```
DuplicateError: column with name "age" is already present in the DataFrame
```

### 5.2.9 with_columns, with_columns_seq

데이터프레임의 기존 열을 변경하거나 새로운 열을 추가합니다. 표현식의 작업량이 적은 경우에는 with_columns_seq를 사용하여 병렬로 실행되지 않고 순차적으로 실행되도록 합니다.

```python
print(df.with_columns((pl.col("age")**2).alias("age^2")))
```

```
shape: (5, 6)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ age^2 │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ i64   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 100   │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 400   │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 900   │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 1600  │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 2500  │
└─────┴─────┴─────────────────────┴───────┴───────┴───────┘
```

기존의 열과 추가된 열의 이름이 같은 경우 기존 열을 새로운 열의 값으로 변경합니다.

```python
print(df.with_columns(pl.col("age").cast(pl.Float64)))
```

```
shape: (5, 5)
┌─────┬──────┬─────────────────────┬───────┬───────┐
│ id  ┆ age  ┆ date                ┆ score ┆ grade │
│ --- ┆ ---  ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ f64  ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪══════╪═════════════════════╪═══════╪═══════╡
│ 1   ┆ 10.0 ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 2   ┆ 20.0 ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 3   ┆ 30.0 ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 4   ┆ 40.0 ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 5   ┆ 50.0 ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴──────┴─────────────────────┴───────┴───────┘

```

쉼표(,)를 사용하여 여러 열을 추가할 수 있습니다.

```python
print(
    df.with_columns(
        (pl.col("age") ** 2).alias("age^2"),
        (pl.col("age") / 2).alias("age/2"),
        (pl.col("age") // 2).alias("age//2"),
    )
)
```

리스트로 전달하여 여러 열을 추가할 수도 있습니다.

```python
print(
    df.with_columns(
        [
            (pl.col("age") ** 2).alias("age^2"),
            (pl.col("age") / 2).alias("age/2"),
            (pl.col("age") // 2).alias("age//2"),
        ]
    )
)
```

```
shape: (5, 8)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────┬───────┬────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ age^2 ┆ age/2 ┆ age//2 │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---   ┆ ---   ┆ ---    │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ i64   ┆ f64   ┆ i64    │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════╪═══════╪════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 100   ┆ 5.0   ┆ 5      │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 400   ┆ 10.0  ┆ 10     │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 900   ┆ 15.0  ┆ 15     │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 1600  ┆ 20.0  ┆ 20     │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 2500  ┆ 25.0  ┆ 25     │
└─────┴─────┴─────────────────────┴───────┴───────┴───────┴───────┴────────┘
```

열을 추가할 때, 키워드 인수를 사용하여 쉽게 컬럼명을 지정할 수 있습니다.

```python
print(
    df.with_columns(
        # 컬럼명=식
        score_a=pl.col("age") * pl.col("score"),
        date2=pl.col("date").cast(pl.Date),
    )
)
```

```
shape: (5, 7)
┌─────┬─────┬─────────────────────┬───────┬───────┬─────────┬────────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ score_a ┆ date2      │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---     ┆ ---        │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ f64     ┆ date       │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═════════╪════════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ 40.0    ┆ 2022-01-01 │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ 100.0   ┆ 2022-01-02 │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ 180.0   ┆ 2022-01-03 │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ 280.0   ┆ 2022-01-04 │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ 400.0   ┆ 2022-01-05 │
└─────┴─────┴─────────────────────┴───────┴───────┴─────────┴────────────┘
```

여러 출력이 있는 경우, Config.set_auto_structify(True): 설정을 활성화하여 Struct로 자동 인스턴스화할 수 있습니다.

```python
with pl.Config(auto_structify=True):
    print(
        df.with_columns(
            c=pl.col(["id", "age"]),
        )
    )
```

```
shape: (5, 6)
┌─────┬─────┬─────────────────────┬───────┬───────┬───────────┐
│ id  ┆ age ┆ date                ┆ score ┆ grade ┆ c         │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   ┆ ---       │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   ┆ struct[2] │
╞═════╪═════╪═════════════════════╪═══════╪═══════╪═══════════╡
│ 1   ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     ┆ {1,10}    │
│ 2   ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     ┆ {2,20}    │
│ 3   ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     ┆ {3,30}    │
│ 4   ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     ┆ {4,40}    │
│ 5   ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     ┆ {5,50}    │
└─────┴─────┴─────────────────────┴───────┴───────┴───────────┘
```

:::div{.callout}
with_columns를 사용하면 새로운 데이터 프레임이 반환됩니다. 이때, 메모리 측면에서 기존 데이터 프레임의 새 복사본을 생성하지 않고 기존 데이터프레임에서 열만 새로 추가하여 불필요한 데이터 복사를 피합니다. 이는 메모리 사용을 최소화하고 성능을 향상시키는 데 도움이 됩니다.
Polars의 내부 구조를 보면 불변 데이터 프레임을 사용하며, 새로운 데이터 프레임을 만들 때 기존 데이터를 공유할 수 있는 방식으로 설계되어 있습니다. 따라서 데이터 프레임을 수정하거나 새 열을 추가하더라도, 전체 데이터 프레임을 복사하지 않고 필요한 부분만 처리하여 새로운 데이터 프레임을 생성합니다.

:::

### 5.2.10 replace_column

인덱스 위치에 있는 열 전체를 시리즈 값으로 변경합니다.

```python
s = pl.Series("a", [10, 20, 30, 40, 50])
# df.replace_column("열 인덱스", "대체할 시리즈")
print(df.replace_column(0, s))
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

### 5.2.11 with_row_index

데이터프레임의 첫 번째 열에 행 인덱스를 추가합니다. 인덱스 열의 타입은 정수형입니다.

```python
print(df.with_row_index())
```

```
shape: (5, 6)
┌───────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ index ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---   ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32   ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0     ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1     ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2     ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3     ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4     ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└───────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

인덱스 열의 컬럼명을 설정할 수도 있습니다.

```python
# df.with_row_index("인덱스 열 컬럼명")
print(df.with_row_index("id"))
```

```
shape: (5, 6)
┌─────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ id  ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32 ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0   ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1   ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2   ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3   ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4   ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

offset을 1000으로 설정하면 1000부터 인덱스를 시작합니다. offset은 음수일 수 없습니다.

```python
print(df.with_row_index("id", offset=1000))
```

```
shape: (5, 6)
┌──────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ id   ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---  ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32  ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 1000 ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1001 ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 1002 ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 1003 ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 1004 ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└──────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

int_range() 및 len() 을 사용하여 직접 인덱스를 만들 수도 있습니다.

```python
print(
    df.select(
        pl.int_range(pl.len(), dtype=pl.UInt32).alias("index"),
        pl.all(),
    )
)
```

```
shape: (5, 6)
┌───────┬─────┬─────┬─────────────────────┬───────┬───────┐
│ index ┆ a   ┆ age ┆ date                ┆ score ┆ grade │
│ ---   ┆ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ u32   ┆ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═══════╪═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 0     ┆ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 1     ┆ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 2     ┆ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 3     ┆ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 4     ┆ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└───────┴─────┴─────┴─────────────────────┴───────┴───────┘
```

## 5.3 DataFrame의 Data(데이터)

### 5.3.1 데이터 조회

행, 열을 둘 다 반영한 값을 가져올 수도 있습니다.

```python
print(df[0,'a']) # 행, 열
print(df[0,2])
print(df['a','score'])
```

```
10
2022-01-01 00:00:00
shape: (5, 2)
┌─────┬───────┐
│ a   ┆ score │
│ --- ┆ ---   │
│ i64 ┆ f64   │
╞═════╪═══════╡
│ 10  ┆ 4.0   │
│ 20  ┆ 5.0   │
│ 30  ┆ 6.0   │
│ 40  ┆ 7.0   │
│ 50  ┆ 8.0   │
└─────┴───────┘
```

`df[0, 'a']`는 row(행) 데이터의 인덱스 중 0 번째 행을 선택한다는 의미입니다. 그 행의 값 중 “a” column(컬럼, 열)을 가지는 값만 가지고 올 수 있습니다.

### 5.3.2 item

특정 데이터프레임의 값을 스칼라로 반환하거나 주어진 행/열에 있는 요소를 반환합니다. 행/열이 제공되지 않은 경우, 이는 df[0,0]과 같으며, 모양이 (1,1)인지 확인합니다. 행/열을 사용하면 df[행,열]과 같습니다.

```python
print(df.select((pl.col("score")).sum()).item())
```

```
30.0
```

```python
# df.item(행 인덱스, 열 인덱스)
print(df.item(1, 2))
```

```
2022-01-02 00:00:00
```

```python
# df.item(행 인덱스, 컬럼명)
print(df.item(2, "score"))
```

```
6.0
```

### 5.3.3 데이터 값 변경하기

행, 열 인덱스를 사용하여 해당 위치에 있는 값을 변경할 수 있습니다.

```python
df[1,1] = 3
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

다시 원래대로 돌려놓도록 하겠습니다.

```python
df[1,1] = 20
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

### 5.3.4 clone

데이터프레임을 복사할 때, `df_copy=df` 와 같이 복사하게 되면 같은 메모리 주소를 갖게 됩니다. 아래 코드를 보면 df_copy의 값을 3으로 바꾸었는데 df도 값이 바뀐것을 볼 수 있습니다.

```python
df_copy = df
df_copy[1,1] = 3
print("df",df)
print("df_copy",df_copy)
```

```
df shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
df_copy shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

다시 원래 값으로 변경한 뒤, clone 해 보도록 하겠습니다.

```python
df_copy[1,1] = 20
print(df)
```

```
shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

clone을 하면 데이터프레임의 복사본을 만듭니다. 이때 두 데이터프레임은 다른 메모리 주소를 가지므로 df_copy 값을 바꿔도 df에 적용되지 않는 것을 볼 수 있습니다.

```python
df_copy = df.clone()
df_copy[1,1] = 3
print("df",df)
print("df_copy",df_copy)
```

```
df shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
df_copy shape: (5, 5)
┌─────┬─────┬─────────────────────┬───────┬───────┐
│ a   ┆ age ┆ date                ┆ score ┆ grade │
│ --- ┆ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 3   ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────┴─────────────────────┴───────┴───────┘
```

:::div{.callout}
데이터 분석 시, 원본 데이터는 거의 건들이지 않는 것이 좋습니다. clone()을 이용해서 데이터 프레임 복사 후 분석하시는 것을 추천드립니다.

:::

## 5.4 데이터 생성

```python
%%writefile rawData.csv
사원번호,연차,입사연도,매출,순익
110,1,2015,1000000,100001
109,2,2016,2000000,200001
108,3,2017,3000000,300001
107,4,2018,4000000,400001
106,5,2019,8000000,800001
107,6,2020,16000000,1600001
```

```
Overwriting rawData.csv
```

## 5.5 데이터 읽기

CSV 파일 데이터를 읽어옵니다.

```python
print(pl.read_csv('rawData.csv'))
```

```
shape: (6, 5)
┌──────────┬──────┬──────────┬──────────┬─────────┐
│ 사원번호 ┆ 연차 ┆ 입사연도 ┆ 매출     ┆ 순익    │
│ ---      ┆ ---  ┆ ---      ┆ ---      ┆ ---     │
│ i64      ┆ i64  ┆ i64      ┆ i64      ┆ i64     │
╞══════════╪══════╪══════════╪══════════╪═════════╡
│ 110      ┆ 1    ┆ 2015     ┆ 1000000  ┆ 100001  │
│ 109      ┆ 2    ┆ 2016     ┆ 2000000  ┆ 200001  │
│ 108      ┆ 3    ┆ 2017     ┆ 3000000  ┆ 300001  │
│ 107      ┆ 4    ┆ 2018     ┆ 4000000  ┆ 400001  │
│ 106      ┆ 5    ┆ 2019     ┆ 8000000  ┆ 800001  │
│ 107      ┆ 6    ┆ 2020     ┆ 16000000 ┆ 1600001 │
└──────────┴──────┴──────────┴──────────┴─────────┘
```

# 6. 데이터 삭제

데이터프레임에서 값을 사용하는 방법은 여러 가지가 있습니다.

## 6.1 drop

`drop` 함수는 데이터프레임에서 지정한 열(컬럼)을 삭제할 때 사용하는 함수입니다.

```python
# drop(’컬럼명’)
print(df.drop('a'))
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ age ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

`df.drop('a')`을 이용해 ‘a’ 열을 삭제하였습니다. 만약 원본에 반영하고 싶다면 다시 df 변수에 저장해주어야 합니다. 실습 진행을 위해 실행시키지 않도록 하겠습니다.

```python
# df = df.drop('a')
# print(df)
```

여러 컬럼명을 연달아 작성하여 전달하거나 리스트 형태로 전달하여 여러개의 컬럼을 삭제할 수 있습니다.

```python
print(df.drop('a','score'))
# print(df.drop(['a','score']))
```

```
shape: (5, 3)
┌─────┬─────────────────────┬───────┐
│ age ┆ date                ┆ grade │
│ --- ┆ ---                 ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ str   │
╞═════╪═════════════════════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ e     │
└─────┴─────────────────────┴───────┘
```

polars 셀렉터를 사용하여 여러개의 숫자형 컬럼만 삭제할 수 있습니다.

```python
import polars.selectors as cs

print(df.drop(cs.numeric()))
```

```
shape: (5, 2)
┌─────────────────────┬───────┐
│ date                ┆ grade │
│ ---                 ┆ ---   │
│ datetime[μs]        ┆ str   │
╞═════════════════════╪═══════╡
│ 2022-01-01 00:00:00 ┆ a     │
│ 2022-01-02 00:00:00 ┆ b     │
│ 2022-01-03 00:00:00 ┆ c     │
│ 2022-01-04 00:00:00 ┆ b     │
│ 2022-01-05 00:00:00 ┆ e     │
└─────────────────────┴───────┘
```

## 6.2 drop_in_place

단일 열을 drop 후 원본에 반영한 뒤, 삭제된 열을 반환합니다.

```python
print(df.drop_in_place('a'))
```

```
shape: (5,)
Series: 'a' [i64]
[
	10
	20
	30
	40
	50
]
```

```python
print(df)
```

```
shape: (5, 4)
┌─────┬─────────────────────┬───────┬───────┐
│ age ┆ date                ┆ score ┆ grade │
│ --- ┆ ---                 ┆ ---   ┆ ---   │
│ i64 ┆ datetime[μs]        ┆ f64   ┆ str   │
╞═════╪═════════════════════╪═══════╪═══════╡
│ 10  ┆ 2022-01-01 00:00:00 ┆ 4.0   ┆ a     │
│ 20  ┆ 2022-01-02 00:00:00 ┆ 5.0   ┆ b     │
│ 30  ┆ 2022-01-03 00:00:00 ┆ 6.0   ┆ c     │
│ 40  ┆ 2022-01-04 00:00:00 ┆ 7.0   ┆ b     │
│ 50  ┆ 2022-01-05 00:00:00 ┆ 8.0   ┆ e     │
└─────┴─────────────────────┴───────┴───────┘
```

## 6.3 clear

동일한 컬럼명을 가진 데이터가 없거나(n=0) n행이 null로 채워진(n>0) 현재 데이터 프레임의 빈 복사본을 만듭니다.

```python
print(df2)
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1.0  ┆ 3    │
│ 2.0  ┆ 4    │
└──────┴──────┘
```

```python
print(df2.clear())
```

```
shape: (0, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
└──────┴──────┘
```

n은 지워진 데이터프레임에서 null로 채워진 행의 수로 데이터프레임의 현재 행 수보다 클 수 있습니다.

```python
print(df2.clear(n=2))
```

```
shape: (2, 2)
┌──────┬──────┐
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ null ┆ null │
│ null ┆ null │
└──────┴──────┘
```

# 7. 결측치 처리

## 7.1 결측값 추가

null 값을 추가하는 방법에 대해 알아보도록 하겠습니다.

```python
df_null = pl.DataFrame({
    '이름': ['A', 'B', None],
    '나이': [25, 35, None],
    '성별': ['남', '여', '남'],
    '학점': [4.5, 4.0, None],
    '주소': [None, 'jeju', None],
})

print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
│ null ┆ null ┆ 남   ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

데이터 값 추가했던 것과 같이 None 값을 넣어줍니다.

```python
df_null[2,'성별'] = None
print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
│ null ┆ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

이번에는 NaN 값을 추가하는 방법에 대해 알아보도록 하겠습니다.

```python
df_nan = pl.DataFrame({
    '이름': ['A', 'B', 'C'],
    '나이': [25, 35, 40],
    '성별': ['남', '여', '남'],
    '학점': [4.5, 4.0, np.nan],
    '주소': ['seoul', 'jeju', 'busan'],
})

print(df_nan)
```

- np.nan: NaN으로 값을 채움

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40   ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

아래와 같이 값을 NaN으로 변경할 경우 NaN값이 아닌, null 값이 들어가게 됩니다. 이는 NaN이 실수형이기 때문에 타입이 맞지 않아 null 값으로 들어가게 됩니다.

```python
df_nan[1,1] = np.nan
print(df_nan)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ null ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40   ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

NaN 값을 추가할 때는 먼저 실수형으로 자료형을 변경한 뒤, NaN값으로 변경해주셔야 합니다.

```python
df_nan = df_nan.cast({'나이':pl.Float32})
df_nan[1,1] = np.nan
print(df_nan)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ f32  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25.0 ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ NaN  ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40.0 ┆ 남   ┆ NaN  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

## 7.2 결측치 확인

`null_count`는 데이터에 열별로 null 값의 개수가 몇개 있는지 확인할 수 있습니다.

```python
print(df_null.null_count()) # 결측값 개수 확인
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ u32  ┆ u32  ┆ u32  ┆ u32  ┆ u32  │
╞══════╪══════╪══════╪══════╪══════╡
│ 1    ┆ 1    ┆ 1    ┆ 1    ┆ 2    │
└──────┴──────┴──────┴──────┴──────┘
```

## 7.3 결측치 처리

### 7.3.1 결측치 삭제(drop_nulls)

`drop_nulls` 함수는 데이터프레임에서 결측값(null)을 포함한 행을 삭제할 때 사용하는 함수입니다.

```python
print(df_null.drop_nulls())
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

subset 매개변수를 사용하여 polars 셀렉터로 데이터 타입이 문자열인 열이고 null이 있는 경우 행을 삭제할 수 있습니다. 없음(기본값)으로 설정하면 모든 열에 있는 결측값을 확인하고 해당 행을 삭제합니다.

```python
print(df_null.drop_nulls(subset=cs.string()))
```

```
shape: (1, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

모든 행이 null인 경우, 해당 행을 삭제합니다.

```python
print(df_null.filter(~pl.all_horizontal(pl.all().is_null())))
```

```
shape: (2, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ jeju │
└──────┴──────┴──────┴──────┴──────┘
```

모든 열이 null인 경우, 해당 열을 삭제합니다.

```python
df_null[1,'주소'] = None
print(df_null)
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ null │
│ null ┆ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

```python
print(df_null[[s.name for s in df_null if not (s.null_count() == df_null.height)]])
```

```
shape: (3, 4)
┌──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 │
│ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  │
╞══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  │
│ B    ┆ 35   ┆ 여   ┆ 4.0  │
│ null ┆ null ┆ null ┆ null │
└──────┴──────┴──────┴──────┘
```

### 7.3.2 결측치 채우기(fill_null, fill_nan)

fill_null을 사용하여 지정된 값이나 어떤 값을 채울지 전략을 세워 null 값을 채울 수 있습니다.

- value : null 값 대신 채울 값
- strategy : null 값을 채우는 데 사용되는 전략
  - None(기본값), forward, backward, min, max, mean, 0, 1
- limit : strategy에서 'forward' 또는 'backward'를 사용할 때 연속으로 채울 null 값의 개수
- matches_supertype : 채울 값의 타입이 다를 경우, 채울 값의 타입과 일치하도록 열의 타입을 채울 값의 타입으로 변경합니다. 기본값은 True이며, False로 설정할 경우 타입이 맞는 열에만 값이 채워지며, 타입이 맞지 않은 열은 null을 출력하게 됩니다.

```python
print(df_null.fill_null(99))
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬──────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소 │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str  ┆ i64  ┆ str  ┆ f64  ┆ str  │
╞══════╪══════╪══════╪══════╪══════╡
│ A    ┆ 25   ┆ 남   ┆ 4.5  ┆ null │
│ B    ┆ 35   ┆ 여   ┆ 4.0  ┆ null │
│ null ┆ 99   ┆ null ┆ 99.0 ┆ null │
└──────┴──────┴──────┴──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="max"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.5  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="zero"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 0    ┆ 0.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="forward"))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(strategy="forward", limit=1))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ 35   ┆ 4.0  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(9.9, matches_supertype=True))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ f64  ┆ f64  │
╞══════╪══════╡
│ 25.0 ┆ 4.5  │
│ 35.0 ┆ 4.0  │
│ 9.9  ┆ 9.9  │
└──────┴──────┘
```

```python
print(df_null['나이','학점'].fill_null(9.9, matches_supertype=False))
```

```
shape: (3, 2)
┌──────┬──────┐
│ 나이 ┆ 학점 │
│ ---  ┆ ---  │
│ i64  ┆ f64  │
╞══════╪══════╡
│ 25   ┆ 4.5  │
│ 35   ┆ 4.0  │
│ null ┆ 9.9  │
└──────┴──────┘
```

fill_nan을 사용하여 부동 소수점 NaN 값을 다른 값으로 채울 수 있습니다.

```python
print(df_nan.fill_nan(3.5))
```

```
shape: (3, 5)
┌──────┬──────┬──────┬──────┬───────┐
│ 이름 ┆ 나이 ┆ 성별 ┆ 학점 ┆ 주소  │
│ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---   │
│ str  ┆ f32  ┆ str  ┆ f64  ┆ str   │
╞══════╪══════╪══════╪══════╪═══════╡
│ A    ┆ 25.0 ┆ 남   ┆ 4.5  ┆ seoul │
│ B    ┆ 3.5  ┆ 여   ┆ 4.0  ┆ jeju  │
│ C    ┆ 40.0 ┆ 남   ┆ 3.5  ┆ busan │
└──────┴──────┴──────┴──────┴───────┘
```

:::div{.callout}
부동소수점 NaN(숫자 아님)은 누락된 값이 아니라는 점에 유의하셔야 합니다. 누락된 값을 대체하려면 fill_null()을 사용합니다.

:::

# 8. 데이터 필터

### filter

하나 이상의 조건을 기준으로 데이터프레임의 행을 필터링합니다. 필터링 결과는 논리형(True, Fasle) 시리즈로 True로 반환된 행은 행의 순서는 기존 데이터프레임과 같은 순서대로 유지되며, False로 반환된 행은 null을 포함하여 삭제됩니다.

```python
df = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6, 7, 8],
        "ham": ["a", "b", "c"],
    }
)
```

```python
# df.filter(필터링 할 조건)
print(df.filter(pl.col("foo") > 1))
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ b   │
│ 3   ┆ 8   ┆ c   │
└─────┴─────┴─────┘
```

조건을 여러개 두고 싶은 경우, `&(and, 그리고) 연산자`, `|(or, 또는) 연산자`와 결합하여 필터링 할 수 있습니다.

```python
df.filter((pl.col("foo") < 3) & (pl.col("ham") == "a"))
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘
```

```python
df.filter((pl.col("foo") == 1) | (pl.col("ham") == "c"))
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
│ 3   ┆ 8   ┆ c   │
└─────┴─────┴─────┘
```

쉼표(,)로 연결하여 & 연산자와 같이 여러 조건을 모두 만족하는 행을 출력할 수 있습니다.

```python
df.filter(
    pl.col("foo") <= 2,
    ~pl.col("ham").is_in(["b", "c"]),
)
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘
```

`컬럼명 = 값`으로 열을 필터링할 수 있습니다. pl.col(name).eq(value)와 동일하게 작동합니다.

```python
df.filter(foo=2, ham="b")
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ b   │
└─────┴─────┴─────┘
```

### is_duplicated

데이터 프레임에서 중복된 모든 행의 bool 값을 가져옵니다.

```python
df = pl.DataFrame(
    {
        "a": [1, 2, 3, 1],
        "b": ["x", "y", "z", "x"],
        "c": ["b", "b", "b", "b"],
    }
)

print(df)
```

```python
shape: (4, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
df.is_duplicated()
shape: (4,)
Series: '' [bool]
[
        true
        false
        false
        true
]
```

이 마스크를 사용하면 다음과 같이 중복된 선을 시각화할 수 있습니다.

```python
df.filter(df.is_duplicated())
shape: (2, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 1   ┆ x   │
│ 1   ┆ x   │
└─────┴─────┘
```

### is_unique

데이터프레임의 모든 고유한 행을 가지고 있는지 확인합니다.

```python
print(df.is_unique())
```

```python
shape: (4,)
Series: '' [bool]
[
	false
	true
	true
	false
]
```

고유값을 가진 행만 출력할 수 있습니다.

```python
print(df.filter(df.is_unique()))
```

```python
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

### unique

데이터프레임에서 중복된 행을 삭제합니다. 만약, 데이터프레임 또는 하위 집합에 List 유형의 열이 있는 경우 이 메서드는 실패합니다.

```python
print(df.unique())
```

```python
shape: (3, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
│ 2   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

- subset : 중복 행을 식별할 때 고려할 열 이름 또는 선택기입니다. 없음(기본값)으로 설정하면 모든 열을 사용합니다.
- keep : {'first', 'last', 'any', 'none'} 중복 행 중 유지할 행.
  'any': 어떤 행이 유지되는지 보장하지 않습니다. 더 많은 최적화가 가능합니다. 'none': 중복 행을 유지하지 않습니다. 'first': 첫 번째 고유 행을 유지합니다. 'last': 마지막 고유 행을 유지합니다.
- **maintain_order** : 원래 데이터프레임과 동일한 순서를 유지합니다. 이 경우 계산 비용이 더 많이 듭니다. True로 설정하면 스트리밍 엔진에서 실행할 가능성이 차단됩니다.

```python
print(df.unique(subset=["b", "c"]))
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
print(df.unique(keep="last"))
```

```python
shape: (3, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ a   ┆ b   │
│ 1   ┆ a   ┆ b   │
│ 3   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

```python
print(df.unique(subset=["b", "c"], maintain_order=True))
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ b   │
└─────┴─────┴─────┘
```

<aside>
👉 pandas의 drop_duplicates와 유사합니다.

</aside>

속성값 중에서 유일한 값 출력

```
print(df["a"].unique())
```

```
shape: (3,)
Series: 'a' [i64]
[
	1
	2
	3
]
```

### n_unique

고유한 행의 수 또는 고유한 행 부분 집합의 수를 반환합니다.

```python
df = pl.DataFrame(
    {
        "a": [1, 1, 2, 3, 4, 5],
        "b": [0.5, 0.5, 1.0, 2.0, 3.0, 3.0],
        "c": [True, True, True, False, True, True],
    }
)
print(df)
```

```python
shape: (6, 3)
┌─────┬─────┬───────┐
│ a   ┆ b   ┆ c     │
│ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ bool  │
╞═════╪═════╪═══════╡
│ 1   ┆ 0.5 ┆ true  │
│ 1   ┆ 0.5 ┆ true  │
│ 2   ┆ 1.0 ┆ true  │
│ 3   ┆ 2.0 ┆ false │
│ 4   ┆ 3.0 ┆ true  │
│ 5   ┆ 3.0 ┆ true  │
└─────┴─────┴───────┘
```

```python
print(df.n_unique())
```

```python
5
```

속성 값에 대한 빈도수 출력

```python
print(df['a'].n_unique())
```

```python
3
```

```python
# 단순 열
print(df.n_unique(subset=["b", "c"]))
```

```python
4
```

```python
# 표현식
df.n_unique(subset=[(pl.col("a") // 2),
                    (pl.col("c") | (pl.col("b") >= 2)),
                   ],
)
```

```python
3
```

- subset : 계산할 대상을 정의하는 하나 이상의 열/표현식

데이터 프레임 수준에서 작동하며, 표현식 수준에서 하위 집합에 대해 작업하려면 다음과 같이 구조 패킹을 대신 사용할 수 있습니다.

```python
expr_unique_subset = pl.struct("a", "b").n_unique()
```

대신 열별 고유 값의 수를 계산하려는 경우 표현식 수준 구문을 사용하여 해당 결과가 포함된 새 프레임을 반환할 수도 있습니다.

```python
df = pl.DataFrame(
    [[1, 2, 3], [1, 2, 4]], schema=["a", "b", "c"], orient="row"
)
df_nunique = df.select(pl.all().n_unique())
print(df_nunique)
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ u32 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 2   │
└─────┴─────┴─────┘
```

집계 컨텍스트에서 그룹별 고유 값을 반환하는 동등한 방법도 있습니다.

```python
df_agg_nunique = df.group_by("a").n_unique()
print(df_agg_nunique)
```

```python
shape: (1, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 2   │
└─────┴─────┴─────┘
```

### is_empty

데이터 프레임에 행이 없는 경우 True를 반환합니다.

```python
df.is_empty()
```

```python
df.filter(pl.col("id") > 99).is_empty()
```

# 9. 데이터 정렬

## sort

지정된 컬럼명을 기준으로 데이터 프레임을 정렬합니다. 문자열로 입력할 경우 컬럼을 기준으로 정렬합니다.

```
import polars as pl

df = pl.DataFrame(
    {
        "a": [1, 2, None],
        "b": [6.0, 5.0, 4.0],
        "c": ["a", "c", "b"],
    }
)

# df.sort("컬럼명")
print(df.sort("a"))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ null ┆ 4.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

계산식을 기준으로도 정렬할 수 있습니다.

```
# df.sort("계산식")
print(df.sort(pl.col("a") + pl.col("b") * 2, nulls_last=True))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
└──────┴─────┴─────┘
```

- nulls_last : 정렬할 때 null 값을 마지막에 오도록 지정할 수 있습니다.
  - `nulls_last=True` : 모든 열에 적용되는 단일 부울 값 지정
  - `nulls_last=[True, False, True]` : 각 열에 대해 개별적으로 제어를 위해 부울 리스트 지정

이처럼 a, c 열만 nulls_last를 적용할 수 있습니다.

```
print(df.sort([pl.col("a"), pl.col("b"), pl.col("c")], nulls_last=[True, False, True]))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
└──────┴─────┴─────┘
```

리스트로 여러 컬럼명을 기준으로 정렬합니다.

```
print(df.sort(["c", "a"], descending=True))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ c   │
│ null ┆ 4.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
└──────┴─────┴─────┘
```

- descending : 내림차순으로 정렬합니다.

descending는 nulls_last과 마찬가지로 여러 열을 기준으로 정렬하는 경우 부울 리스트 전달하여 열별로 지정할 수 있습니다.

```
print(df.sort(["c", "a"], descending=[False, True]))
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

또한 쉼표로 컬럼명을 입력하여 같은 방식으로 여러 열을 기준으로 정렬합니다.

```
df.sort("c", "a", descending=[False, True])
```

```
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 1    ┆ 6.0 ┆ a   │
│ null ┆ 4.0 ┆ b   │
│ 2    ┆ 5.0 ┆ c   │
└──────┴─────┴─────┘
```

요소가 동일한 경우 순서를 유지하고 싶다면 maintain_order=True 를 합니다.

```python
import polars as pl

df = pl.DataFrame(
    {
        "a": [1, 2, None],
        "b": [6.0, 5.0, 5.0],
        "c": ["a", "b", "b"],
    }
)

print(df.sort("c", descending=True, maintain_order=True))
```

```python
shape: (3, 3)
┌──────┬─────┬─────┐
│ a    ┆ b   ┆ c   │
│ ---  ┆ --- ┆ --- │
│ i64  ┆ f64 ┆ str │
╞══════╪═════╪═════╡
│ 2    ┆ 5.0 ┆ b   │
│ null ┆ 5.0 ┆ b   │
│ 1    ┆ 6.0 ┆ a   │
└──────┴─────┴─────┘
```

multithreaded=True(기본값)인 경우 데이터 정렬 시 여러 스레드를 사용하여 병렬 처리하여 성능을 최적화 할 수 있습니다.

```python
print(df.sort("c", descending=True, multithreaded=True))
```

<aside>
💡 **`multithreaded` 옵션은 언제 사용하는가?**

- 데이터셋이 매우 클 때
- 멀티코어 프로세서를 가지고 있을 때
- 데이터 정렬 작업이 시간이 많이 걸리는 경우 병렬 처리 혜택을 원할 때

작은 데이터 셋이나 디버깅을 쉽게 하고 싶은 경우에는 멀티 스레드를 사용하면 스레드를 생성하고 관리하는 오버헤드가 실제 정렬 시간보다 더 오래 걸릴 수 있습니다. 이럴 때는 단일 스레드를 사용하는 것이 더 효율적일 수 있습니다.

</aside>

## reverse

DataFrame을 반대로 뒤집습니다.

```python
df = pl.DataFrame(
    {
        "key": ["a", "b", "c"],
        "val": [1, 2, 3],
    }
)
df.reverse()
```

```python
shape: (3, 2)
┌─────┬─────┐
│ key ┆ val │
│ --- ┆ --- │
│ str ┆ i64 │
╞═════╪═════╡
│ c   ┆ 3   │
│ b   ┆ 2   │
│ a   ┆ 1   │
└─────┴─────┘
```

# 10. 문자열 처리 방법

```python
weather = pl.DataFrame(
    {
        "station": ["Station " + str(x) for x in range(1, 6)],
        "temperatures": [
            "20 5 5 E1 7 13 19 9 6 20",
            "18 8 16 11 23 E2 8 E2 E2 E2 90 70 40",
            "19 24 E9 16 6 12 10 22",
            "E2 E0 15 7 8 10 E1 24 17 13 6",
            "14 8 E0 16 22 24 E1",
        ],
    }
)
print(weather)
```

```python
weather['temperatures'].dtype
```

```python
out = weather.with_columns(
    pl.col("temperatures")
)
print(out)
```

```python
# df.columns.str.replace('바꿀값', '바꿀 문자열')
weather.with_columns(
    pl.col("temperatures").str.replace("E","W")
)
```

```python
# df.columns.str.replace('바꿀값', '바꿀 문자열')
weather.with_columns(
    weather['temperatures'].str.replace("E","W")
)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
    ).explode(
        "temperatures"
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures").str.split(" ")
    ).with_columns(
        pl.col("temperatures").list.head(3).alias("top3"),
        pl.col("temperatures").list.slice(-3, 3).alias("bottom_3"),
        pl.col("temperatures").list.len().alias("obs"),
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
    .list.sum()
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().cast(pl.Int64, strict=False).is_null())
    .list.sum()
    .alias("errors")
)
print(out)
```

```python
out = weather.with_columns(
    pl.col("temperatures")
    .str.split(" ")
    .list.eval(pl.element().str.contains("(?i)[a-z]"))
    .list.sum()
    .alias("errors")
)
print(out)
```

```python
weather_by_day = pl.DataFrame(
    {
        "station": ["Station " + str(x) for x in range(1, 11)],
        "day_1": [17, 11, 8, 22, 9, 21, 20, 8, 8, 17],
        "day_2": [15, 11, 10, 8, 7, 14, 18, 21, 15, 13],
        "day_3": [16, 15, 24, 24, 8, 23, 19, 23, 16, 10],
    }
)
print(weather_by_day)
```

```python
rank_pct = (pl.element().rank(descending=True) / pl.col("*").count()).round(2)

out = weather_by_day.with_columns(
    # create the list of homogeneous data
    pl.concat_list(pl.all().exclude("station")).alias("all_temps")
).select(
    # select all columns except the intermediate list
    pl.all().exclude("all_temps"),
    # compute the rank by calling `list.eval`
    pl.col("all_temps").list.eval(rank_pct, parallel=True).alias("temps_rank"),
)

print(out)
```

```python
array_df = pl.DataFrame(
    [
        pl.Series("Array_1", [[1, 3], [2, 5]]),
        pl.Series("Array_2", [[1, 7, 3], [8, 1, 0]]),
    ],
    schema={
        "Array_1": pl.Array(pl.Int64, 2),
        "Array_2": pl.Array(pl.Int64, 3),
    },
)
print(array_df)
```
