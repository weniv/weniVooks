---
chapter: 데이터 구조
title: DataFrame(데이터프레임) 심화
date: 2024-12-11
---

# 1. 데이터 결합 및 분해

## 1.1 데이터 결합

### 1.1.1 equals

equals 메서드는 데이터프레임이 다른 데이터프레임과 같은지 비교할 수 있습니다.

```python
df1 = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6.0, 7.0, 8.0],
        "ham": ["a", "b", "c"],
    }
)
df2 = pl.DataFrame(
    {
        "foo": [3, 2, 1],
        "bar": [8.0, 7.0, 6.0],
        "ham": ["c", "b", "a"],
    }
)

# 데이터프레임1.equals(데이터프레임2)
print(df1.equals(df1))
print(df1.equals(df2))
```

```
True
False
```

null_equal 매개변수를 True(기본값)으로 설정하면 데이터프레임에 널 값이 있는 경우 동등한 데이터프레임 값으로 간주합니다.

```python
print(df1.equals(df1, null_equal=True))
print(df1.equals(df1, null_equal=False))
```

```
True
False
```

특정 컬럼의 값이 동일한지도 확인할 수 있습니다.

```python
df2 = pl.DataFrame(
    {
        "foo": [3, 2, 1],
        "bar": [6.0, 7.0, 8.0],
        "ham": ["c", "b", "a"],
    }
)

print(df1['bar'].equals(df2['bar']))
```

```
True
```

### 1.1.2 hstack

여러 개의 Series를 수평으로 쌓아 확장된 새로운 DataFrame을 반환합니다. in_place 매개변수를 True로 설정하시면 바로 원본에 반영됩니다.

```python
x = pl.Series("apple", [10, 20, 30])
print(df1.hstack([x]))
```

```
shape: (3, 4)
┌─────┬─────┬─────┬───────┐
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ str ┆ i64   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6.0 ┆ a   ┆ 10    │
│ 2   ┆ 7.0 ┆ b   ┆ 20    │
│ 3   ┆ 8.0 ┆ c   ┆ 30    │
└─────┴─────┴─────┴───────┘
```

### 1.1.3 vstack

데이터프레임에 데이터를 수직으로 쌓아서 데이터프레임을 늘립니다. in_place 매개변수를 True로 설정하시면 바로 원본에 반영됩니다.

```python
df2 = pl.DataFrame(
    {
        "foo": [3, 4],
        "bar": [8.0, 9.0],
        "ham": ["c", "d"],
    }
)
print(df1.vstack(df2))
```

```
shape: (5, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6.0 ┆ a   │
│ 2   ┆ 7.0 ┆ b   │
│ 3   ┆ 8.0 ┆ c   │
│ 3   ┆ 8.0 ┆ c   │
│ 4   ┆ 9.0 ┆ d   │
└─────┴─────┴─────┘
```

### 1.1.4 extend

extend 메서드는 데이터프레임이 지원하는 메모리를 다른 데이터프레임의 값으로 세로로 확장합니다.

```python
df1 = pl.DataFrame({"foo": [1, 2, 3], "bar": [4, 5, 6]})
df2 = pl.DataFrame({"foo": [10, 20, 30], "bar": [40, 50, 60]})
print(df1.extend(df2))
```

```python
shape: (6, 2)
┌─────┬─────┐
│ foo ┆ bar │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 4   │
│ 2   ┆ 5   │
│ 3   ┆ 6   │
│ 10  ┆ 40  │
│ 20  ┆ 50  │
│ 30  ┆ 60  │
└─────┴─────┘
```

:::div{.callout}
다른 데이터프레임의 청크를 기존 데이터프레임의 청크에 추가하는 vstack과 달리, 확장에서는 다른 데이터의 데이터를 기본 메모리 위치에 추가하므로 재할당이 발생할 수 있습니다. 재할당이 발생하지 않으면 결과 데이터 구조에 추가 청크가 없으므로 쿼리가 더 빠릅니다. 한 번 추가한 후 쿼리를 수행하려는 경우 vstack보다 확장하는 것을 선호합니다.

예를 들어, n개의 행을 추가하고 쿼리를 다시 실행하는 온라인 작업 중입니다. 쿼리를 수행하기 전에 여러 번 추가하려는 경우 확장보다 vstack을 선호합니다.

예를 들어, 여러 파일을 읽어서 단일 데이터 프레임에 저장하려는 경우입니다. 후자의 경우, 리청크를 통해 일련의 vstack 작업을 완료하세요.

:::

### 1.1.5 update

update는 두 데이터프레임에 같은 컬럼명이 있는 경우 해당 열의 데이터프레임의 값을 다른 데이터프레임의 값으로 업데이트합니다.

df의 B열을 new_df의 B열로 업데이트 합니다. 만약, 값이 없거나 null 값인 경우 df 값을 유지합니다.

```python
df = pl.DataFrame(
    {
        "A": [1, 2, 3, 4],
        "B": [400, 500, 600, 700],
    }
)

new_df = pl.DataFrame(
    {
        "B": [-66, None, -99],
        "C": [5, 3, 1],
    }
)

# df.update(새로운데이터프레임)
print(df.update(new_df))
```

```
shape: (4, 2)
┌─────┬─────┐
│ A   ┆ B   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ -66 │
│ 2   ┆ 500 │
│ 3   ┆ -99 │
│ 4   ┆ 700 │
└─────┴─────┘
```

how 파라미터는 어떤 방식으로 데이터프레임을 업데이트할지 조인 방식을 지정합니다.

```python
# df.update(new_df, how="조인 종류")
print(df.update(new_df, how="inner"))
```

```
shape: (3, 2)
┌─────┬─────┐
│ A   ┆ B   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ -66 │
│ 2   ┆ 500 │
│ 3   ┆ -99 │
└─────┴─────┘
```

- how=‘left’ : 왼쪽 테이블의 모든 행을 유지하며, 오른쪽 프레임의 매칭되는 값만 업데이트하고 나머지는 원래 값을 유지합니다. 만약, 여러번 매칭되면 행이 중복될 수 있습니다.
- how=‘inner’ : 두 데이터프레임에서 공통으로 존재하는 값, null이 아닌 매칭되는 값만 결과에 포함됩니다.
- how=‘full’ : 왼쪽 테이블의 모든 행을 유지하며, 오른쪽 프레임의 매칭되는 값만 업데이트하고 새로운 데이터프레임에만 있는 행도 추가합니다.

각 데이터프레임에서 명시적으로 조인할 열을 설정하여 값을 업데이트합니다.

```python
# df.update(새로운데이터프레임, on=["컬럼명"], how="조인 종류")
print(df.update(new_df, on=["B"], how="full"))
```

- on : 조인할 컬럼명, 두 데이터프레임에 해당 컬럼명이 존재해야 합니다. 없음(기본값)으로 설정하면 각 데이터프레임의 암묵적인 행 인덱스가 조인 키로 사용됩니다.

```
shape: (7, 2)
┌──────┬──────┐
│ A    ┆ B    │
│ ---  ┆ ---  │
│ i64  ┆ i64  │
╞══════╪══════╡
│ 1    ┆ 400  │
│ 2    ┆ 500  │
│ 3    ┆ 600  │
│ 4    ┆ 700  │
│ null ┆ null │
│ null ┆ -66  │
│ null ┆ -99  │
└──────┴──────┘
```

왼쪽 데이터프레임의 A 열의 값과 오른쪽 데이터프레임의 C 열의 값이 같은 행을 찾아 해당 행의 B 값을 업데이트합니다.

```python
# df.update(새로운데이터프레임, left_on=["기존 데이터프레임 컬럼명"], right_on=["새로운 데이터프레임 컬럼명"], how="조인 종류")
print(df.update(new_df, left_on=["A"], right_on=["C"], how="full"))
```

- left_on : 왼쪽 데이터프레임의 열을 기준으로 조인합니다.
- right_on : 오른쪽 데이터프레임의 열을 기준으로 조인합니다.

```
shape: (5, 2)
┌─────┬─────┐
│ A   ┆ B   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ -99 │
│ 2   ┆ 500 │
│ 3   ┆ 600 │
│ 4   ┆ 700 │
│ 5   ┆ -66 │
└─────┴─────┘
```

include_nulls 매개변수는 left/inner 조인을 위한 매개변수로 True로 설정하면 null 값을 포함하여 값 업데이트합니다. 이때, 왼쪽 데이터프레임의 값을 오른쪽 데이터프레임의 null 값으로 덮어씁니다. False(기본값)로 설정하면 오른쪽 프레임의 null 값은 무시됩니다.

```python
print(df.update(new_df, left_on="A", right_on="C", how="full", include_nulls=True))
```

```
shape: (5, 2)
┌─────┬──────┐
│ A   ┆ B    │
│ --- ┆ ---  │
│ i64 ┆ i64  │
╞═════╪══════╡
│ 1   ┆ -99  │
│ 2   ┆ 500  │
│ 3   ┆ null │
│ 4   ┆ 700  │
│ 5   ┆ -66  │
└─────┴──────┘
```

### 1.1.6 join

join 메서드는 두 데이터프레임을 특정 컬럼 기준으로 조인합니다.

```python
df = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6.0, 7.0, 8.0],
        "ham": ["a", "b", "c"],
    }
)
other_df = pl.DataFrame(
    {
        "apple": ["x", "y", "z"],
        "ham": ["a", "b", "d"],
    }
)

# df.join(새로운 데이터프레임, on="컬럼명")
print(df.join(other_df, on="ham"))
```

```
shape: (2, 4)
┌─────┬─────┬─────┬───────┐
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ str ┆ str   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6.0 ┆ a   ┆ x     │
│ 2   ┆ 7.0 ┆ b   ┆ y     │
└─────┴─────┴─────┴───────┘
```

만약 조인할 열의 이름이 다를 경우 on이 아닌 left_on, right_on을 사용하셔야 합니다.

```python
df2 = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6.0, 7.0, 8.0],
        "ham1": ["a", "b", "c"],
    }
)
other_df2 = pl.DataFrame(
    {
        "apple": ["x", "y", "z"],
        "ham2": ["a", "b", "d"],
    }
)

# df.join(새로운 데이터프레임, left_on="왼쪽 데이터프레임의 컬럼명", right_on="오른쪽 데이터프레임의 컬럼명")
print(df2.join(other_df2, left_on="ham1", right_on="ham2"))
```

```
shape: (2, 4)
┌─────┬─────┬──────┬───────┐
│ foo ┆ bar ┆ ham1 ┆ apple │
│ --- ┆ --- ┆ ---  ┆ ---   │
│ i64 ┆ f64 ┆ str  ┆ str   │
╞═════╪═════╪══════╪═══════╡
│ 1   ┆ 6.0 ┆ a    ┆ x     │
│ 2   ┆ 7.0 ┆ b    ┆ y     │
└─────┴─────┴──────┴───────┘
```

두 데이터프레임을 어떻게 조인할지 조인 방법을 정할 수 있습니다.

```python
# df.join(other_df, on="컬럼명", how="조인방법")
print(df.join(other_df, on="ham", how="full"))
```

- inner : 두 데이터프레임에 일치하는 값이 있는 행을 반환합니다.
- left : 왼쪽 데이터프레임의 모든 행과 오른쪽 데이터프레임의 일치하는 행을 반환합니다. 출력 결과는 왼쪽 데이터프레임의 행 순서를 유지합니다.
- full : 왼쪽 또는 오른쪽 데이터프레임에 일치하는 항목이 있을 때 모든 행을 반환합니다.
- cross : 두 데이터프레임의 행의 데카르트 곱을 반환합니다.
- semi : 왼쪽 데이터프레임에서 오른쪽 데이터프레임에 일치하는 행이 있는 행을 반환합니다.
- anti : 왼쪽 데이터프레임에서 오른쪽 데이터프레임에 일치하는 항목이 없는 행을 반환합니다.

```python
shape: (4, 5)
┌──────┬──────┬──────┬───────┬───────────┐
│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_right │
│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---       │
│ i64  ┆ f64  ┆ str  ┆ str   ┆ str       │
╞══════╪══════╪══════╪═══════╪═══════════╡
│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a         │
│ 2    ┆ 7.0  ┆ b    ┆ y     ┆ b         │
│ null ┆ null ┆ null ┆ z     ┆ d         │
│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null      │
└──────┴──────┴──────┴───────┴───────────┘
```

```python
print(df.join(other_df, on="ham", how="semi"))
```

```
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6.0 ┆ a   │
│ 2   ┆ 7.0 ┆ b   │
└─────┴─────┴─────┘
```

```python
print(df.join(other_df, on="ham", how="anti"))
```

```
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 3   ┆ 8.0 ┆ c   │
└─────┴─────┴─────┘
```

full, cross 조인 결과를 보면 컬럼명\_result 라고 새로운 컬럼이 만들어진 것을 볼 수 있습니다. 만약, 컬럼명\_result이 아닌 다른 접미사를 추가하고 싶다면 suffix를 이용하시면 됩니다.

```python
print(df.join(other_df, on="ham", how="full", suffix="_new"))
```

```python
shape: (4, 5)
┌──────┬──────┬──────┬───────┬─────────┐
│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_new │
│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---     │
│ i64  ┆ f64  ┆ str  ┆ str   ┆ str     │
╞══════╪══════╪══════╪═══════╪═════════╡
│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a       │
│ 2    ┆ 7.0  ┆ b    ┆ y     ┆ b       │
│ null ┆ null ┆ null ┆ z     ┆ d       │
│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null    │
└──────┴──────┴──────┴───────┴─────────┘
```

coalesce 매개변수를 True로 설정하시면 조인 열을 병합합니다. 만약, 계산식에 의해 조인한다면 병합이 해제됩니다. False(기본값, None)로 설정할 경우 조인 열을 병합하지 않습니다.

```python
print(df.join(other_df, on="ham", how="left", coalesce=True))
```

```python
shape: (3, 4)
┌─────┬─────┬─────┬───────┐
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ str ┆ str   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6.0 ┆ a   ┆ x     │
│ 2   ┆ 7.0 ┆ b   ┆ y     │
│ 3   ┆ 8.0 ┆ c   ┆ null  │
└─────┴─────┴─────┴───────┘
```

:::div{.callout}
범주형 데이터가 있는 열에 대한 조인은 `polars.StringCache`를 참고하시길 바랍니다.

:::

join_nulls 매개변수를 True로 설정하시면 null 값끼리 조인을 허용합니다. False(기본값)은 null 값끼리 조인을 생성하지 않습니다.

```python
df = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6.0, 7.0, 8.0],
        "ham": ["a", None, "c"],
    }
)
other_df = pl.DataFrame(
    {
        "apple": ["x", "y", "z"],
        "ham": ["a", None, "d"],
    }
)

print(df.join(other_df, on="ham", how="full", join_nulls=True))
```

```python
shape: (4, 5)
┌──────┬──────┬──────┬───────┬───────────┐
│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_right │
│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---       │
│ i64  ┆ f64  ┆ str  ┆ str   ┆ str       │
╞══════╪══════╪══════╪═══════╪═══════════╡
│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a         │
│ 2    ┆ 7.0  ┆ null ┆ y     ┆ null      │
│ null ┆ null ┆ null ┆ z     ┆ d         │
│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null      │
└──────┴──────┴──────┴───────┴───────────┘
```

```python
# print(df.join(other_df, on="ham", how="full"))
print(df.join(other_df, on="ham", how="full", join_nulls=False))
```

```python
shape: (5, 5)
┌──────┬──────┬──────┬───────┬───────────┐
│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_right │
│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---       │
│ i64  ┆ f64  ┆ str  ┆ str   ┆ str       │
╞══════╪══════╪══════╪═══════╪═══════════╡
│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a         │
│ null ┆ null ┆ null ┆ y     ┆ null      │
│ null ┆ null ┆ null ┆ z     ┆ d         │
│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null      │
│ 2    ┆ 7.0  ┆ null ┆ null  ┆ null      │
└──────┴──────┴──────┴───────┴───────────┘
```

validate는 두 데이터프레임 관계가 조인 유형과 동일한지 확인합니다. 만약, 다른 경우 에러가 나게 됩니다.

```python
df = pl.DataFrame(
    {
        "foo": [1, 2, 3],
        "bar": [6.0, 7.0, 8.0],
        "ham": ["a", "a" , "c"],
    }
)
other_df = pl.DataFrame(
    {
        "apple": ["x", "y", "z"],
        "ham": ["a", "a", "d"],
    }
)

print(df.join(other_df, on="ham", how="full", validate="m:m"))
# print(df.join(other_df, on="ham", how="full", validate="1:m"))
# print(df.join(other_df, on="ham", how="full", validate="m:1"))
# print(df.join(other_df, on="ham", how="full", validate="1:1"))
```

```
shape: (6, 5)
┌──────┬──────┬──────┬───────┬───────────┐
│ foo  ┆ bar  ┆ ham  ┆ apple ┆ ham_right │
│ ---  ┆ ---  ┆ ---  ┆ ---   ┆ ---       │
│ i64  ┆ f64  ┆ str  ┆ str   ┆ str       │
╞══════╪══════╪══════╪═══════╪═══════════╡
│ 1    ┆ 6.0  ┆ a    ┆ x     ┆ a         │
│ 2    ┆ 7.0  ┆ a    ┆ x     ┆ a         │
│ 1    ┆ 6.0  ┆ a    ┆ y     ┆ a         │
│ 2    ┆ 7.0  ┆ a    ┆ y     ┆ a         │
│ null ┆ null ┆ null ┆ z     ┆ d         │
│ 3    ┆ 8.0  ┆ c    ┆ null  ┆ null      │
└──────┴──────┴──────┴───────┴───────────┘
ComputeError: the join keys did not fulfil 1:m validation
ComputeError: the join keys did not fulfil m:1 validation
ComputeError: the join keys did not fulfil 1:1 validation
```

- m:m(many_to_many) : 기본값, 확인을 수행하지 않습니다.
- 1:m(one_to_many) : 왼쪽 데이터 셋에서 조인 키가 고유한지 확인합니다.
  left_df
  | join_columns | n |
  | ------------ | --- |
  | a | 1 |
  | b | 3 |
  | c | 2 |
  right_df
  | join_columns | n |
  | ------------ | --- |
  | a | 1 |
  | a | 2 |
  | e | 3 |
- m:1(many_to_one) : 오른쪽 데이터 셋에서 조인 키가 고유한지 확인합니다.
  left_df
  | join_columns | n |
  | ------------ | --- |
  | b | 1 |
  | b | 3 |
  | c | 2 |
  right_df
  | join_columns | n |
  | ------------ | --- |
  | a | 1 |
  | d | 2 |
  | e | 3 |
- 1:1(one_to_one) : 왼쪽 및 오른쪽 데이터 셋 모두에서 조인 키가 고유한지 확인합니다.
  left_df
  | join_columns | n |
  | ------------ | --- |
  | a | 1 |
  | b | 3 |
  | c | 2 |
  right_df
  | join_columns | n |
  | ------------ | --- |
  | a | 1 |
  | d | 2 |
  | e | 3 |

### 1.1.7 join_asof

ASOF(As-Of) 조인은 두 테이블을 병합하는 방법 중 하나로, 특히 시계열 데이터에서 유용합니다. ASOF 조인은 기준 열에서 값이 정확히 일치하지 않더라도 가장 가까운 이전 값과 매칭되는 키를 찾습니다. 이는 시계열 데이터의 비동기적 특성을 처리하는 데 유용합니다.

동일한 키가 아닌 가장 가까운 키를 기준으로 매칭한다는 점을 제외하면 left 조인과 비슷합니다. 두 데이터 프레임 모두 키를 기준으로 정렬해야 합니다.

```python
from datetime import date

gdp = pl.DataFrame(
    {
        "date": pl.date_range(
            date(2016, 1, 1),
            date(2020, 1, 1),
            "1y",
            eager=True,
        ),
        "gdp": [4164, 4411, 4566, 4696, 4827],
    }
)

population = pl.DataFrame(
    {
        "date": [date(2016, 3, 1), date(2018, 8, 1), date(2019, 1, 1)],
        "population": [82.19, 82.66, 83.12],
    }
).sort("date")

# df.join_asof(df2, on="컬럼명", strategy="조인 방법")
print(population.join_asof(gdp, on="date", strategy="backward"))
```

- on: 두 데이터 프레임의 조인할 컬럼명입니다. 만약, 두 데이터프레임의 조인 컬럼명이 다를 경우 join에서와 같이 on 대신 left_on, right_on을 사용하여 각각의 조인할 컬럼명을 입력합니다.
- strategy: 어떤 방법으로 조인할지 설정합니다.
  - backward(기본값) : 각 행에 대해 오른쪽 데이터 프레임의 행의 값이 왼쪽 데이터 프레임의 행의 값보다 작거나 같은 마지막 행을 선택합니다.
  - forward : 각 행에 대해 오른쪽 데이터프레임의 행의 값이 왼쪽 데이터 프레임의 행의 값보다 크거나 같은 첫 번째 행을 선택합니다.
  - nearest : 각 행에 대해 오른쪽 데이터프레임의 행의 값이 왼쪽 데이터 프레임의 행의 값에 가장 가까운 값을 가진 마지막 행을 선택합니다. nearest에는 데이터 타입이 문자열인 경우 ASOF 조인이 지원되지 않습니다.

출력 결과를 확인해보시면 날짜가 정확히 일치하지 않는 population의 각 날짜는 gdp에서 가장 가까운 이전 날짜와 매칭된 것을 볼 수 있습니다.

```
shape: (3, 3)
┌────────────┬────────────┬──────┐
│ date       ┆ population ┆ gdp  │
│ ---        ┆ ---        ┆ ---  │
│ date       ┆ f64        ┆ i64  │
╞════════════╪════════════╪══════╡
│ 2016-03-01 ┆ 82.19      ┆ 4164 │
│ 2018-08-01 ┆ 82.66      ┆ 4566 │
│ 2019-01-01 ┆ 83.12      ┆ 4696 │
└────────────┴────────────┴──────┘
```

strategy 매개변수를 forward로 설정하면, population의 2016-03-01 날짜는 gdp의 2016-01-01과 매칭되고, population의 2018-08-01 날짜는 gdp의 2018-01-01과 매칭됩니다. 이처럼 정확히 일치하지 않는 population의 각 날짜는 gdp에서 가장 가까운 이후의 날짜와 매칭됩니다.

```python
print(population.join_asof(gdp, on="date", strategy="forward"))
```

```
shape: (3, 3)
┌────────────┬────────────┬──────┐
│ date       ┆ population ┆ gdp  │
│ ---        ┆ ---        ┆ ---  │
│ date       ┆ f64        ┆ i64  │
╞════════════╪════════════╪══════╡
│ 2016-03-01 ┆ 82.19      ┆ 4411 │
│ 2018-08-01 ┆ 82.66      ┆ 4696 │
│ 2019-01-01 ┆ 83.12      ┆ 4696 │
└────────────┴────────────┴──────┘
```

strategy 매개변수를 nearest로 설정하면, population의 2016-03-01 날짜는 gdp의 2017-01-01과 매칭되고, population의 2018-08-01 날짜는 gdp의 2019-01-01과 매칭됩니다. 이처럼 정확히 일치하지 않는 population의 각 날짜가 이전이든 이후든 상관없이 gdp에서 가장 가까운 날짜와 매칭되므로 위의 두 결과를 혼합하여 제공합니다.

```python
print(population.join_asof(gdp, on="date", strategy="nearest"))
```

```
shape: (3, 3)
┌────────────┬────────────┬──────┐
│ date       ┆ population ┆ gdp  │
│ ---        ┆ ---        ┆ ---  │
│ date       ┆ f64        ┆ i64  │
╞════════════╪════════════╪══════╡
│ 2016-03-01 ┆ 82.19      ┆ 4164 │
│ 2018-08-01 ┆ 82.66      ┆ 4696 │
│ 2019-01-01 ┆ 83.12      ┆ 4696 │
└────────────┴────────────┴──────┘
```

by 매개변수를 사용하면 asof 조인 전에 다른 열에 먼저 조인할 수 있습니다. 국가별로 먼저 조인한 다음 날짜별로 asof 조인합니다.

```python
gdp_dates = pl.date_range(  # fmt: skip
    date(2016, 1, 1), date(2020, 1, 1), "1y", eager=True
)

gdp2 = pl.DataFrame(
    {
        "country": ["Germany"] * 5 + ["Netherlands"] * 5,
        "date": pl.concat([gdp_dates, gdp_dates]),
        "gdp": [4164, 4411, 4566, 4696, 4827, 784, 833, 914, 910, 909],
    }
).sort("country", "date")

pop2 = pl.DataFrame(
    {
        "country": ["Germany"] * 3 + ["Netherlands"] * 3,
        "date": [
            date(2016, 3, 1),
            date(2018, 8, 1),
            date(2019, 1, 1),
            date(2016, 3, 1),
            date(2018, 8, 1),
            date(2019, 1, 1),
        ],
        "population": [82.19, 82.66, 83.12, 17.11, 17.32, 17.40],
    }
).sort("country", "date")

# df.join_asof(df2, by="첫번째 조인 컬럼명", on="두번째 조인 컬럼명", strategy="조인방법")
print(pop2.join_asof(gdp2, by="country", on="date", strategy="nearest"))
```

출력 결과를 보시면 population의 2016-03-01 날짜는 gdp의 2016-01-01과 매칭되고, population의 2018-08-01 날짜는 gdp의 2019-01-01과 매칭됩니다.

on 매개변수와 마찬가지로 두 데이터프레임의 컬럼명이 다를 경우 by_left, by_right 매개변수에 각각의 컬럼명을 입력합니다.

```
shape: (6, 4)
┌─────────────┬────────────┬────────────┬──────┐
│ country     ┆ date       ┆ population ┆ gdp  │
│ ---         ┆ ---        ┆ ---        ┆ ---  │
│ str         ┆ date       ┆ f64        ┆ i64  │
╞═════════════╪════════════╪════════════╪══════╡
│ Germany     ┆ 2016-03-01 ┆ 82.19      ┆ 4164 │
│ Germany     ┆ 2018-08-01 ┆ 82.66      ┆ 4696 │
│ Germany     ┆ 2019-01-01 ┆ 83.12      ┆ 4696 │
│ Netherlands ┆ 2016-03-01 ┆ 17.11      ┆ 784  │
│ Netherlands ┆ 2018-08-01 ┆ 17.32      ┆ 910  │
│ Netherlands ┆ 2019-01-01 ┆ 17.4       ┆ 910  │
└─────────────┴────────────┴────────────┴──────┘
```

두 데이터프레임에 컬럼명이 동일한 경우 suffix 매개변수에 이름이 중복된 열에 추가할 접미사를 입력하여 출력할 수 있습니다.

```python
#  'value' 열이 있는 경우
df1 = pl.DataFrame({
    "date": [date(2023, 1, 1), date(2023, 2, 1), date(2023, 3, 1)],
    "value": [100, 200, 300]
})

df2 = pl.DataFrame({
    "date": [date(2023, 1, 15), date(2023, 2, 15), date(2023, 3, 15)],
    "value": [150, 250, 350]
})

# suffix를 사용하여 중복 열 이름 처리
result = df1.join_asof(df2, on="date", suffix="_right")
print(result)
```

```
shape: (3, 3)
┌────────────┬───────┬────────────┐
│ date       ┆ value ┆ value_right│
│ ---        ┆ ---   ┆ ---        │
│ date       ┆ i64   ┆ i64        │
╞════════════╪═══════╪════════════╡
│ 2023-01-01 ┆ 100   ┆ null       │
│ 2023-02-01 ┆ 200   ┆ 150        │
│ 2023-03-01 ┆ 300   ┆ 250        │
└────────────┴───────┴────────────┘
```

- tolerance : 숫자 허용 오차로 값을 설정하면 가까운 키가 이 거리 내에 있는 경우에만 조인이 수행됩니다. 데이터 타입이 "Date", "Datetime", "Duration", "Time"의 열에 대해 asof 조인을 수행하는 경우 datetime.timedelta 개체 또는 다음 문자열 언어를 사용합니다.

- 1ns(1나노초)
- 1us(1마이크로초)
- 1ms(1밀리초)
- 1s(1초)
- 1m(1분)
- 1h(1시간)

ex) 3d12h4m25s
(3일, 12시간 4분 25초)

- 1d(1역일)
- 1w(1역주)
- 1mo(1역월)
- 1q(1역분기)
- 1y(1역연도)

:::div{.callout}
'역일'이란 다음 날의 해당 시간(서머타임으로 인해 24시간이 아닐 수 있음)을 의미합니다. '역주', '역월', '역분기', '역연도'도 마찬가지입니다.

:::

```python
df1 = pl.DataFrame({
    "date": [date(2023, 1, 1), date(2023, 2, 1), date(2023, 3, 1)],
    "value": [100, 200, 300]
})

df2 = pl.DataFrame({
    "date": [date(2023, 1, 15), date(2023, 2, 15), date(2023, 3, 15)],
    "value": [150, 250, 350]
})

# 20일 이내의 데이터 매칭
print(df1.join_asof(
    df2,
    on="date",
    tolerance="20d",  # 20일로 허용 오차 증가
    suffix="_right"
))
```

```
shape: (3, 3)
┌────────────┬───────┬─────────────┐
│ date       ┆ value ┆ value_right │
│ ---        ┆ ---   ┆ ---         │
│ date       ┆ i64   ┆ i64         │
╞════════════╪═══════╪═════════════╡
│ 2023-01-01 ┆ 100   ┆ null        │
│ 2023-02-01 ┆ 200   ┆ 150         │
│ 2023-03-01 ┆ 300   ┆ 250         │
└────────────┴───────┴─────────────┘
```

대용량 데이터 셋에서 병렬 처리 활성화하는 방법에 대해 알아보도록 하겠습니다.

```python
from datetime import date

df1 = pl.DataFrame({
    "date": pl.date_range(date(2023, 1, 1), date(2023, 12, 31), "1d", eager=True),  # eager=True 추가
    "value": list(range(365))
})

df2 = pl.DataFrame({
    "date": pl.date_range(date(2023, 1, 15), date(2023, 12, 15), "1d", eager=True),  # eager=True 추가
    "value": list(range(335))
})

# 병렬 처리 허용
result_allow = df1.join_asof(
    df2,
    on="date",
    allow_parallel=True,
    suffix="_right"
)
print(result_allow.head())

# 병렬 처리 강제
result_force = df1.join_asof(
    df2,
    on="date",
    force_parallel=True,
    suffix="_right"
)
print(result_force.head())
```

- allow_parallel : 물리적 계획이 선택적으로 조인까지 두 데이터 프레임의 계산을 병렬로 평가하도록 허용합니다.
- force_parallel : 물리적 계획이 조인까지 두 데이터 프레임의 계산을 병렬로 평가하도록 강제합니다.

```
shape: (5, 3)
┌────────────┬───────┬─────────────┐
│ date       ┆ value ┆ value_right │
│ ---        ┆ ---   ┆ ---         │
│ date       ┆ i64   ┆ i64         │
╞════════════╪═══════╪═════════════╡
│ 2023-01-01 ┆ 0     ┆ null        │
│ 2023-01-02 ┆ 1     ┆ null        │
│ 2023-01-03 ┆ 2     ┆ null        │
│ 2023-01-04 ┆ 3     ┆ null        │
│ 2023-01-05 ┆ 4     ┆ null        │
└────────────┴───────┴─────────────┘
shape: (5, 3)
┌────────────┬───────┬─────────────┐
│ date       ┆ value ┆ value_right │
│ ---        ┆ ---   ┆ ---         │
│ date       ┆ i64   ┆ i64         │
╞════════════╪═══════╪═════════════╡
│ 2023-01-01 ┆ 0     ┆ null        │
│ 2023-01-02 ┆ 1     ┆ null        │
│ 2023-01-03 ┆ 2     ┆ null        │
│ 2023-01-04 ┆ 3     ┆ null        │
│ 2023-01-05 ┆ 4     ┆ null        │
└────────────┴───────┴─────────────┘
```

```python
df1 = pl.DataFrame({
    "date": [date(2023, 1, 1), date(2023, 2, 1), date(2023, 3, 1)],
    "value": [100, None, 300]
})

df2 = pl.DataFrame({
    "date": [date(2023, 1, 15), date(2023, 2, 15), date(2023, 3, 15)],
    "value": [150, 250, 350]
})

# coalesce를 True로 설정하여 조인 열 병합
result = df1.join_asof(
    df2,
    on="date",
    coalesce=True,# None 값을 df2의 값으로 대체
    suffix="_right"
)
print(result)
```

- coalesce : 조인 동작(조인 열 병합) , col 이외의 다른 식에 조인하면 병합이 해제됩니다.
  - None: 특정 조인
  - True: 항상 조인 열을 병합합니다.
  - False: 조인 열을 병합하지 않습니다.

```
shape: (3, 3)
┌────────────┬───────┬─────────────┐
│ date       ┆ value ┆ value_right │
│ ---        ┆ ---   ┆ ---         │
│ date       ┆ i64   ┆ i64         │
╞════════════╪═══════╪═════════════╡
│ 2023-01-01 ┆ 100   ┆ null        │
│ 2023-02-01 ┆ null  ┆ 150         │
│ 2023-03-01 ┆ 300   ┆ 250         │
└────────────┴───────┴─────────────┘
```

### 1.1.8 merge_sorted

정렬된 두 개의 데이터 프레임을 가져와 정렬된 키로 병합합니다. 출력 결과도 정렬되어 나옵니다.

두 데이터프레임의 스키마는 동일해야하며, 각가의 데이터 프레임은 정렬할 키를 기준으로 정렬되어 있어야 합니다.

```python
df0 = pl.DataFrame(
    {"name": ["steve", "elise", "bob"], "age": [42, 44, 18]}
).sort("age")

df1 = pl.DataFrame(
    {"name": ["anna", "megan", "steve", "thomas"], "age": [21, 33, 42, 20]}
).sort("age")

# 데이터프레임1.merge_sorted(데이터프레임2, key="정렬할 컬럼명")
print(df0.merge_sorted(df1, key="age"))
```

```
shape: (7, 2)
┌────────┬─────┐
│ name   ┆ age │
│ ---    ┆ --- │
│ str    ┆ i64 │
╞════════╪═════╡
│ bob    ┆ 18  │
│ thomas ┆ 20  │
│ anna   ┆ 21  │
│ megan  ┆ 33  │
│ steve  ┆ 42  │
│ steve  ┆ 42  │
│ elise  ┆ 44  │
└────────┴─────┘
```

## 1.2 데이터 분해

### 1.2.1 explode

지정된 열을 분해하여 데이터 프레임을 긴 형식으로 분해합니다. 분해되는 기본 열은 목록 또는 배열 데이터 타입이어야 합니다.

```python
df = pl.DataFrame({
        "letters": ["a", "a", "b", "c"],
        "numbers": [[1], [2, 3], [4, 5], [6, 7, 8]],
    })
print(df.explode("numbers"))
```

```python
shape: (8, 2)
┌─────────┬─────────┐
│ letters ┆ numbers │
│ ---     ┆ ---     │
│ str     ┆ i64     │
╞═════════╪═════════╡
│ a       ┆ 1       │
│ a       ┆ 2       │
│ a       ┆ 3       │
│ b       ┆ 4       │
│ b       ┆ 5       │
│ c       ┆ 6       │
│ c       ┆ 7       │
│ c       ┆ 8       │
└─────────┴─────────┘
```

### 1.2.2 unnest

각 필드에 대해 구조체 열을 별도의 열로 분해합니다. 새 열은 구조 열의 위치에 있는 데이터프레임에 삽입됩니다.

```python
df = pl.DataFrame({
        "before": ["foo", "bar"],
        "t_a": [1, 2],
        "t_b": ["a", "b"],
        "t_c": [True, None],
        "t_d": [[1, 2], [3]],
        "after": ["baz", "womp"],
    }).select("before", pl.struct(pl.col("^t_.$")).alias("t_struct"), "after")

print(df.unnest("t_struct"))
```

```python
shape: (2, 6)
┌────────┬─────┬─────┬──────┬───────────┬───────┐
│ before ┆ t_a ┆ t_b ┆ t_c  ┆ t_d       ┆ after │
│ ---    ┆ --- ┆ --- ┆ ---  ┆ ---       ┆ ---   │
│ str    ┆ i64 ┆ str ┆ bool ┆ list[i64] ┆ str   │
╞════════╪═════╪═════╪══════╪═══════════╪═══════╡
│ foo    ┆ 1   ┆ a   ┆ true ┆ [1, 2]    ┆ baz   │
│ bar    ┆ 2   ┆ b   ┆ null ┆ [3]       ┆ womp  │
└────────┴─────┴─────┴──────┴───────────┴───────┘
```
