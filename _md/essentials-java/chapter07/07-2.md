---
chapter: 배열
title: 1차원 배열
date: 2024-08-22
---
# 1. 1차원 배열
1차원 배열은 같은 데이터 타입의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조입니다. 

배열의 각 요소는 순차적으로 나열되며, 인덱스를 통해 접근할 수 있습니다.

# 2. 1차원 배열의 선언과 초기화
## 2.1 배열 선언
```java
// 배열 선언 구조
데이터 타입[] 배열 이름;

int[] numbers;
String[] names;
```
1. 배열을 선언할 때는 먼저 배열에 담을 데이터 타입을 먼저 기재합니다.
2. 데이터 타입 기재 후 대괄호([])를 기재하고, 해당 배열의 변수명으로 배열 이름을 기재합니다.

## 2.2 배열 초기화
```java
// 배열 초기화 구조
배열이름 = new 데이터타입[배열크기];

numbers = new int[5];
names = new String[3];
```
1. 선언된 배열을 초기화할 때는 new 키워드를 사용해 대상 배열을 힙(heap) 메모리 공간에 할당합니다.
2. 데이터 타입은 배열 선언 시 사용한 타입과 일치해야 합니다.
3. 대괄호([]) 안에 배열의 크기를 지정합니다. 이 크기는 변경할 수 없습니다.
4. 배열의 각 요소는 해당 데이터 타입의 기본값으로 자동 초기화됩니다.

## 2.3 배열 선언과 초기화
- `2.1`과 `2.2`에서 설명한 배열의 선언과 초기화는 동시에 할 수 있습니다.
```java
데이터타입[] 배열이름 = new 데이터타입[배열크기];

int[] numbers = new int[5];
String[] names = new String[3];
```

## 2.4 기본값으로 배열 초기화
- 숫자형 배열은 초기화 시에나 초기화 이후 값을 지정해주지 않는다면 기본값인 0으로 초기화됩니다.
```java
// 숫자형 배열 초기화
int[] numbers = new int[5];
System.out.println("숫자형 배열 초기값:");
for (int num : numbers) {
    System.out.print(num + " ");  // 출력: 0 0 0 0 0
}
```

- 참조형 배열은 초기화 시에나 초기화 이후 값을 지정해주지 않는다면 기본값인 null로 초기화됩니다.
```java
// 참조형 배열 초기화
String[] strings = new String[3];
System.out.println("참조형 배열 초기값:");
for (String str : strings) {
    System.out.print(str + " ");  // 출력: null null null
}
```

- boolean 배열은 초기화 시에나 초기화 이후 값을 지정해주지 않는다면 기본값인 false로 초기화됩니다.
```java
// 불리언 배열 초기화
boolean[] booleans = new boolean[3];
System.out.println("불리언 배열 초기값:");
for (boolean bool : booleans) {
    System.out.print(bool + " ");  // 출력: false false false
}
```

## 2.5 선언과 동시에 직접 값 지정하여 배열 초기화
```java
데이터타입[] 배열이름 = {값1, 값2, 값3, ...};

int[] numbers = {1, 2, 3, 4, 5};
String[] fruits = {"apple", "banana", "orange"};
```
1. 중괄호 {} 안에 배열의 초기값들을 나열합니다.
2. 컴파일러가 중괄호 안의 값의 개수를 세어 자동으로 배열의 크기를 결정합니다.
3. 나열된 값들로 배열 요소가 초기화됩니다.

# 3. 배열 요소 접근 및 수정
배열의 각 요소는 인덱스를 통해 접근할 수 있으며, 인덱스는 0부터 시작합니다.
## 3.1 배열 요소 접근
- 인덱스는 0부터 시작합니다. 따라서 첫 번째 요소의 인덱스는 0입니다.
- 배열의 마지막 요소에 접근하려면 배열이름[배열이름.length - 1]을 사용합니다.
- 유효하지 않은 인덱스(음수 또는 배열의 길이 이상의 값)를 사용하면 ArrayIndexOutOfBoundsException이 발생합니다.
```java
// 배열 요소 접근 기본 문법
배열이름[인덱스]

int[] scores = {90, 85, 77, 93, 88};

System.out.println("첫 번째 점수: " + scores[0]);  // 출력: 90
System.out.println("세 번째 점수: " + scores[2]);  // 출력: 77
System.out.println("마지막 점수: " + scores[scores.length - 1]);  // 출력: 88
```
- scores 배열에 0번째 인덱스로 접근했을 때는 첫 번째 요소에 접근하기 때문에 {90, 85, 77, 93, 88} 중 첫 번째 요소인 90에 접근하게 됩니다.

```java
scores[2] = 80;  // 세 번째 요소 값 변경
System.out.println("변경된 세 번째 점수: " + scores[2]);  // 출력: 80
```

# 4. 배열의 길이
배열의 길이는 length 속성을 통해 얻을 수 있습니다.
```java
int[] numbers = {1, 2, 3, 4, 5};
System.out.println("배열의 길이: " + numbers.length);  // 출력: 5
```

# 5. 배열 복사
배열을 복사하는 방법에는 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)가 있습니다.
## 5.1 얕은 복사
- 얕은 복사는 배열의 참조(메모리 주소)만을 복사합니다. 즉, 새로운 배열 변수가 원본 배열과 동일한 메모리 위치를 가리키게 됩니다.
```java
int[] original = {1, 2, 3, 4, 5};
int[] copy = original;

copy[0] = 10;
System.out.println(original[0]);  // 출력: 10
System.out.println(copy[0]);      // 출력: 10
```
- 위 코드에서 original과 copy는 같은 배열을 참조하므로 한 쪽의 변경이 다른 쪽에도 반영됩니다.

## 5.2 깊은 복사
- 깊은 복사는 배열의 모든 요소를 새로운 메모리 공간에 복사합니다. 원본 배열과 복사본 배열이 서로 독립적인 메모리를 가지게 됩니다.
1. 반복문을 사용한 복사
```java
int[] original = {1, 2, 3, 4, 5};
int[] copy = new int[original.length];

for (int i = 0; i < original.length; i++) {
    copy[i] = original[i];
}
```

2. System.arraycopy() 메소드 사용
```java
int[] original = {1, 2, 3, 4, 5};
int[] copy = new int[original.length];
System.arraycopy(original, 0, copy, 0, original.length);
```

3. Arrays.copyOf() 메소드 사용
```java
int[] original = {1, 2, 3, 4, 5};
int[] copy = Arrays.copyOf(original, original.length);
```

4. clone() 메소드 사용
```java
int[] original = {1, 2, 3, 4, 5};
int[] copy = original.clone();
```

# 6. 주의사항
- 배열의 인덱스는 0부터 시작합니다.
- 배열의 크기를 벗어난 인덱스에 접근하면 ArrayIndexOutOfBoundsException이 발생합니다.
- 배열은 한 번 생성되면 크기를 변경할 수 없습니다.

:::div{.callout}
1차원 배열은 Java 프로그래밍에서 가장 기본적이고 중요한 자료구조 중 하나입니다. 배열을 효과적으로 사용하면 데이터를 효율적으로 관리하고 처리할 수 있습니다. 배열의 선언, 초기화, 접근, 순회 등의 기본 개념을 잘 이해하고 활용하는 것이 중요합니다.
:::