---
chapter: 객체지향 프로그래밍(OOP) 기초
title: 객체지향 4대 원칙
date: 2024-08-26
---

# 1. 캡슐화 (Encapsulation)

## 1.1 캡슐화의 정의

캡슐화는 객체의 데이터(속성)와 그 데이터를 처리하는 메서드(기능)를 하나로 묶어 외부로부터 보호하는 것을 말합니다. 이는 객체의 내부 구현을 숨기고 외부에서의 접근을 제어하는 메커니즘입니다.

## 1.2 캡슐화의 주요 특징

1. 데이터 은닉 (Data Hiding)
2. 접근 제어 (Access Control)
3. 유지보수성 향상

## 1.3 실생활 예시: 자동차

자동차를 통해 캡슐화의 개념을 이해해봅시다.

```
    +------------------------+
    |        자동차          |
    |  +------------------+  |
    |  | 엔진             |  | 
    |  | 연료 시스템      |  |
    |  | 전기 시스템      |  |
    |  +------------------+  |
    |                        |
    |  스티어링 휠     (O)   |
    |  가속 페달       (O)   |
    |  브레이크 페달   (O)   |
    +------------------------+
```

![](/images/essentials-java/chapter15/OOP15-3-ex2.png)

- 자동차의 복잡한 내부 구조(엔진, 연료 시스템 등)는 사용자에게 보이지 않습니다.
- 운전자는 스티어링 휠, 가속 페달, 브레이크 페달 등의 인터페이스만을 사용하여 차를 조작합니다.
- 자동차의 내부 작동 원리를 모르더라도 누구나 쉽게 운전할 수 있습니다.

## 1.4 자바에서의 캡슐화 구현

```java
public class Car {
    // private 키워드로 내부 상태를 은닉
    private int fuel;
    private boolean engineOn;

    // 생성자
    public Car() {
        this.fuel = 0;
        this.engineOn = false;
    }

    // public 메서드를 통한 기능 제공
    public void startEngine() {
        if (fuel > 0 && !engineOn) {
            engineOn = true;
            System.out.println("엔진이 시동되었습니다.");
        } else if (engineOn) {
            System.out.println("이미 엔진이 켜져 있습니다.");
        } else {
            System.out.println("연료가 부족합니다.");
        }
    }

    public void addFuel(int amount) {
        if (amount > 0) {
            fuel += amount;
            System.out.println(amount + "L의 연료가 주입되었습니다.");
        } else {
            System.out.println("유효하지 않은 연료량입니다.");
        }
    }

    public int getFuelLevel() {
        return fuel;
    }
}
```

위 코드에서 아래와 같은 특징을 확인할 수 있습니다.

- `fuel`과 `engineOn`은 `private`으로 선언되어 외부에서 직접 접근할 수 없습니다.
- `startEngine()`, `addFuel()`, `getFuelLevel()` 메서드를 통해 자동차의 상태를 안전하게 조작하고 확인할 수 있습니다.

## 1.5 캡슐화의 이점

1. **데이터 보호**: 객체의 내부 상태를 보호하여 무결성을 유지합니다.
2. **유지보수성 향상**: 내부 구현을 변경해도 외부 인터페이스가 유지되면 다른 코드에 영향을 주지 않습니다.
3. **사용의 편의성**: 복잡한 내부 로직을 알 필요 없이 제공된 메서드만으로 객체를 사용할 수 있습니다.

## 1.6 연습 문제

### 5.6.1 스마트폰 클래스를 설계해보세요. 배터리 잔량, 전원 상태, 볼륨 레벨을 관리하고, 전원 켜기/끄기, 볼륨 조절, 배터리 충전 기능을 구현하세요.

   <details>
   <summary>정답 코드 및 설명 보기</summary>

   ```java
   public class Smartphone {
       // 캡슐화된 필드들
       private int batteryLevel;
       private boolean isPowerOn;
       private int volumeLevel;
   
       // 생성자
       public Smartphone() {
           this.batteryLevel = 50;  // 초기 배터리 50%
           this.isPowerOn = false;
           this.volumeLevel = 5;    // 초기 볼륨 5
       }
   
       // 전원 켜기/끄기
       public void togglePower() {
           if (batteryLevel > 0) {
               isPowerOn = !isPowerOn;
               System.out.println(isPowerOn ? "전원이 켜졌습니다." : "전원이 꺼졌습니다.");
           } else {
               System.out.println("배터리가 없어 전원을 켤 수 없습니다.");
           }
       }
   
       // 볼륨 조절
       public void adjustVolume(int amount) {
           if (!isPowerOn) {
               System.out.println("전원이 꺼져 있습니다.");
               return;
           }
           volumeLevel += amount;
           if (volumeLevel < 0) volumeLevel = 0;
           if (volumeLevel > 10) volumeLevel = 10;
           System.out.println("현재 볼륨: " + volumeLevel);
       }
   
       // 배터리 충전
       public void chargeBattery(int amount) {
           batteryLevel += amount;
           if (batteryLevel > 100) batteryLevel = 100;
           System.out.println("현재 배터리 잔량: " + batteryLevel + "%");
       }
   
       // 배터리 잔량 확인
       public int getBatteryLevel() {
           return batteryLevel;
       }
   
       // 전원 상태 확인
       public boolean isPowerOn() {
           return isPowerOn;
       }
   
       // 볼륨 레벨 확인
       public int getVolumeLevel() {
           return volumeLevel;
       }
   }
   ```

1. **캡슐화된 필드**
    - `batteryLevel`, `isPowerOn`, `volumeLevel`은 `private`으로 선언되어 외부에서 직접 접근할 수 없습니다.

2. **생성자**
    - 스마트폰 객체 생성 시 초기 상태를 설정합니다.

3. **전원 켜기/끄기 (togglePower)**
    - 배터리가 있을 때만 전원 상태를 전환합니다.
    - 현재 상태의 반대로 `isPowerOn`을 설정합니다.

4. **볼륨 조절 (adjustVolume)**
    - 전원이 켜져 있을 때만 동작합니다.
    - 볼륨을 0에서 10 사이로 유지합니다.

5. **배터리 충전 (chargeBattery)**
    - 배터리 레벨을 증가시키고 100%를 초과하지 않도록 합니다.

6. **상태 확인 메서드들**
    - `getBatteryLevel()`, `isPowerOn()`, `getVolumeLevel()`을 통해
      내부 상태를 안전하게 확인할 수 있습니다.

- 데이터(필드)는 private으로 숨겨져 있습니다.
    - 각 기능은 메서드를 통해 제공됩니다.
    - 내부 상태의 유효성을 검사하고 보장합니다 (예: 볼륨 범위 제한).
    - 외부에서는 제공된 메서드를 통해서만 객체와 상호작용할 수 있습니다.

   </details>

# 2. 상속 (Inheritance)

## 2.1 상속의 정의

상속은 객체 지향 프로그래밍의 핵심 원칙 중 하나로, **기존의 클래스(부모 클래스)의 특성을 새로운 클래스(자식 클래스)가 물려받는 메커니즘입니다.** 이를 통해 코드의 재사용성을 높이고, 객체 간의 계층적 관계를
구성할 수 있습니다.

## 2.2 상속의 주요 특징

1. **코드 재사용**: 부모 클래스의 속성과 메서드를 자식 클래스에서 다시 작성할 필요 없이 사용할 수 있습니다.
2. **계층 구조**: 객체들 간의 분류와 구조화된 관계를 표현할 수 있습니다.
3. **확장성**: 기존 클래스를 수정하지 않고 새로운 기능을 추가할 수 있습니다.
4. **다형성의 기반**: 상속은 다형성을 구현하는 기초가 됩니다.

## 2.3 상속의 개념 이해하기

생물 분류 체계를 통해 상속의 개념을 이해해봅시다.

![](/images/essentials-java/chapter15/OOP15-3-ex1.png)

- **공통 특성의 상속**
    - 모든 생물은 '생존', '번식' 등의 기본 특성을 가집니다.
    - 동물과 식물은 이러한 생물의 기본 특성을 '상속'받습니다.
    - 포유류는 동물의 특성을 상속받고, 추가로 '젖분비', '체온유지' 등의 특성을 가집니다.

- **특수화(Specialization)**
    - 개와 고양이는 포유류의 모든 특성을 상속받으면서, 각자의 고유한 특성(개의 '짖기', 고양이의 '야옹거리기')을 추가합니다.

- **계층 구조**
    - 이 구조에서 상위 클래스는 더 일반적인 특성을, 하위 클래스로 갈수록 더 특수한 특성을 가집니다.

## 2.4 상속의 이점

1. **코드 중복 감소**
    - 공통된 특성을 상위 클래스에 한 번만 정의하여 중복을 줄입니다.
    - 예: '생존' 메서드를 '생물' 클래스에 한 번만 정의하면, 모든 하위 클래스에서 사용 가능합니다.

2. **유지보수 용이성**
    - 공통 특성의 변경이 필요할 때 상위 클래스만 수정하면 됩니다.
    - 예: '생존' 메커니즘의 변경이 필요할 경우, '생물' 클래스만 수정하면 모든 하위 클래스에 적용됩니다.

3. **다형성 구현**
    - 상속을 통해 같은 타입으로 다양한 객체를 다룰 수 있습니다.
    - 예: '동물' 타입의 변수로 '개'와 '고양이' 객체를 모두 다룰 수 있습니다.

4. **개념의 계층적 표현**
    - 현실 세계의 분류 체계를 프로그래밍에서 자연스럽게 표현할 수 있습니다.

## 2.5 상속의 주의점

1. **복잡성**: 과도한 상속은 클래스 구조를 복잡하게 만들 수 있습니다.
2. **유연성 감소**: 상속은 강한 결합을 만들어 유연성을 떨어뜨릴 수 있습니다.
3. **불필요한 기능 상속**: 때로는 필요 없는 기능까지 상속받을 수 있습니다.

## 2.6 상속 이해를 위한 핵심 질문

1. 상속은 어떤 상황에서 유용할까요?

2. '모든 A는 B이다'라는 관계가 성립할 때 상속을 사용할 수 있을까요?

3. 상속과 구성(Composition) 중 어느 것을 선택해야 할까요?

4. 다중 상속의 장단점은 무엇일까요? (Java는 다중 상속을 지원하지 않습니다)

---
<details>
<summary>질문에 대한 답변 보기</summary>

1. 상속은 어떤 상황에서 유용할까요?

   1. **공통 특성이 많은 여러 클래스가 있을 때**
      
      예를 들어, '자동차', '오토바이', '자전거'는 모두 '탈것'이라는 공통점이 있습니다. 이럴 때 '탈것' 클래스를 만들어 공통 특성(예: 이동하다, 멈추다)을 정의하고, 나머지 클래스들이 이를 상속받으면 코드 중복을 줄일 수 있습니다.
   
   
   2. **기존 클래스의 기능을 확장하고 싶을 때**
      
      만약 '스마트폰' 클래스가 있는데, '폴더블 스마트폰'을 만들고 싶다면, '스마트폰'을 상속받아 폴딩 기능만 추가하면 됩니다.
   
   
   3. **다형성을 활용하고 싶을 때**
      
      '동물' 클래스를 상속받은 '개', '고양이', '말' 등의 객체를 모두 '동물' 타입으로 다룰 수 있어, 코드의 유연성이 높아집니다.

2. '모든 A는 B이다'라는 관계가 성립할 때 상속을 사용할 수 있을까요?

   > 네, '모든 A는 B이다'라는 관계가 성립할 때 상속을 사용하는 것이 적절합니다. 이를 'is-a' 관계라고 부릅니다.

   **예시**

    - 모든 개는 동물이다 → 개 클래스는 동물 클래스를 상속받을 수 있습니다.
    - 모든 자동차는 탈것이다 → 자동차 클래스는 탈것 클래스를 상속받을 수 있습니다.

   **주의할 점**

    1. '~을 가지고 있다' (has-a) 관계는 상속보다는 구성(composition)을 사용해야 합니다.
       
       예시: '자동차는 엔진을 가지고 있다' → 상속보다는 자동차 클래스가 엔진 객체를 포함하는 것이 좋습니다.

   2. 과도한 상속은 피해야 합니다. 때로는 인터페이스나 구성이 더 적절할 수 있습니다.

   **따라서 'is-a' 관계가 명확할 때 상속을 고려하되, 다른 설계 방식도 함께 검토해보는 것이 좋습니다.**


3. 객체지향 프로그래밍으로 개발할 시, 어떤 상황일 때 상속과 구성(Composition) 중 어느 것을 선택해야 할까요?

   **상속을 선택할 때**

      - 'is-a' 관계가 명확할 때 (예: 고양이는 동물이다)
      - 부모 클래스의 모든 특성을 물려받아 사용할 때
      - 다형성을 활용하고 싶을 때

   **구성을 선택할 때**

      - 'has-a' 관계일 때 (예: 자동차는 엔진을 가지고 있다)
      - 유연성이 필요할 때 (객체를 교체하기 쉬움)
      - 부모 클래스의 일부 기능만 필요할 때

   **예시**

    1. 상속: `class Cat extends Animal { ... }`
        - 고양이는 동물의 모든 특성을 가지며, 동물로 취급될 수 있습니다.

    2. 구성: `class Car { private Engine engine; ... }`
        - 자동차는 엔진을 부품으로 가지고 있으며, 필요시 다른 엔진으로 교체할 수 있습니다.

   **일반적으로 "상속보다는 구성을 사용하라"는 원칙이 있지만, 각 상황에 맞는 적절한 선택이 중요합니다.**

4. 다중 상속의 장점 및단점은 무엇일까요? (Java는 다중 상속을 지원하지 않습니다)

   **장점**
      1. 코드 재사용성 증가: 여러 클래스의 기능을 한 번에 상속받을 수 있습니다.
      2. 유연한 설계: 다양한 특성을 조합하여 새로운 클래스를 만들 수 있습니다.

   **단점**

      1. **다이아몬드 문제:** 두 부모 클래스가 같은 조상 클래스를 가질 때 발생하는 모호성 문제
      ```
          A    
         / \   
        B   C
         \ /   D가 B와 C를 상속받을 때, A의 메서드를 
          D    어느 경로로 상속받아야 할지 모호해집니다.
      ```
   
      2. **복잡성 증가:** 클래스 간 관계가 복잡해져 유지보수가 어려워질 수 있습니다.
      3. **충돌 가능성:** 서로 다른 부모 클래스에서 같은 이름의 메서드나 속성이 있을 때 충돌이 발생할 수 있습니다.

   **Java에서는 이러한 문제를 피하고자 클래스의 다중 상속을 금지하고, 대신 인터페이스를 통한 다중 구현을 지원합니다. 이는 다중 상속의 장점은 취하면서 단점은 최소화하는 방법입니다.**

</details>

# 3. 추상화 (Abstraction)

## 3.1 추상화의 정의

추상화는 복잡한 시스템에서 핵심적인 개념 또는 기능을 간추려 내는 것을 의미합니다. 이는 불필요한 세부 사항은 숨기고 중요한 부분만을 드러내어 복잡성을 관리하는 기법입니다.

## 3.2 추상화의 주요 특징

1. 복잡성 감소
2. 핵심 기능 집중
3. 재사용성 증가
4. 유지보수 용이성

## 3.3 실생활 예시: 자동차 운전

자동차 운전을 통해 추상화의 개념을 이해해봅시다.

```
     운전자 인터페이스
    +------------------+
    |   스티어링 휠    |
    |   가속 페달      |
    |   브레이크 페달  |
    |   기어 변속기    |
    +------------------+
             |
             v
     자동차 내부 시스템
    +------------------+
    |   엔진           |
    |   변속기         |
    |   연료 시스템    |
    |   전기 시스템    |
    +------------------+
```
![](/images/essentials-java/chapter15/OOP15-3-ex3.png)

- **추상화 전**: 운전자가 엔진, 변속기, 연료 시스템 등 모든 내부 작동 원리를 알아야 함
- **추상화 후**: 운전자는 스티어링 휠, 페달, 기어 변속기만으로 차를 운전할 수 있음

추상화를 통해 복잡한 자동차 시스템을 단순한 인터페이스로 제어할 수 있게 됩니다.

## 3.4 프로그래밍에서의 추상화

추상화는 주로 두 가지 방법으로 구현됩니다.

1. **추상 클래스 (Abstract Class)**
    - 공통적인 특성을 가진 클래스들의 기본 틀
    - 일부 메서드는 구현하고, 일부는 하위 클래스에서 구현하도록 함

2. **인터페이스 (Interface)**
    - 클래스가 구현해야 할 메서드들의 명세
    - 모든 메서드가 추상 메서드로 이루어짐

## 3.5 추상화의 이점

1. **코드 단순화**: 복잡한 내부 로직을 숨기고 필요한 기능만 노출
2. **유지보수성 향상**: 내부 구현 변경이 외부에 영향을 미치지 않음
3. **재사용성 증가**: 공통 인터페이스를 통해 다양한 구현 가능
4. **개발 효율성**: 세부 구현에 앞서 전체 구조 설계 가능

## 3.6 추상화 이해를 위한 핵심 질문

1. 추상화가 왜 필요한가요?
2. 추상 클래스와 인터페이스의 차이점은 무엇인가요?
3. 실제 프로그래밍에서 추상화를 어떻게 적용할 수 있을까요?
4. 추상화의 단점이 있다면 무엇일까요?
---
<details>
<summary>질문에 대한 답변 보기</summary>

1. 추상화가 왜 필요한가요?
    - 복잡성 관리: 큰 시스템을 다룰 때 세부사항을 숨기고 핵심에 집중할 수 있게 해줍니다.
    - 유연성: 구체적인 구현에 얽매이지 않고 전체 구조를 설계할 수 있습니다.
    - 코드 재사용: 공통된 특성을 추상화하여 여러 곳에서 재사용할 수 있습니다.

2. 추상 클래스와 인터페이스의 차이점은 무엇인가요?
    - 추상 클래스: 일부 구현된 메서드와 추상 메서드를 모두 가질 수 있습니다. 단일 상속만 가능합니다.
    - 인터페이스: 모든 메서드가 추상 메서드입니다(Java 8 이후 default 메서드 예외). 다중 구현이 가능합니다.

3. 실제 프로그래밍에서 추상화를 어떻게 적용할 수 있을까요?
    - 공통 인터페이스 정의: 예를 들어, 모든 도형 클래스가 구현해야 할 `draw()` 메서드를 정의합니다.
    - 세부 구현 은닉: 복잡한 알고리즘의 내부 동작을 숨기고 간단한 메서드로 제공합니다.
    - 계층 구조 설계: 추상 클래스를 사용하여 관련 클래스들의 공통 특성을 정의합니다.

4. 추상화의 단점이 있다면 무엇일까요?
    - 설계의 복잡성: 적절한 추상화 수준을 정하는 것이 어려울 수 있습니다.
    - 성능 오버헤드: 때로는 추상화로 인해 직접 구현보다 성능이 떨어질 수 있습니다.
    - 학습 곡선: 추상화된 시스템을 이해하는 데 시간이 걸릴 수 있습니다.

</details>

# 4. 다형성 (Polymorphism)

## 4.1 다형성의 정의

다형성은 **여러 가지 형태를 가질 수 있는 능력**을 의미합니다.

프로그래밍에서는 같은 인터페이스나 메서드가 다양한 형태로 동작할 수 있음을 나타냅니다.

## 4.2 다형성의 주요 특징

1. 코드의 유연성 증가
2. 확장성 향상
3. 코드 재사용성 증대
4. 인터페이스 단순화

## 4.3 실생활 예시: 리모컨

리모컨을 통해 다형성의 개념을 이해해봅시다.

```
    리모컨 (인터페이스)
    +----------------+
    |   전원 버튼    |
    |   볼륨 +/-     |
    |   채널 +/-     |
    +----------------+
            |
     +------+------+
     |             |
   TV 리모컨    에어컨 리모컨
```
![](/images/essentials-java/chapter15/OOP15-3-ex4.png)

- 같은 '전원' 버튼이 TV에서는 TV를 켜고, 에어컨에서는 에어컨을 켭니다.
- '볼륨 +/-'는 TV에서는 소리를, 에어컨에서는 온도를 조절합니다.
- 하나의 인터페이스(리모컨)가 여러 객체(TV, 에어컨)에 대해 다르게 동작합니다.

이처럼 다형성을 통해 동일한 인터페이스로 다양한 기기를 제어할 수 있습니다.

## 4.4 프로그래밍에서의 다형성

프로그래밍에서 다형성은 주로 세 가지 형태로 나타납니다.

1. **오버로딩 (Overloading)**
    - 같은 이름의 메서드를 매개변수의 타입이나 개수를 달리하여 여러 개 정의
    - 컴파일 시간에 결정되는 정적 다형성

2. **오버라이딩 (Overriding)**
    - 상위 클래스의 메서드를 하위 클래스에서 재정의
    - 실행 시간에 결정되는 동적 다형성

:::div{.box}
   오버로딩과 오버라이딩은 다음 챕터인 **'상속'** 에서 자세히 다룹니다.
   ::a[오버로딩과 오버라이딩]{class='btn-link' href="https://www.books.weniv.co.kr/essentials-java/chapter16/16-3" target="\_blank"}
:::

3. **인터페이스 다형성**
    - 하나의 인터페이스나 상위 클래스 타입으로 여러 하위 클래스 객체를 다룸

## 4.5 다형성의 이점

1. **코드 재사용**: 같은 코드로 다양한 타입의 객체 처리 가능
2. **유연성**: 새로운 클래스 추가가 기존 코드에 영향을 미치지 않음
3. **확장성**: 기존 코드 수정 없이 새로운 기능 추가 가능
4. **결합도 감소**: 객체 간의 의존성을 줄여 유지보수성 향상

## 4.6 다형성 이해를 위한 핵심 질문

1. 다형성이 왜 중요한가요?
2. 다형성은 어떻게 코드의 유연성을 높이나요?
3. 다형성의 단점이 있다면 무엇일까요?
---

<details>
<summary>질문에 대한 답변 보기</summary>

1. 다형성이 왜 중요한가요?
    - **코드 재사용성:** 하나의 인터페이스로 다양한 객체를 다룰 수 있어 코드 중복을 줄입니다.
    - **유연성:** 새로운 클래스를 추가할 때 기존 코드를 변경하지 않아도 됩니다.
    - **확장성:** 시스템에 새로운 기능을 쉽게 추가할 수 있습니다.
    - **간결성:** 복잡한 if-else 구문 대신 다형성을 사용하여 코드를 간결하게 만들 수 있습니다.

2. 다형성은 어떻게 코드의 유연성을 높이나요?
    - **인터페이스 사용:** 구체적인 구현에 의존하지 않고 인터페이스에 의존하여 코드를 작성할 수 있습니다.
    - **타입 유연성:** 상위 타입의 참조 변수로 하위 타입의 객체를 참조할 수 있습니다.
    - **확장 용이성:** 새로운 클래스를 추가할 때 기존 코드를 변경하지 않아도 됩니다.

3. 다형성의 단점이 있다면 무엇일까요?
    - **복잡성 증가:** 다형성을 과도하게 사용하면 코드의 흐름을 파악하기 어려울 수 있습니다.
    - **성능 오버헤드:** 동적 바인딩으로 인한 약간의 성능 저하가 있을 수 있습니다.
    - **디버깅의 어려움:** 실행 시간에 결정되는 동작을 추적하기 어려울 수 있습니다.
    - **설계의 어려움:** 적절한 추상화 수준을 결정하는 것이 쉽지 않을 수 있습니다.

</details>