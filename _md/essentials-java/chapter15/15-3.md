---
chapter: 객체지향 프로그래밍(OOP) 기초
title: 접근 제어자, Getter, Setter, 생성자
date: 2024-08-23
---

# 3.1 접근 제어자 (Access Modifiers)

자바에서 접근 제어자는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 키워드입니다. 이를 통해 데이터를 보호하고, 불필요한 접근을 막을 수 있습니다.

## 3.1.1 접근 제어자의 종류

1. **public**: 어디서든 접근 가능
2. **protected**: 같은 패키지 내에서, 그리고 다른 패키지의 자식 클래스에서 접근 가능
3. **default** (package-private): 같은 패키지 내에서만 접근 가능
4. **private**: 같은 클래스 내에서만 접근 가능

## 3.1.2 접근 제어자 이해하기

접근 제어자를 이해하기 위해 간단한 "동물원 관리 시스템"을 예로 들어보겠습니다.

```java
// Animal.java
public class Animal {
    public String species;     // 모든 곳에서 접근 가능
    protected int age;         // 같은 패키지와 자식 클래스에서 접근 가능
    String habitat;            // 같은 패키지에서만 접근 가능 (default)
    private String healthStatus; // 이 클래스 내에서만 접근 가능

    // private 멤버에 접근하기 위한 public 메서드
    public String getHealthStatus() {
        return healthStatus;
    }

    public void setHealthStatus(String status) {
        healthStatus = status;
    }
}
```

## 3.1.3 접근 제어자의 범위

아래 다이어그램은 각 접근 제어자의 범위를 시각적으로 보여줍니다.

```
   [전체 프로그램]
   |
   |-- [다른 패키지]  (public만 접근 가능)
   |
   |-- [같은 패키지]
       |
       |-- [다른 클래스]  (public, protected, default 접근 가능)
       |
       |-- [같은 클래스]  (모든 접근 제어자 접근 가능)
```

## 3.1.4 접근 제어자 사용 예시

```java
// Zookeeper.java (같은 패키지 내의 다른 클래스)
public class Zookeeper {
    public void checkAnimal(Animal animal) {
        System.out.println("Species: " + animal.species);  // OK (public)
        System.out.println("Age: " + animal.age);          // OK (protected)
        System.out.println("Habitat: " + animal.habitat);  // OK (default)
        // System.out.println("Health: " + animal.healthStatus);  // 컴파일 에러! (private)
        System.out.println("Health: " + animal.getHealthStatus());  // OK (public method)
    }
}
```

이 예제에선 `Zookeeper` 클래스는 `Animal`과 같은 패키지에 있어 `public`, `protected`, `default` 멤버에 접근할 수 있습니다. 

하지만 `private` 멤버인 `healthStatus`에는 직접 접근할 수 없고, public 메서드를 통해 접근해야 합니다.

# 3.2 Getter와 Setter

앞서 우리는 접근 제어자를 통해 클래스의 멤버 변수에 대한 접근을 제한할 수 있다는 것을 배웠습니다. 그런데 private으로 선언된 변수에 어떻게 접근하고 수정할 수 있을까요? 여기서 Getter와 Setter 메서드가 등장합니다.

## 3.2.1 Getter와 Setter란?

Getter와 Setter는 객체의 데이터를 안전하게 접근하고 수정할 수 있게 해주는 메서드입니다.

- **Getter**: 객체의 private 변수의 값을 반환하는 메서드
- **Setter**: 객체의 private 변수의 값을 설정하는 메서드

## 3.2.2 Getter와 Setter가 필요한 이유

아래 그림을 통해 Getter와 Setter의 필요성을 이해해봅시다:

```
[외부 세계]   ->   [객체의 벽]   ->   [객체의 내부]
                     |
                     |  Getter/Setter (문지기)
                     |
```

1. **데이터 보호**: 객체의 내부 데이터를 직접 접근하지 못하게 하여 보호합니다.
2. **유효성 검사**: 데이터가 설정되기 전에 유효한 값인지 확인할 수 있습니다.
3. **유연성**: 내부 구현을 변경하지 않고도 접근 방식을 수정할 수 있습니다.

## 3.2.3 실제 시나리오: 동물원 관리 시스템

동물원에서 동물들의 정보를 관리하는 시스템을 만든다고 상상해봅시다. 

각 동물의 나이를 관리해야 하는데, 나이는 음수가 될 수 없습니다. 

Getter와 Setter를 사용하여 이를 어떻게 구현할 수 있을지 살펴보겠습니다.

```java
public class Animal {
    private String name;  // 동물의 이름
    private int age;      // 동물의 나이

    // name에 대한 Getter
    public String getName() {
        return name;
    }

    // name에 대한 Setter
    public void setName(String newName) {
        // 이름이 null이거나 비어있지 않은지 확인
        if (newName != null && !newName.isEmpty()) {
            name = newName;
        } else {
            System.out.println("Error: 이름은 비워둘 수 없습니다.");
        }
    }

    // age에 대한 Getter
    public int getAge() {
        return age;
    }

    // age에 대한 Setter
    public void setAge(int newAge) {
        // 나이가 0 이상인지 확인
        if (newAge >= 0) {
            age = newAge;
        } else {
            System.out.println("Error: 나이는 음수가 될 수 없습니다.");
        }
    }
}
```

## 3.2.4 Getter와 Setter 사용 예시

이제 이 `Animal` 클래스를 사용하는 방법을 살펴보겠습니다.

```java
public class ZooManagement {
    public static void main(String[] args) {
        // 새로운 동물 객체 생성
        Animal lion = new Animal();

        // Setter를 사용하여 값 설정
        lion.setName("Simba");
        lion.setAge(5);

        // Getter를 사용하여 값 가져오기
        System.out.println("동물 이름: " + lion.getName());
        System.out.println("동물 나이: " + lion.getAge());

        // 잘못된 값 설정 시도
        lion.setAge(-3);  // 에러 메시지 출력
        lion.setName("");  // 에러 메시지 출력

        // 값이 변경되지 않았는지 확인
        System.out.println("동물 나이: " + lion.getAge());
        System.out.println("동물 이름: " + lion.getName());
    }
}
```

이 코드를 실행하면 다음과 같은 결과가 나옵니다.

```
동물 이름: Simba
동물 나이: 5
Error: 나이는 음수가 될 수 없습니다.
Error: 이름은 비워둘 수 없습니다.
동물 나이: 5
동물 이름: Simba
```

## 3.2.5 Getter와 Setter의 장점

1. **데이터 무결성**: Setter에서 유효성 검사를 통해 잘못된 데이터가 설정되는 것을 방지합니다.
2. **캡슐화**: 내부 데이터 구조를 숨기고, 외부에서는 메서드를 통해서만 접근할 수 있게 합니다.
3. **유연성**: 나중에 내부 구현을 변경하더라도 외부 코드에 영향을 주지 않습니다.

## 3.2.6 주의사항

1. **과도한 사용 주의**: 모든 private 변수에 대해 무조건 Getter와 Setter를 만들지 않습니다.
2. **불변성 고려**: 객체의 상태가 변경되지 않아야 하는 경우, Setter를 제공하지 않을 수 있습니다.

Getter와 Setter를 적절히 사용하면 객체의 데이터를 안전하게 관리하고, 코드의 유지보수성을 높일 수 있습니다. 

# 3.3 생성자 (Constructor)

객체 지향 프로그래밍에서 객체를 생성할 때 가장 먼저 호출되는 특별한 메서드가 있습니다. 

바로 '생성자'입니다. 생성자는 객체의 초기화를 담당하는 중요한 요소입니다.

## 3.3.1 생성자란?

생성자는 객체가 생성될 때 자동으로 호출되는 특별한 메서드입니다. 

주로 객체의 초기 상태를 설정하는 데 사용됩니다.

**생성자의 특징**

1. 클래스의 이름과 동일합니다.
2. 반환 타입이 없습니다 (void도 사용하지 않습니다).
3. 객체 생성 시 자동으로 호출됩니다.

## 3.3.2 생성자가 필요한 이유

생성자를 사용하는 이유를 그림으로 표현해 보겠습니다.

```
[객체 생성]  →  [생성자 호출]  →  [초기화된 객체]
   (new)          (자동)         (사용 준비 완료)
```

1. **초기화**: 객체의 초기 상태를 설정합니다.
2. **필수 데이터 보장**: 객체 생성 시 필요한 데이터를 반드시 제공하도록 강제할 수 있습니다.
3. **편의성**: 객체 생성과 동시에 초기화를 수행하여 코드를 간결하게 만듭니다.

## 3.3.3 생성자 구현 예시: 동물원 관리 시스템

우리의 동물원 관리 시스템에서 `Animal` 클래스에 생성자를 추가해 보겠습니다.

```java
public class Animal {
    private String name;  // 동물의 이름
    private int age;      // 동물의 나이
    private String species;  // 동물의 종

    // 기본 생성자
    public Animal() {
        // 아무런 초기화도 하지 않음
        System.out.println("새로운 동물이 생성되었습니다.");
    }

    // 매개변수가 있는 생성자
    public Animal(String name, int age, String species) {
        // 매개변수로 받은 값으로 필드 초기화
        this.name = name;
        setAge(age);  // 기존의 setAge 메서드를 활용하여 유효성 검사
        this.species = species;
        System.out.println(name + "이(가) 동물원에 추가되었습니다.");
    }

    // Getter와 Setter 메서드 (이전과 동일)
    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("Error: 이름은 비워둘 수 없습니다.");
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("Error: 나이는 음수가 될 수 없습니다.");
        }
    }

    public String getSpecies() {
        return species;
    }

    public void setSpecies(String species) {
        this.species = species;
    }
}
```

## 3.3.4 생성자 사용 예시

이제 이 `Animal` 클래스의 생성자를 사용하는 방법을 살펴보겠습니다.

```java
public class ZooManagement {
    public static void main(String[] args) {
        // 기본 생성자를 사용한 객체 생성
        Animal unknownAnimal = new Animal();
        
        // 매개변수가 있는 생성자를 사용한 객체 생성
        Animal lion = new Animal("Simba", 5, "Lion");
        
        // 생성된 객체의 정보 출력
        System.out.println("Unknown Animal - Name: " + unknownAnimal.getName() + 
                           ", Age: " + unknownAnimal.getAge() + 
                           ", Species: " + unknownAnimal.getSpecies());
        
        System.out.println("Lion - Name: " + lion.getName() + 
                           ", Age: " + lion.getAge() + 
                           ", Species: " + lion.getSpecies());
        
        // 기본 생성자로 만든 객체에 나중에 정보 설정
        unknownAnimal.setName("Dumbo");
        unknownAnimal.setAge(3);
        unknownAnimal.setSpecies("Elephant");
        
        System.out.println("Updated Unknown Animal - Name: " + unknownAnimal.getName() + 
                           ", Age: " + unknownAnimal.getAge() + 
                           ", Species: " + unknownAnimal.getSpecies());
    }
}
```

이 코드를 실행하면 다음과 같은 결과가 나옵니다.

```
새로운 동물이 생성되었습니다.
Simba이(가) 동물원에 추가되었습니다.
Unknown Animal - Name: null, Age: 0, Species: null
Lion - Name: Simba, Age: 5, Species: Lion
Updated Unknown Animal - Name: Dumbo, Age: 3, Species: Elephant
```

## 3.3.5 생성자의 장점

1. **객체 초기화 보장**: 객체가 생성될 때 필요한 초기화를 반드시 수행합니다.
2. **코드 간결성**: 객체 생성과 초기화를 한 번에 수행할 수 있습니다.
3. **유연성**: 여러 생성자를 오버로딩하여 다양한 방식의 객체 생성을 지원할 수 있습니다.

## 3.3.6 주의사항

1. **기본 생성자**: 매개변수가 있는 생성자를 정의하면, Java는 기본 생성자를 자동으로 제공하지 않습니다. 필요하다면 명시적으로 정의해야 합니다.
2. **초기화 순서**: 필드 초기화 → 초기화 블록 → 생성자 순으로 실행됩니다.
3. **this 키워드**: 생성자 내에서 `this`를 사용하여 현재 객체의 필드나 메서드를 참조할 수 있습니다.

생성자를 적절히 사용하면 객체의 일관성을 유지하고, 코드의 안정성과 가독성을 높일 수 있습니다. 

객체 지향 프로그래밍에서 생성자는 매우 중요한 개념이므로 잘 이해하고 활용하는 것이 좋습니다.

