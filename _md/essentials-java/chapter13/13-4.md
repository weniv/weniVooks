---
chapter: 객체지향 프로그래밍(OOP) 기초
title: SOLID
date: 2024-08-26
---

# 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

## 1.1 단일 책임 원칙의 정의

단일 책임 원칙은 **"한 클래스는 하나의 책임만 가져야 한다"** 는 원칙입니다.

여기서 '책임'이란 '변경의 이유'로 해석할 수 있습니다. **즉, 클래스를 변경해야 하는 이유는 오직 하나여야 합니다.**

## 1.2 단일 책임 원칙의 주요 특징

1. 클래스의 응집도 향상
2. 코드의 가독성과 유지보수성 증가
3. 변경의 영향 최소화

## 1.3 실생활 예시: 스마트폰

스마트폰을 통해 단일 책임 원칙의 개념을 이해해봅시다.

```
    스마트폰
    +------------------+
    |   전화 기능      |
    |   메시지 기능    |
    |   카메라 기능    |
    |   인터넷 기능    |
    +------------------+
```

이 구조는 단일 책임 원칙을 위반하고 있습니다.

1. 전화 기능에 문제가 생겨도 전체 스마트폰에 영향을 줄 수 있습니다.
2. 카메라 기능을 업그레이드하려면 전체 스마트폰 시스템을 수정해야 할 수 있습니다.



```
    스마트폰
    +------------------+
    |   전화 모듈      |
    +------------------+
    |   메시지 모듈    |
    +------------------+
    |   카메라 모듈    |
    +------------------+
    |   인터넷 모듈    |
    +------------------+
```
단일 책임 원칙을 적용하면 위와 같이 각 기능을 독립적인 모듈로 분리할 수 있습니다.


이렇게 각 기능을 독립적인 모듈로 분리하면 다음과 같은 이점을 얻을 수 있습니다.

1. 각 모듈은 자신의 기능에 대해서만 책임을 집니다.
2. 한 모듈의 변경이 다른 모듈에 영향을 주지 않습니다.
3. 각 모듈을 독립적으로 개선하거나 교체할 수 있습니다.

![](/images/essentials-java/chapter13/OOP13-4-ex1.png)

## 1.4 단일 책임 원칙의 이점

1. **유지보수성 향상**: 각 클래스가 하나의 책임만 가지므로, 수정이 필요할 때 해당 클래스만 변경하면 됩니다.
2. **재사용성 증가**: 작은 단위의 책임을 가진 클래스는 다른 상황에서도 쉽게 재사용될 수 있습니다.
3. **테스트 용이성**: 각 클래스가 단일 책임을 가지므로 해당 책임에 대한 테스트를 집중적으로 할 수 있습니다.

## 1.5 단일 책임 원칙 적용 시 주의점

1. 과도한 분리는 오히려 복잡성을 증가시킬 수 있습니다.
2. '책임'의 범위를 정의하는 것은 상황과 맥락에 따라 달라질 수 있습니다.
3. 시스템의 요구사항 변경에 따라 책임의 분배도 변경될 수 있습니다.

# 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

# 2.1 개방-폐쇄 원칙의 정의

개방-폐쇄 원칙은 "소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다"는 원칙입니다. **즉, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 합니다.**

## 2.2 개방-폐쇄 원칙의 주요 특징

1. 기존 코드의 변경 없이 동작을 확장할 수 있음
2. 새로운 기능 추가가 용이함
3. 유지보수성과 재사용성 향상

## 2.3 실생활 예시: 리모컨

리모컨을 통해 개방-폐쇄 원칙의 개념을 이해해봅시다.

```
    범용 리모컨
    +------------------+
    |   전원 버튼      |
    |   볼륨 조절      |
    |   채널 변경      |
    +------------------+
            |
    +-------+-------+
    |               |
  TV 제어       에어컨 제어
```

1. 범용 리모컨은 기본적인 인터페이스(전원, 볼륨, 채널)를 제공합니다.
2. TV나 에어컨 같은 새로운 기기를 추가할 때, 리모컨의 코드를 변경하지 않고도 제어 기능을 확장할 수 있습니다.
3. 각 기기는 리모컨의 인터페이스를 자신의 방식대로 구현합니다.

![](/images/essentials-java/chapter13/OOP13-4-ex2.png)

## 2.4 개방-폐쇄 원칙의 이점

1. **유연성**: 새로운 기능이나 요구사항이 추가되어도 기존 코드를 변경하지 않아도 됩니다.
2. **재사용성**: 기존의 코드를 그대로 사용하면서 새로운 기능을 추가할 수 있습니다.
3. **유지보수성**: 기존 코드를 변경하지 않으므로 기존 기능에 대한 영향을 최소화할 수 있습니다.

## 2.5 개방-폐쇄 원칙 적용 방법

1. **추상화**: 변경되지 않는 부분을 추상화하여 인터페이스나 추상 클래스로 정의합니다.
2. **다형성**: 추상화된 부분을 구체적인 클래스에서 다양하게 구현합니다.
3. **상속과 컴포지션**: 기존 클래스를 상속하거나 컴포지션을 통해 새로운 기능을 추가합니다.

## 2.6 개방-폐쇄 원칙 적용 시 주의점

1. 모든 경우에 대비한 과도한 추상화는 오히려 복잡성을 증가시킬 수 있습니다.
2. 변경될 가능성이 있는 부분을 예측하여 적절히 추상화해야 합니다.
3. 실제 요구사항과 변경 가능성을 고려하여 적용 범위를 결정해야 합니다.

# 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

## 3.1 리스코프 치환 원칙의 정의

리스코프 치환 원칙은 "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다"는 원칙입니다.

간단히 말해, **부모 클래스의 객체를 자식 클래스의 객체로 치환해도 프로그램의 동작에 문제가 없어야 합니다.**

## 3.2 리스코프 치환 원칙의 주요 특징

1. 타입의 일관성 유지
2. 다형성의 원활한 동작 보장
3. 예측 가능한 프로그램 동작

## 3.3 실생활 예시: 자동차

자동차를 통해 리스코프 치환 원칙의 개념을 이해해봅시다.

```
       자동차
         |
    +----+----+
    |         |
  승용차     트럭
```

이 구조에서 리스코프 치환 원칙을 적용한다면, 다음과 같은 조건을 만족해야 합니다.

1. '자동차' 타입을 사용하는 모든 곳에서 '승용차'나 '트럭'으로 대체해도 문제가 없어야 합니다.
2. 예를 들어, "주차하기" 기능을 사용할 때 자동차.주차하기()' 대신 '승용차.주차하기()' 또는 '트럭.주차하기()'를 사용해도 정상적으로 동작해야 합니다.
3. 단, '트럭'에만 있는 "화물 적재" 같은 특수 기능은 '자동차' 인터페이스에 포함되지 않아야 합니다.

![](/images/essentials-java/chapter13/OOP13-4-ex3.png)

## 3.4 리스코프 치환 원칙의 이점

1. **코드의 유연성**: 상위 타입의 객체를 사용하는 프로그램은 하위 타입의 객체로 쉽게 확장될 수 있습니다.
2. **재사용성 증가**: 상위 클래스를 사용하는 코드를 변경하지 않고도 새로운 하위 클래스를 추가할 수 있습니다.
3. **테스트 용이성**: 상위 클래스의 테스트를 하위 클래스에도 적용할 수 있습니다.

## 3.5 리스코프 치환 원칙 적용 방법

1. **계약에 의한 설계**: 메서드의 사전조건, 사후조건, 불변식을 명확히 정의합니다.
2. **행위 보존**: 하위 클래스는 상위 클래스의 행위를 보존해야 합니다.
3. **예외 처리**: 하위 클래스에서 상위 클래스보다 더 구체적인 예외를 발생시키지 않아야 합니다.

## 3.6 리스코프 치환 원칙 위반의 예

1. **직사각형-정사각형 문제**
    - 직사각형 클래스를 상속받아 정사각형 클래스를 만들면, 가로와 세로를 독립적으로 설정할 수 있는 직사각형의 특성이 정사각형에서는 유지되지 않습니다.
    - 이는 리스코프 치환 원칙을 위반하는 전형적인 예입니다.

2. **제한된 기능**
    - 상위 클래스의 일부 메서드를 하위 클래스에서 지원하지 않고 예외를 발생시키는 경우, 이는 리스코프 치환 원칙을 위반합니다.

## 3.7 리스코프 치환 원칙 적용 시 주의점

1. 상속 관계를 설계할 때 "is-a" 관계를 신중히 고려해야 합니다.
2. 하위 클래스가 상위 클래스의 기능을 제한하거나 변경하지 않도록 주의해야 합니다.
3. 인터페이스 분리 원칙(ISP)과 함께 고려하여 적절한 추상화 수준을 유지해야 합니다.

# 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

## 4.1 인터페이스 분리 원칙의 정의

인터페이스 분리 원칙은 "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다"는 원칙입니다.

즉, 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다는 것을 의미합니다.

## 4.2 인터페이스 분리 원칙의 주요 특징

1. 인터페이스의 단일 책임 보장
2. 불필요한 의존성 제거
3. 유연성과 재사용성 향상

### 6.4.3 실생활 예시: 다기능 프린터

다기능 프린터를 통해 인터페이스 분리 원칙의 개념을 이해해봅시다.

인터페이스 분리 전
```
    다기능 프린터
    +------------------+
    |   인쇄하기       |
    |   스캔하기       |
    |   팩스 보내기    |
    |   복사하기       |
    +------------------+
```

이 구조는 인터페이스 분리 원칙을 위반하고 있습니다. 이는 다음과 같은 문제를 야기할 수 있습니다.
1. 단순 프린터만 필요한 클라이언트도 불필요하게 스캔, 팩스 기능에 의존해야 합니다.
2. 새로운 기능을 추가할 때마다 모든 구현체를 수정해야 할 수 있습니다.

**인터페이스 분리 후**
```
    +----------+    +----------+
    |  프린터  |    |  스캐너  |
    +----------+    +----------+
         |               |
         |   +--------+  |
         +---|  팩스  |--+
             +--------+
                 |
            +----------+
            |  복사기  |
            +----------+
```

이렇게 분리하면 아래와 같은 이점을 얻을 수 있습니다.

1. 각 클라이언트는 필요한 기능만 사용할 수 있습니다.
2. 새로운 기능 추가가 다른 인터페이스에 영향을 주지 않습니다.

![](/images/essentials-java/chapter13/OOP13-4-ex4.png)

## 4.4 인터페이스 분리 원칙의 이점

1. **유연성 증가**: 클라이언트는 필요한 기능만 가진 인터페이스를 사용할 수 있습니다.
2. **유지보수성 향상**: 한 기능의 변경이 다른 기능에 영향을 미치지 않습니다.
3. **재사용성 증가**: 작은 단위의 인터페이스는 다양한 상황에서 재사용될 수 있습니다.

## 4.5 인터페이스 분리 원칙 적용 방법

1. **기능별 인터페이스 분리**: 큰 인터페이스를 작고 특화된 여러 인터페이스로 나눕니다.
2. **클라이언트 요구 분석**: 클라이언트가 실제로 필요로 하는 메서드만 인터페이스에 포함시킵니다.
3. **역할 기반 분리**: 객체가 수행하는 역할에 따라 인터페이스를 분리합니다.

## 4.6 인터페이스 분리 원칙 적용 시 주의점

1. 너무 많은 인터페이스 분리는 오히려 복잡성을 증가시킬 수 있습니다.
2. 인터페이스 간의 관계와 계층 구조를 신중히 설계해야 합니다.
3. 시스템의 전체적인 구조와 의도를 고려하여 적절한 분리 수준을 결정해야 합니다.

## 4.7 인터페이스 분리 원칙과 다른 SOLID 원칙과의 관계

1. **단일 책임 원칙(SRP)과의 관계**: ISP는 인터페이스 수준에서 SRP를 적용한 것으로 볼 수 있습니다.
2. **개방-폐쇄 원칙(OCP)과의 관계**: 잘 분리된 인터페이스는 새로운 기능을 추가할 때 기존 코드의 변경을 최소화합니다.

# 5. 의존관계 역전 원칙 (Dependency Inversion Principle, DIP)

## 5.1 의존관계 역전 원칙의 정의

의존관계 역전 원칙은 "고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다"는 원칙입니다. 

간단히 말해, **구체적인 것이 추상적인 것에 의존해야 한다는 것**을 의미합니다.

## 5.2 의존관계 역전 원칙의 주요 특징

1. 추상화에 의존
2. 구체적인 구현보다는 인터페이스나 추상 클래스에 의존
3. 결합도 감소와 유연성 증가

## 5.3 실생활 예시: 전자제품과 전원

전자제품과 전원을 통해 의존관계 역전 원칙의 개념을 이해해봅시다.

의존관계 역전 전
```
    전자제품
      |
      v
    콘센트
```

이 구조는 의존관계 역전 원칙을 위반하고 있습니다. 이는 다음과 같은 문제를 야기할 수 있습니다.

1. 전자제품이 직접 콘센트에 의존하고 있어, 다른 전원 공급 방식을 사용하기 어렵습니다.
2. 전자제품의 재사용성과 확장성이 제한됩니다.

의존관계 역전 후
```
    전자제품  -->  전원 인터페이스
                       ^
                       |
                 +-----+-----+
                 |           |
               콘센트       배터리
```

이렇게 변경하면 다음과 같은 이점을 얻을 수 있습니다.

1. 전자제품은 구체적인 전원 공급 방식(콘센트, 배터리)이 아닌 추상적인 전원 인터페이스에 의존합니다.
2. 새로운 전원 공급 방식을 쉽게 추가할 수 있습니다.

![](/images/essentials-java/chapter13/OOP13-4-ex5.png)

## 5.4 의존관계 역전 원칙의 이점

1. **유연성 증가**: 구체적인 구현에 의존하지 않으므로 시스템의 결합도가 낮아집니다.
2. **재사용성 향상**: 고수준 모듈이 저수준 모듈에 독립적이므로 다양한 상황에서 재사용될 수 있습니다.
3. **테스트 용이성**: 추상화에 의존하므로 목(mock) 객체 등을 이용한 단위 테스트가 쉬워집니다.

## 5.5 의존관계 역전 원칙 적용 방법

1. **추상화 정의**: 고수준 모듈에서 추상화(인터페이스 또는 추상 클래스)를 정의합니다.
2. **의존성 주입**: 구체적인 구현을 외부에서 주입받도록 설계합니다.
3. **팩토리 패턴 사용**: 객체 생성을 추상화하여 의존성을 관리합니다.

## 5.6 의존관계 역전 원칙 적용 시 주의점

1. 과도한 추상화는 코드를 이해하기 어렵게 만들 수 있습니다.
2. 시스템의 전체적인 구조와 목적을 고려하여 적절한 추상화 수준을 결정해야 합니다.
3. 추상화와 구체 클래스 사이의 관계를 명확히 해야 합니다.

## 5.7 의존관계 역전 원칙과 다른 SOLID 원칙과의 관계

1. **개방-폐쇄 원칙(OCP)과의 관계**: DIP를 적용하면 새로운 구현을 추가할 때 기존 코드를 변경하지 않아도 됩니다.
2. **리스코프 치환 원칙(LSP)과의 관계**: DIP를 통해 정의된 추상화는 LSP를 만족시켜야 합니다.

# 6. SOLID 원칙 연습문제

1. 단일 책임 원칙(SRP)을 가장 잘 설명하는 문장은 무엇인가요?

   1. 클래스는 여러 가지 기능을 수행해야 한다.
   2. 클래스는 오직 하나의 변경 이유만 가져야 한다.
   3. 클래스는 최소한 두 가지 이상의 책임을 가져야 한다.
   4. 클래스의 모든 메서드는 서로 연관되어 있어야 한다.

<details>
<summary>정답 보기</summary>
정답: 클래스는 오직 하나의 변경 이유만 가져야 한다.

설명: 단일 책임 원칙은 한 클래스가 하나의 책임만을 가져야 한다는 것을 의미합니다. 여기서 '책임'은 '변경의 이유'로 해석될 수 있습니다.
</details>

2. 개방-폐쇄 원칙(OCP)에 따르면, 소프트웨어 개체는 어떠해야 하나요?

   1. 수정에는 열려 있고, 확장에는 닫혀 있어야 한다.
   2. 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
   3. 수정과 확장 모두에 닫혀 있어야 한다.
   4. 수정과 확장 모두에 열려 있어야 한다.

<details>
<summary>정답 보기</summary>
정답: 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.

설명: 개방-폐쇄 원칙은 기존의 코드를 변경하지 않으면서(닫혀 있음) 새로운 기능을 추가할 수 있도록(열려 있음) 설계해야 한다는 원칙입니다.
</details>

3. 다음 중 리스코프 치환 원칙(LSP)을 위반하는 가장 일반적인 예는 무엇인가요?

   1. 원-타원 문제
   2. 직사각형-정사각형 문제
   3. 자동차-오토바이 문제
   4. 새-펭귄 문제

<details>
<summary>정답 보기</summary>
정답: 직사각형-정사각형 문제

설명: 직사각형 클래스를 상속받아 정사각형 클래스를 만들 경우, 가로와 세로를 독립적으로 설정할 수 있는 직사각형의 특성이 정사각형에서는 유지되지 않아 LSP를 위반하게 됩니다.
</details>

4. 인터페이스 분리 원칙(ISP)의 주요 목적은 무엇인가요?

   1. 인터페이스를 최대한 크게 만드는 것
   2. 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록 하는 것
   3. 모든 클래스가 동일한 인터페이스를 구현하도록 하는 것
   4. 인터페이스의 메서드 수를 최소화하는 것

<details>
<summary>정답 보기</summary>
정답: 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록 하는 것

설명: ISP는 큰 인터페이스를 더 작고 구체적인 여러 인터페이스로 분리하여, 클라이언트가 실제로 필요한 메서드에만 의존하도록 합니다.
</details>

5. 의존관계 역전 원칙(DIP)에 따르면, 의존성의 방향은 어떻게 되어야 하나요?

   1. 구체화(저수준 모듈)에 의존해야 한다.
   2. 추상화(고수준 모듈)에 의존해야 한다.
   3. 의존성의 방향은 중요하지 않다.
   4. 가능한 한 의존성을 제거해야 한다.

<details>
<summary>정답 보기</summary>
정답: 추상화(고수준 모듈)에 의존해야 한다.

설명: DIP는 고수준 모듈이 저수준 모듈에 직접 의존하지 않고, 둘 다 추상화에 의존해야 한다고 말합니다.
</details>

6. 다음 중 SOLID 원칙을 적용했을 때 얻을 수 있는 이점이 아닌 것은 무엇인가요?

   1. 코드의 재사용성 증가
   2. 유지보수성 향상
   3. 코드의 실행 속도 향상
   4. 시스템의 유연성 증가

<details>
<summary>정답 보기</summary>
정답: 코드의 실행 속도 향상

설명: SOLID 원칙은 주로 코드의 구조와 설계 품질을 개선하는 데 초점을 맞추며, 직접적인 실행 속도 향상과는 관련이 없습니다.
</details>

7. "자동차" 클래스가 "엔진" 클래스를 직접 생성하여 사용하는 것은 어떤 SOLID 원칙을 위반할 가능성이 높은가요?

   1. 단일 책임 원칙(SRP)
   2. 개방-폐쇄 원칙(OCP)
   3. 리스코프 치환 원칙(LSP)
   4. 의존관계 역전 원칙(DIP)

<details>
<summary>정답 보기</summary>
정답: 의존관계 역전 원칙(DIP)

설명: 자동차 클래스가 구체적인 엔진 클래스에 직접 의존하는 것은 DIP를 위반합니다. 대신 엔진 인터페이스에 의존하고, 구체적인 엔진을 외부에서 주입받는 것이 더 좋은 설계입니다.
</details>

8. 다음 중 단일 책임 원칙(SRP)을 가장 잘 따르는 클래스 구조는 무엇인가요?

   1. 사용자 등록, 인증, 프로필 관리를 모두 처리하는 UserManager 클래스
   2. 사용자 인증만을 담당하는 UserAuthenticator 클래스
   3. 데이터베이스 연결, 쿼리 실행, 결과 처리를 모두 수행하는 DatabaseHandler 클래스
   4. 파일 읽기, 쓰기, 삭제, 복사를 모두 처리하는 FileUtil 클래스

<details>
<summary>정답 보기</summary>
정답: 사용자 인증만을 담당하는 UserAuthenticator 클래스

설명: 단일 책임 원칙에 따르면, 클래스는 하나의 책임만을 가져야 합니다. 사용자 인증이라는 단일 책임만을 가진 클래스가 SRP를 가장 잘 따릅니다.
</details>

9. 개방-폐쇄 원칙(OCP)을 적용하기 위한 가장 일반적인 방법은 무엇인가요?

   1. if-else 문을 최대한 많이 사용하기
   2. 모든 메서드를 public으로 선언하기
   3. 추상화와 다형성 사용하기
   4. 모든 클래스를 final로 선언하기

<details>
<summary>정답 보기</summary>
정답: 추상화와 다형성 사용하기

설명: 추상 클래스나 인터페이스를 사용하여 기능을 추상화하고, 이를 구현하는 새로운 클래스를 만들어 기능을 확장하는 것이 OCP를 적용하는 일반적인 방법입니다.
</details>

10. 리스코프 치환 원칙(LSP)에 따르면, 하위 클래스는 상위 클래스의 무엇을 유지해야 하나요?

    1. 이름
    2. 구현 세부사항
    3. 계약(Contract)
    4. private 멤버 변수

<details>
<summary>정답 보기</summary>
정답: 계약(Contract)

설명: LSP에 따르면, 하위 클래스는 상위 클래스의 계약(메서드의 사전조건, 사후조건, 불변식 등)을 위반하지 않아야 합니다.
</details>