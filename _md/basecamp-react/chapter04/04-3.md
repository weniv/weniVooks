---
chapter: Hook
title: useMemo
date: 2024-07-24
---

# 1. useMemo

`useMemo`는 React 컴포넌트의 성능 최적화에 사용되는 훅입니다. 복잡한 연산을 통해 어떤 값을 구해야 하는 상황을 가정해 봅시다. 컴포넌트가 렌더링될 때마다 이러한 복잡한 계산을 수행하면 성능에 부담이 될 수 있습니다.

계산에 사용되는 의존성 값들이 변경되지 않았다면, 동일한 결과를 반복해서 계산할 필요가 없습니다. 이때 메모이제이션(memoization) 기법을 활용할 수 있습니다. 메모이제이션은 한 번 계산한 값을 저장해두었다가 필요할 때마다 재사용하는 최적화 기법입니다. React에서는 이러한 메모이제이션 기능을 제공하는 훅이 바로 useMemo입니다.

useMemo를 사용하면 특정 값들이 변경되었을 때만 계산을 다시 수행하고, 그렇지 않은 경우에는 이전에 계산된 값을 재사용할 수 있습니다. 이를 통해 불필요한 연산을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다.

useMemo의 구조를 살펴보겠습니다. 

```jsx
  const memo = useMemo(() => 저장하려는 값을 계산하는 함수, [바뀌는지 감시할 변수]);
```

첫 번째 인자는 `저장하려는 값을 계산하는 함수`입니다. 이 함수의 반환값이 메모이제이션되어 저장됩니다. 두 번째 인자는 `의존성 배열`입니다. 이 배열에 포함된 값들의 변화를 React가 감지합니다.

## 1.1 useMemo 동작 방식

컴포넌트가 처음 화면에 보여질 때, useMemo는 첫 번째 인자로 전달된 계산 함수를 실행합니다. 계산된 결과는 저장하고 반환됩니다.

의존성 배열에 값이 있다면 컴포넌트가 리렌더링될 때마다 React는 의존성 배열의 모든 값을 이전 렌더링 값과 비교합니다. 만약 의존성 배열 속 어떤 값이라도 변경되었다면 계산 함수를 실행합니다. 새로 계산된 결과를 저장하고 반환합니다. 의존성 배열의 모든 값이 이전과 같다면, 저장된 이전 값을 반환합니다.

의존성 배열이 생략된 경우 렌더링이 일어날 때마다 계산 함수를 실행하고 새 값을 저장하고 반환합니다. 이 경우는 메모이제이션의 이점을 얻지 못합니다.

의존성 배열이 비어있는 경우 초기 렌더링 시에만 한 번 계산 함수를 실행하고 그 결과를 저장합니다. 이후의 모든 렌더링에서는 항상 이 초기값을 재사용합니다.

useMemo로 저장한 값은 컴포넌트가 화면에서 완전히 사라질 때 자동으로 메모리에서 정리됩니다. React가 이 값을 직접 지우는 것은 아니지만, 컴포넌트가 없어지면 저장된 값도 더 이상 필요 없게 되어 자연스럽게 메모리에서 사라집니다.

## 1.2 간단한 예시

부하가 발생하는 코드를 사용하여 간단한 예시를 살펴보겠습니다. useMemo를 사용하였을 때와 사용하지 않았을 때 어떤 차이가 있는지 확인해보겠습니다.

`App.jsx`

```jsx
import { useState } from 'react'

function load(){
    let s = 0
    for (let i = 0; i < 1000000000; i++) {
        s += i
    }
    return s
}

function App() {
    const [count, setCount] = useState(0)
    let result = load()

    const handleCountUp = (e) => {
        setCount(prevCount =>prevCount + 1)
        // 업데이트 전의 count 값을 보여줍니다.
        console.log(count)
    }

    return (
        <div>
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
        </div>
    );
}
export default App;
```

load 함수는 1000000000번의 많은 덧셈 계산을 하고 결과를 반환하는 복잡한 함수입니다. 이 예시에서는 useMemo를 사용하지 않았기 때문에, 컴포넌트가 리렌더링될 때마다 load 함수가 실행됩니다. 즉, 'UP!' 버튼을 클릭하여 count 상태가 변경될 때마다 불필요하게 load 함수가 다시 실행되어 성능에 부담을 줄 수 있습니다.

useMemo를 사용하여 성능을 최적화해보겠습니다. 