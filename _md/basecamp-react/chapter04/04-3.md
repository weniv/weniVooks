---
chapter: Hook
title: useMemo
date: 2024-07-24
---

# 1. useMemo

`useMemo`는 React 컴포넌트의 성능 최적화에 사용되는 훅입니다. 복잡한 연산을 통해 어떤 값을 구해야 하는 상황을 가정해 봅시다. 컴포넌트가 렌더링될 때마다 이러한 복잡한 계산을 수행하면 성능에 부담이 될 수 있습니다.

계산에 사용되는 의존성 값들이 변경되지 않았다면, 동일한 결과를 반복해서 계산할 필요가 없습니다. 이때 메모이제이션(memoization) 기법을 활용할 수 있습니다. 메모이제이션은 한 번 계산한 값을 저장해두었다가 필요할 때마다 재사용하는 최적화 기법입니다. React에서는 이러한 메모이제이션 기능을 제공하는 훅이 바로 useMemo입니다.

useMemo를 사용하면 특정 값들이 변경되었을 때만 계산을 다시 수행하고, 그렇지 않은 경우에는 이전에 계산된 값을 재사용할 수 있습니다. 이를 통해 불필요한 연산을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다.

useMemo의 구조를 살펴보겠습니다. 

```jsx
const memo = useMemo(() => 저장하려는 값을 계산하는 함수, [바뀌는지 감시할 변수]);
  
// 예
const memo = useMemo(() => add(a, b), [a, b]);
```
첫 번째 인자는 `값을 계산하는 함수`입니다. 이 함수가 계산하고 반환한 값은 메모이제이션되어 저장되고 재사용됩니다. 두 번째 인자는 `의존성 배열`입니다. 이 배열에 포함된 값들의 변화를 React가 감지합니다.

## 1.1 useMemo 동작 방식

컴포넌트가 처음 렌더링될 때, useMemo는 첫 번째 인자로 전달된 계산 함수를 실행합니다. 계산된 결과는 반환되고 저장됩니다.

의존성 배열에 값이 있다면, 컴포넌트 내 state나 props가 변경되어 컴포넌트가 리렌더링될 때마다 React는 의존성 배열의 모든 값을 이전 렌더링 값과 비교합니다. 만약 의존성 배열 속 어떤 값이라도 변경되었다면 계산 함수를 실행합니다. 새로 계산된 결과를 저장하고 반환합니다. 의존성 배열의 모든 값이 이전과 같다면, 저장된 이전 값을 반환합니다.

의존성 배열이 생략된 경우, 렌더링이 일어날 때마다 계산 함수를 실행하고 새 값을 저장하고 반환합니다. 이 경우는 메모이제이션의 이점을 얻지 못합니다.

의존성 배열이 비어있는 경우, 초기 렌더링 시에만 한 번 계산 함수를 실행하고 그 결과를 저장합니다. 이후의 모든 렌더링에서는 항상 이 초기값을 재사용합니다.

useMemo로 저장한 값은 컴포넌트가 화면에서 완전히 사라질 때 자동으로 메모리에서 정리됩니다. React가 이 값을 직접 지우는 것은 아니지만, 컴포넌트가 없어지면 저장된 값도 더 이상 필요 없게 되어 자연스럽게 메모리에서 사라집니다.

## 1.2 간단한 예시

useMemo를 사용했을 때와 사용하지 않았을 때의 차이를 간단한 예시를 통해 살펴보겠습니다. 부하가 발생하는 코드를 사용하여 그 차이를 확인해보겠습니다.

`App.css`

```css
.app-container{
  padding: 20px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 15px;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  margin: 10px 0 20px 0;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}
```

`App.jsx`

```jsx
import { useState } from 'react'
import './App.css'

function load(){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    let result = load()

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    return (
        <div>
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
        </div>
    );
}
export default App;
```

`load` 함수는 10억 번의 덧셈 계산을 수행하는 복잡한 함수입니다. 이 예시에서는 useMemo를 사용하지 않았기 때문에, 컴포넌트가 리렌더링될 때마다 `load` 함수가 실행됩니다. 즉, 버튼을 클릭하여 count 상태가 변경될 때마다 불필요하게 `load` 함수가 다시 실행되어 부하가 발생해 성능에 부담을 줄 수 있습니다. 페이지에 접속해 확인해보면, 버튼을 누를 때마다 복잡한 계산이 실행되기 때문에 업데이트된 count 값이 화면에 반영되는 데 시간이 오래 걸립니다.

이제 useMemo를 사용하여 성능을 최적화해보겠습니다.

`App.jsx` 

```jsx
import { useMemo, useState } from 'react'
import './App.css'

function load(){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    const result = useMemo(() => load(), [])

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    return (
        <div className="app-container">
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
        </div>
    );
}

export default App;
```

useMemo의 첫 번째 인자로 복잡한 계산을 수행하는 `load` 함수를 전달하고, 두 번째 인자로 빈 배열을 전달합니다. 이렇게 하면 초기 렌더링 시에만 한 번 계산 함수를 실행하고 그 결과를 저장합니다. 따라서 처음 계산된 결과가 메모이제이션되어, 이후 버튼을 클릭하여 count 상태가 변경되더라도 `load` 함수는 다시 실행되지 않습니다.

이렇게 최적화된 버전에서는 버튼을 클릭할 때마다 복잡한 계산이 매번 다시 실행되지 않기 때문에 count 값이 즉시 업데이트되는 것을 확인할 수 있습니다.

특정 변수가 변할 때마다 load 함수를 실행하도록 해보겠습니다. 특정 변수는 load 함수 내에서 10억번 더해지는 값으로 사용됩니다.

```jsx
import { useMemo, useState } from 'react'
import './App.css'

function load(num){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += num
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    const [countTwo, setCountTwo] = useState(0)
    
    const result = useMemo(() => load(countTwo), [countTwo])

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    const handleCountUpTwo = () => {
        setCountTwo(prevCountTwo => prevCountTwo+ 1)
        // 업데이트 전의 countTwo 값을 출력합니다.
        console.log(countTwo)
    }

    return (
        <div className="app-container">
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
            <div>{countTwo}</div>
            <button onClick={handleCountUpTwo}>Up!</button>
        </div>
    );
}

export default App;
```

useMemo의 두 번째 인자로 전달된 `countTwo`는 useState의 state로 선언되었습니다. 두 번째 버튼을 클릭할 때마다 countTwo가 1씩 증가합니다. React가 countTwo의 변화를 감지하면 `load` 함수를 다시 실행해 새로운 결과를 반환하고 저장합니다. 그러면 countTwo를 10억 번 더한 결과값이 화면에 표시됩니다. 첫 번째 버튼을 누르면 증가하는 count의 값이 바로 반영되지만, 두 번째 버튼을 누를 때마다 load 함수가 실행돼 부하가 생기면서 countTwo의 값과 계산 결과가 화면에 반영되는 것을 확인할 수 있습니다.

::img{width="300" alt="useMemo를 활용한 계산 함수 실행 결과" src="/images/basecamp-react/chapter04-3/chapter04-3-1.png"}