---
chapter: Hook
title: useMemo
date: 2024-07-24
---

# 1. useMemo

`useMemo`는 React 컴포넌트의 성능 최적화에 사용되는 훅입니다. 복잡한 연산을 통해 어떤 값을 구해야 하는 상황을 가정해 봅시다. 컴포넌트가 렌더링될 때마다 이러한 복잡한 계산을 수행하면 성능에 부담이 될 수 있습니다.

계산에 사용되는 의존성 값들이 변경되지 않았다면, 동일한 결과를 반복해서 계산할 필요가 없습니다. 이때 메모이제이션(memoization) 기법을 활용할 수 있습니다. 메모이제이션은 한 번 계산한 값을 저장해두었다가 필요할 때마다 재사용하는 최적화 기법입니다. React에서는 이러한 메모이제이션 기능을 제공하는 훅이 바로 useMemo입니다.

useMemo를 사용하면 특정 값들이 변경되었을 때만 계산을 다시 수행하고, 그렇지 않은 경우에는 이전에 계산된 값을 재사용할 수 있습니다. 이를 통해 불필요한 연산을 줄이고 애플리케이션의 전반적인 성능을 향상시킬 수 있습니다.

useMemo의 구조를 살펴보겠습니다. 

```jsx
const memo = useMemo(() => 저장하려는 값을 계산하는 함수, [바뀌는지 감시할 변수]);
  
// 예
const memo = useMemo(() => add(a, b), [a, b]);
```
첫 번째 인자는 `값을 계산하는 함수`입니다. 이 함수가 계산하고 반환한 값은 메모이제이션되어 저장되고 재사용됩니다. 두 번째 인자는 `의존성 배열`입니다. 이 배열에 포함된 값들의 변화를 React가 감지합니다.

## 1.1 useMemo 동작 방식

컴포넌트가 처음 렌더링될 때, useMemo는 첫 번째 인자로 전달된 계산 함수를 실행합니다. 계산된 결과는 반환되고 저장됩니다.

의존성 배열에 값이 있다면, 컴포넌트 내 state나 props가 변경되어 컴포넌트가 리렌더링될 때마다 React는 의존성 배열의 모든 값을 이전 렌더링 값과 비교합니다. 만약 의존성 배열 속 어떤 값이라도 변경되었다면 계산 함수를 실행합니다. 새로 계산된 결과를 저장하고 반환합니다. 의존성 배열의 모든 값이 이전과 같다면, 저장된 이전 값을 반환합니다. useMemo의 의존성 배열 검사, 계산 함수 실행, 값의 저장 및 반환은 모두 `렌더링 과정 중`에 일어납니다.

의존성 배열이 생략된 경우, 렌더링이 일어날 때마다 계산 함수를 실행하고 새 값을 저장하고 반환합니다. 이 경우는 메모이제이션의 이점을 얻지 못합니다.

의존성 배열이 비어있는 경우, 초기 렌더링 시에만 한 번 계산 함수를 실행하고 그 결과를 저장합니다. 이후의 모든 렌더링에서는 항상 이 초기값을 재사용합니다.

useMemo로 저장한 값은 컴포넌트가 화면에서 완전히 사라질 때 자동으로 메모리에서 정리됩니다. React가 이 값을 직접 지우는 것은 아니지만, 컴포넌트가 없어지면 저장된 값도 더 이상 필요 없게 되어 자연스럽게 메모리에서 사라집니다.

## 1.2 간단한 예시

useMemo를 사용했을 때와 사용하지 않았을 때의 차이를 간단한 예시를 통해 살펴보겠습니다. 부하가 발생하는 코드를 사용하여 그 차이를 확인해보겠습니다.

`App.css`

```css
.app-container{
  padding: 20px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 15px;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  margin: 10px 0 20px 0;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}
```

`App.jsx`

```jsx
import { useState } from 'react'
import './App.css'

function load(){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    let result = load()

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    return (
        <div>
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
        </div>
    );
}
export default App;
```

`load` 함수는 10억 번의 덧셈 계산을 수행하는 복잡한 함수입니다. 이 예시에서는 useMemo를 사용하지 않았기 때문에, 컴포넌트가 리렌더링될 때마다 `load` 함수가 실행됩니다. 즉, 버튼을 클릭하여 count 상태가 변경될 때마다 불필요하게 `load` 함수가 다시 실행되어 부하가 발생해 성능에 부담을 줄 수 있습니다. 페이지에 접속해 확인해보면, 버튼을 누를 때마다 복잡한 계산이 실행되기 때문에 업데이트된 count 값이 화면에 반영되는 데 시간이 오래 걸립니다.

이제 useMemo를 사용하여 성능을 최적화해보겠습니다.

`App.jsx` 

```jsx
import { useMemo, useState } from 'react'
import './App.css'

function load(){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    const result = useMemo(() => load(), [])

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    return (
        <div className="app-container">
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
        </div>
    );
}

export default App;
```

useMemo의 첫 번째 인자로 복잡한 계산을 수행하는 `load` 함수를 전달하고, 두 번째 인자로 빈 배열을 전달합니다. 이렇게 하면 초기 렌더링 시에만 한 번 계산 함수를 실행하고 그 결과를 저장합니다. 따라서 처음 계산된 결과가 메모이제이션되어, 이후 버튼을 클릭하여 count 상태가 변경되더라도 `load` 함수는 다시 실행되지 않습니다.

이렇게 최적화된 버전에서는 버튼을 클릭할 때마다 복잡한 계산이 매번 다시 실행되지 않기 때문에 count 값이 즉시 업데이트되는 것을 확인할 수 있습니다.

특정 변수가 변할 때마다 load 함수를 실행하도록 해보겠습니다. 특정 변수는 load 함수 내에서 10억번 더해지는 값으로 사용됩니다.

```jsx
import { useMemo, useState } from 'react'
import './App.css'

function load(num){
    let sum = 0
    for (let i = 0; i < 1000000000; i++) {
        sum += num
    }
    return sum
}

function App() {
    const [count, setCount] = useState(0)
    const [countTwo, setCountTwo] = useState(0)
    
    const result = useMemo(() => load(countTwo), [countTwo])

    const handleCountUp = () => {
        setCount(prevCount => prevCount + 1)
        // 업데이트 전의 count 값을 출력합니다.
        console.log(count)
    }

    const handleCountUpTwo = () => {
        setCountTwo(prevCountTwo => prevCountTwo+ 1)
        // 업데이트 전의 countTwo 값을 출력합니다.
        console.log(countTwo)
    }

    return (
        <div className="app-container">
            <h1>계산 결과 : {result}</h1>
            <div>{count}</div>
            <button onClick={handleCountUp}>UP!</button>
            <div>{countTwo}</div>
            <button onClick={handleCountUpTwo}>Up!</button>
        </div>
    );
}

export default App;
```

useMemo의 두 번째 인자로 전달된 `countTwo`는 useState의 state로 선언되었습니다. 두 번째 버튼을 클릭할 때마다 countTwo가 1씩 증가합니다. React가 countTwo의 변화를 감지하면 `load` 함수를 다시 실행해 새로운 결과를 반환하고 저장합니다. 그러면 countTwo를 10억 번 더한 결과값이 화면에 표시됩니다. 첫 번째 버튼을 누르면 증가하는 count의 값이 바로 반영되지만, 두 번째 버튼을 누를 때마다 load 함수가 실행돼 부하가 생기면서 countTwo의 값과 계산 결과가 화면에 반영되는 것을 확인할 수 있습니다.

::img{width="300" alt="useMemo를 활용한 계산 함수 실행 결과" src="/images/basecamp-react/chapter04-3/chapter04-3-1.png"}

# 2. useMemo 사용 예시

useMemo는 주로 다음과 같은 상황에서 사용됩니다.

1. 복잡하거나 시간이 오래 걸리는 계산의 결과를 재사용하여 성능을 최적화할 때 사용합니다.
2. 불필요한 컴포넌트 리렌더링을 방지할 때 사용합니다. 이는 주로 React.memo와 함께 활용됩니다.
3. 대규모 리스트의 정렬 및 필터링 연산을 최적화 해야 할 때 사용합니다.

즉, useMemo는 계산된 값을 메모이제이션(memoization)하여 불필요한 재계산이나 리렌더링을 방지함으로써 애플리케이션의 성능을 최적화하는 데 사용됩니다.

## 2.1 연산 최적화 예제

복잡한 계산의 결과를 저장하고 필요할 때 다시 재사용하여 연산을 최적화하는 예시를 살펴보겠습니다. 이 예제는 useMemo의 기본 사용법과 원리를 보여주기 위한 것입니다. 실제 애플리케이션에서는 더 복잡하고 계산 비용이 높은 연산에 useMemo를 적용하면 더 큰 성능 이점을 얻을 수 있습니다.

이름과 아이디를 입력받아 회원 목록과 등록된 회원 수를 화면에 보여주는 코드를 작성합니다. 먼저 useMemo를 사용하지 않았을 때 어떤 일이 일어나는지 확인해보겠습니다.

`src/App.css`

```css
.app-container {
  height: 100vh;
  padding: 20px;
}

input {
  border: 1px solid black;
  border-radius: 5px;
  padding: 10px;
  margin-right: 5px;
  margin-bottom: 10px;
}

button {
  background-color: #4CAF50;
  color: white;
  text-align: center;
  font-size: 15px;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  cursor: pointer;
}

button:hover {
  background-color: #39883c;
}

ul {
  list-style-type: none;
}

li {
  background-color: #f0f0f0;
  border-radius: 5px;
  margin-bottom: 10px;
  padding: 10px;
}

h3, strong {
  margin: 5px 0;
}
```

`src/App.jsx`

```jsx
import React, { useRef, useState } from 'react'
import './App.css'

function App() {
    const nameRef = useRef(null)
    const idRef = useRef(null)
    const [userInfo, setUserInfo] = useState([])
    const [name, setName] = useState('')
    const [id, setId] = useState('')

    function handleInputName(e) {
        setName(e.target.value)
        console.log('렌더링 - 이름 입력')
    }

    function handleInputId(e) {
        setId(e.target.value)
        console.log('렌더링 - 아이디 입력')
    }

    function handleSubmit(e) {
        e.preventDefault()
        const newInfo = [...userInfo, { name, id }]
        setUserInfo(newInfo)
        nameRef.current.value = ''
        idRef.current.value = ''
        nameRef.current.focus()
        console.log('렌더링 - 제출')
    }

    // 렌더링이 발생할 때마다 호출되어 실행됩니다.
    function getNum(list) {
        console.log('렌더링!')
        return list.length
    }

    return (
        <div className="app-container">
            <form onSubmit={handleSubmit}>
                <input
                    type='text'
                    placeholder='이름을 입력하세요'
                    onChange={handleInputName}
                    ref={nameRef}
                />
                <input
                    type='text'
                    placeholder='아이디를 입력하세요'
                    onChange={handleInputId}
                    ref={idRef}
                />
                <button type='submit'>회원 등록</button>
            </form>
            {/* getNum 함수를 매 렌더링마다 호출해 실행하고, 결과가 화면에 표시됩니다. */}
            <span>현재 회원 수: {getNum(userInfo)}</span>
            <ul>
                {userInfo.map((value, index) => (
                    <li key={index}>
                        <h3>이름: {value.name}</h3>
                        <strong>아이디: {value.id}</strong>
                    </li>
                ))}
            </ul>
        </div>
    )
}

export default App;
```

이 예제에서는 이름과 아이디를 입력하는 input 요소를 가리키는 ref 객체로 `nameRef`와 `idRef`를 선언했습니다. 입력한 이름과 아이디를 저장하는 `name`, `id` state 변수를 useState로 선언했습니다. 또한, name과 id 값을 객체로 만들어 유저 정보를 담는 배열인 `userInfo` state 변수도 생성했습니다.

이름과 아이디를 입력하고 회원 등록 버튼을 클릭하면 현재 회원 수가 증가하면서 현재 회원 수 문구 아래에 추가된 회원의 정보가 표시됩니다. 현재 회원 수를 화면에 표시하기 위해 `getNum` 함수가 호출되어 실행되고 그 결과가 화면에 표시됩니다.

:::div{.beforeAfter}
| 입력 전 화면 | 등록 후 화면 |
| ------------------------------------------ | ------------------------------------------ |
| ![이름과 이메일 입력 전 화면](/images/basecamp-react/chapter04-3/chapter04-3-2.png) | ![회원 등록 화면](/images/basecamp-react/chapter04-3/chapter04-3-3.png) |
:::

컴포넌트 내 state가 바뀌면 렌더링이 발생합니다. 현재 코드에서 값이 변하는 경우는 3가지입니다: 이름을 입력하여 setName 함수가 실행될 때, 아이디를 입력하여 setId 함수가 실행될 때, 그리고 회원 등록 버튼을 눌러 setUserInfo 함수가 실행될 때입니다.

콘솔창을 열어 getNum 함수가 언제 실행되는지 확인해보면, 이름과 아이디를 입력할 때마다 `렌더링!` 문구가 출력됩니다. 버튼을 클릭하지 않으면 회원 목록에 추가되지 않기 때문에 getNum 함수가 실행될 필요가 없습니다. 그러나 현재는 이름이나 아이디를 입력하는 것만으로도 getNum 함수가 실행됩니다.

::img{width="350" alt="콘솔창을 통한 getNum 함수 실행 시점 확인" src="/images/basecamp-react/chapter04-3/chapter04-3-4.png"}

이러한 불필요한 연산을 막기 위해 useMemo를 사용해봅시다.

이름과 아이디를 입력하고 버튼을 눌러야만 userInfo 값이 바뀝니다. userInfo의 값이 바뀔 때에만 getNum 함수를 실행해야 하므로, useMemo 훅의 의존성 배열에 userInfo를 전달해줍니다.

```jsx
const num = useMemo(() => getNum(userInfo), [userInfo]);
```

`App.jsx`

```jsx
import React, { useMemo, useRef, useState } from 'react'
import './App.css'

function App() {
    const nameRef = useRef(null)
    const idRef = useRef(null)
    const [userInfo, setUserInfo] = useState([])
    const [name, setName] = useState('')
    const [id, setId] = useState('')
    const num = useMemo(() => getNum(userInfo), [userInfo])

    function handleInputName(e) {
        setName(e.target.value)
        console.log('렌더링 - 이름 입력')
    }

    function handleInputId(e) {
        setId(e.target.value)
        console.log('렌더링 - 아이디 입력')
    }

    function handleSubmit(e) {
        e.preventDefault()
        const newInfo = [...userInfo, { name, id }]
        setUserInfo(newInfo)
        nameRef.current.value = ''
        idRef.current.value = ''
        nameRef.current.focus()
        console.log('렌더링 - 제출')
    }

    // 컴포넌트가 처음 렌더링될 때와 userInfo 값이 변경될 때만 실행됩니다.
    function getNum(list) {
        console.log('렌더링!')
        return list.length
    }

    return (
        <div className="app-container">
            <form onSubmit={handleSubmit}>
                <input
                    type='text'
                    placeholder='이름을 입력하세요'
                    onChange={handleInputName}
                    ref={nameRef}
                />
                <input
                    type='text'
                    placeholder='아이디를 입력하세요'
                    onChange={handleInputId}
                    ref={idRef}
                />
                <button type='submit'>회원 등록</button>
            </form>
            {/* getNum 함수를 매 렌더링마다 호출해 실행하고, 결과가 화면에 표시됩니다. */}
            <span>현재 회원 수: {num}</span>
            <ul>
                {userInfo.map((value, index) => (
                    <li key={index}>
                        <h3>이름: {value.name}</h3>
                        <strong>아이디: {value.id}</strong>
                    </li>
                ))}
            </ul>
        </div>
    )
}
```

`useMemo`를 사용한 후, getNum 함수는 컴포넌트가 처음 렌더링될 때와 userInfo 값이 바뀔 때만 실행됩니다. userInfo 값이 변하지 않았다면, 다른 state의 값이 바뀌어 컴포넌트가 다시 렌더링되어도 getNum 함수는 재실행되지 않고 이전에 저장했던 계산 결과를 재사용합니다.

콘솔창을 열어 getNum 함수가 언제 실행되는지 확인해보세요. 이제는 회원 등록 버튼을 클릭할 때만 '렌더링!' 메시지가 출력되는 것을 확인할 수 있습니다.
이러한 방식으로 useMemo를 사용하면, 불필요한 계산을 줄이고 애플리케이션의 성능을 향상시킬 수 있습니다.

::img{width="350" alt="useMemo를 사용하여 콘솔창을 통한 getNum 함수 실행 시점 확인" src="/images/basecamp-react/chapter04-3/chapter04-3-5.png"}


## 2.2 불필요한 리렌더링 방지 예제
