---
chapter: Hooks
title: useEffect
date: 2024-07-09
---

# 1. useEffect

useEffect의 구조를 살펴보겠습니다.

```jsx
useEffect(() => {
    /* 실행할 코드 */
    return() => {
        /* 정리 작업 코드*/
    }
}, [/* 감시할 변수 */]);
```

useEffect 훅은 두 개의 파라미터를 받습니다. 첫 번째 파라미터는 `실행할 함수(Effect)`이고, 이 함수는 컴포넌트가 렌더링된 후에 실행됩니다. 두 번째 파라미터는 `의존성 배열`이라고 부르는 값들의 목록입니다. 쉽게 말해, 값이 바뀌는지 감시할 변수들을 담은 배열입니다. 의존성 배열에 있는 변수의 값이 변하면 useEffect는 이를 감지하여 첫 번째 파라미터로 전달된 함수를 실행합니다. 

useEffect의 첫 번째 함수 안에서 또 다른 함수를 반환할 수 있는데, 이를 `정리(cleanup) 함수`라고 부릅니다. 변수의 값이 변해 다시 렌더링을 하기 전에 컴포넌트를 지우는 과정이 필요합니다. 이때 컴포넌트를 지우기 전에 정리 함수가 실행됩니다. 주로 이전에 설정한 것들을 정리하는 용도로 사용합니다.

useEffect는 주로 컴포넌트의 생명주기에 맞춰 어떤 일을 하거나, 외부에서 정보를 가져오는 등의 부수 효과(side effects)를 관리하는 데 사용합니다. useEffect를 사용하면 컴포넌트가 생성되고, 업데이트되고, 제거되는 전체 과정을 잘 관리할 수 있습니다.

## 1.1 useEffect의 형태

useEffect의 다양한 형태를 살펴보겠습니다.

```jsx
// 1. 컴포넌트가 렌더링 될 때마다 실행되는 형태
useEffect(() => {
		console.log('hello world');
})

// 2. 첫 렌더링에만 실행되는 형태
useEffect(() => {
		console.log('hello world');
}, [])

// 3. 변수 값의 변화가 발생하면 실행되는 형태
useEffect(() => {
		console.log('hello world');
}, [변수1, 변수2, ...])
```

1번 형태는 의존성 배열이 없습니다. 따라서 의존성 배열 속 변수 값의 변화와는 연관이 없고 컴포넌트가 처음 렌더링됐을 때와 매 렌더링 시마다 실행됩니다. 컴포넌트의 모든 변화에 반응하여 함수를 실행하기 때문에 컴포넌트의 모든 변화를 알고 싶을 때 유용합니다. 하지만 불필요한 함수 실행이 발생할 수 있고, 함수 내에서 state를 업데이트하는 경우 무한 루프가 발생할 수 있으므로 주의해야 합니다. 따라서 의존성 배열을 사용하는 것이 좋습니다.

2번 형태는 두 번째 파라미터로 빈 배열로 주어집니다. 1번 형태처럼 의존성 배열 속 변수 값의 변화와는 연관이 없습니다. 함수는 컴포넌트가 처음 마운트될 때에만 실행됩니다. 이후에 컴포넌트가 다시 렌더링되어도 실행되지 않습니다. 이 형태는 컴포넌트가 처음 렌더링될 때 한 번만 실행해야 하는 로직에 적합합니다.

3번 형태는 의존성 배열 속 변수들 중 하나라도 값이 변경되면 함수를 실행합니다. 물론 컴포넌트가 처음 렌더링될 때에도 실행됩니다. 특정 state나 props의 변화를 감지해 반응해야 할 때 유용합니다. 예를 들면, 검색어를 state로 관리하여 검색어가 변경될 때마다 해당하는 검색 결과를 가져오는 로직에 사용할 수 있습니다. 의존성 배열에 포함된 변수의 값이 변하지 않으면 함수가 실행되지 않기 때문에 불필요한 함수 실행을 방지하여 성능을 최적화할 수 있습니다.

# 2. 간단한 카운터 만들기

useState를 사용해 간단한 카운터를 만들어보겠습니다. 먼저 src 폴더 내에 components 폴더를 만들고, 그 안에 Counter.jsx 파일을 생성해주세요.

`components/Counter.jsx`
```jsx
import { useState } from "react";

function Counter () {
    const [count, setCount] = useState(0)
    const handleCountUp = (e) => {
        setCount(prevCount => prevCount + 1)
    }

    return (
        <>
            <div>{count}</div>
            <button onClick={handleCountUp}>Count Up!</button>
        </>
    )
}

export default Counter;
```

`App.jsx`
```jsx
import Counter from "./components/Counter";

function App() {
    return (
        <div className="App">
            <Counter />
        </div>
    );
}

export default App;
```

useState 훅을 사용하여 초기값이 0인 count라는 상태 변수를 생성하였습니다. handleCountUp 함수는 버튼을 클릭할 때 호출되는데, 이 함수는 실행되면 setCount 함수를 사용해 count의 값을 1 증가시킵니다. count의 값이 변경되면 React는 자동으로 컴포넌트를 다시 렌더링하여 화면의 카운터 값을 업데이트합니다.

## 2.1 짝수 홀수 판별

state인 count의 값이 변할 때마다 해당 값이 짝수인지 홀수인지를 알려주는 기능을 추가해보겠습니다. 

`components/Counter.jsx`
```jsx
import { useEffect, useState } from "react";

function Counter () {
    const [count, setCount] = useState(0)
    const [number, setNumber] = useState("");
    const handleCountUp = (e) => {
        setCount(prevCount => prevCount + 1)
    }

    useEffect(() => {
        console.log('컴포넌트 렌더링');
    }, );

    useEffect(() => {
        console.log('컴포넌트 첫 렌더링');
    }, [])

    useEffect(() => {
        if(count % 2 === 0) {
            setNumber('홀수');
        } else {
            setNumber('짝수');
        }
        console.log('count 값이 변함');
    }, [count])

    return (
        <>
            <div>{count}</div>
            <button onClick={handleCountUp}>Up!</button>
            <div>{number}입니다.</div>
        </>
    )
}

export default Counter;
```

number라는 새로운 state를 생성하였고 초기값은 빈 문자열('')입니다. count의 값이 변할 때마다 useEffect가 실행되어 짝수인지 홀수인지 검사하고, 그 결과에 따라 number 상태를 업데이트합니다.
컴포넌트가 처음 렌더링될 때 count의 초기값은 0이므로, number는 '짝수'로 설정되어 화면에 '짝수입니다'라는 문구가 표시됩니다.