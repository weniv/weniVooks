---
chapter: Hook
title: useEffect
date: 2024-07-09
---

# 1. useEffect

useEffect는 주로 컴포넌트의 생명주기에 맞춰 어떤 일을 하거나, 외부에서 정보를 가져오는 등의 부수 효과(side effects)를 관리하는 데 사용합니다. useEffect를 사용하면 컴포넌트가 생성되고, 업데이트되고, 제거되는 전체 과정을 잘 관리할 수 있습니다.

useEffect의 구조를 살펴보겠습니다.

```jsx
useEffect(() => {
    /* 실행할 코드 */
    return() => {
        /* 정리 작업 코드*/
    }
}, [/* 감시할 변수 */]);
```

useEffect 훅은 두 개의 파라미터를 받습니다. 첫 번째 파라미터는 `실행할 함수(Effect)`이고, 이 함수는 컴포넌트가 렌더링된 후에 실행됩니다. 두 번째 파라미터는 `의존성 배열`이라고 부르는 값들의 목록입니다. 쉽게 말해, 값이 바뀌는지 감시할 변수들을 담은 배열입니다. 의존성 배열에 있는 변수의 값이 변하면 useEffect는 이를 감지하여 첫 번째 파라미터로 전달된 함수를 실행합니다. 

useEffect의 첫 번째 함수 안에서 또 다른 함수를 반환할 수 있는데, 이를 `정리(cleanup) 함수`라고 부릅니다. 변수의 값이 변해 다시 렌더링을 하기 전에 컴포넌트를 지우는 과정이 필요합니다. 이때 컴포넌트를 지우기 전에 정리 함수가 실행됩니다. 주로 이전에 설정한 것들을 정리하는 용도로 사용합니다.


## 1.1 useEffect의 형태

useEffect의 다양한 형태를 살펴보겠습니다.

```jsx
// 1. 컴포넌트가 렌더링 될 때마다 실행되는 형태
useEffect(() => {
		console.log('hello world');
})

// 2. 첫 렌더링에만 실행되는 형태
useEffect(() => {
		console.log('hello world');
}, [])

// 3. 변수 값의 변화가 발생하면 실행되는 형태
useEffect(() => {
		console.log('hello world');
}, [변수1, 변수2, ...])
```

1번 형태는 의존성 배열이 없습니다. 따라서 의존성 배열 속 변수 값의 변화와는 연관이 없고 컴포넌트가 처음 렌더링됐을 때와 매 렌더링 시마다 실행됩니다. 컴포넌트의 모든 변화에 반응하여 함수를 실행하기 때문에 컴포넌트의 모든 변화를 알고 싶을 때 유용합니다. 하지만 불필요한 함수 실행이 발생할 수 있고, 함수 내에서 state를 업데이트하는 경우 무한 루프가 발생할 수 있으므로 주의해야 합니다. 따라서 의존성 배열을 사용하는 것이 좋습니다.

2번 형태는 두 번째 파라미터로 빈 배열로 주어집니다. 1번 형태처럼 의존성 배열 속 변수 값의 변화와는 연관이 없습니다. 함수는 컴포넌트가 처음 마운트될 때에만 실행됩니다. 이후에 컴포넌트가 다시 렌더링되어도 실행되지 않습니다. 이 형태는 컴포넌트가 처음 렌더링될 때 한 번만 실행해야 하는 로직에 적합합니다.

3번 형태는 의존성 배열 속 변수들 중 하나라도 값이 변경되면 함수를 실행합니다. 물론 컴포넌트가 처음 렌더링될 때에도 실행됩니다. 특정 state나 props의 변화를 감지해 반응해야 할 때 유용합니다. 예를 들면, 검색어를 state로 관리하여 검색어가 변경될 때마다 해당하는 검색 결과를 가져오는 로직에 사용할 수 있습니다. 의존성 배열에 포함된 변수의 값이 변하지 않으면 함수가 실행되지 않기 때문에 불필요한 함수 실행을 방지하여 성능을 최적화할 수 있습니다.

# 2. 간단한 카운터 만들기

useState를 사용해 간단한 카운터를 만들어보겠습니다. 먼저 src 폴더 내에 components 폴더를 만들고, 그 안에 Counter.jsx 파일을 생성해주세요.

`components/Counter.jsx`
```jsx
import { useState } from "react";

function Counter () {
    const [count, setCount] = useState(0)
    const handleCountUp = (e) => {
        setCount(prevCount => prevCount + 1)
    }

    return (
        <>
            <div>{count}</div>
            <button onClick={handleCountUp}>Count Up!</button>
        </>
    )
}

export default Counter;
```

`App.jsx`
```jsx
import Counter from "./components/Counter";

function App() {
    return (
        <div className="App">
            <Counter />
        </div>
    );
}

export default App;
```

useState 훅을 사용하여 초기값이 0인 count라는 상태 변수를 생성하였습니다. handleCountUp 함수는 버튼을 클릭할 때 호출되는데, 이 함수는 실행되면 setCount 함수를 사용해 count의 값을 1 증가시킵니다. count의 값이 변경되면 React는 자동으로 컴포넌트를 다시 렌더링하여 화면의 카운터 값을 업데이트합니다.

## 2.1 짝수 홀수 판별

state인 count의 값이 변할 때마다 해당 값이 짝수인지 홀수인지를 알려주는 기능을 추가해보겠습니다. 

```jsx
import { useEffect, useState } from "react";

function Counter () {
    const [count, setCount] = useState(0)
    const [number, setNumber] = useState("");
    const handleCountUp = (e) => {
        setCount(prevCount => prevCount + 1);
    }
    
    useEffect(() => {
        console.log('컴포넌트 렌더링');
    }, );

    useEffect(() => {
        console.log('컴포넌트 첫 렌더링');
    }, [])

		// 짝수 홀수 판별
    useEffect(() => {
        if(count % 2 === 0) {
            setNumber('짝수');
        } else {
            setNumber('홀수');
        }
        // 삼항 연산자를 이용한 간결한 예시
        // setNumber(count % 2 === 0 ? '짝수' : '홀수');
        console.log('count 값이 변함');
    }, [count])

    return (
        <>
            <div>{count}</div>
            <button onClick={handleCountUp}>Up!</button>
            <div>{number}입니다.</div>
        </>
    )
}

export default Counter;
```

number라는 새로운 state를 생성하였고 초기값은 빈 문자열('')입니다. count의 값이 변할 때마다 useEffect가 실행되어 짝수인지 홀수인지 검사하고, 그 결과에 따라 number 상태를 업데이트합니다.
컴포넌트가 처음 렌더링될 때 count의 초기값은 0이므로, number는 '짝수'로 설정되어 화면에 '짝수입니다'라는 문구가 표시됩니다. 버튼을 클릭하면 count 값이 1씩 증가하며 그에 따라 number의 값도 바뀌어 짝수인지 홀수인지 화면에 표시됩니다.

:::div{.beforeAfter}
| 첫 화면 | 1번 클릭 화면 |
| ------------------------------------------ | ------------------------------------------ |
| ![첫 화면 - 0(짝수)](/images/basecamp-react/chapter04-1/chapter04-1-1.png) | ![1번 클릭 화면 - 1(홀수)](/images/basecamp-react/chapter04-1/chapter04-1-2.png) |
:::

:::div{.callout}

콘솔창에서 useEffect의 형태별로 함수(Effect)가 언제 실행되는지 확인해보세요.

:::

# 3. 시계 만들기

Date 객체를 사용하여 실시간으로 시간이 업데이트되는 시계를 만들어보겠습니다. 

components 폴더 안에 Clock.jsx 파일을 생성해 진행해주세요. 실시간으로 시간이 바뀌도록 하기 위해서는 1초마다 새로운 Date 객체를 생성해야 합니다. 이를 위해 setInterval 함수를 이용합니다.

```components/Clock.jsx```
```jsx
import { useState, useEffect } from "react";

function Clock() {
    const [time, setTime] = useState(new Date());
    const hour = time.getHours();
    const minute = time.getMinutes();
    const second = time.getSeconds();
    
    console.log("렌더링 확인");
  
    setInterval(() => {
        const newTime = new Date();
        setTime(newTime);
    }, 1000);

    return (
        <div>
            <h1>
                시간 : {hour}시 {minute}분 {second}초
            </h1>
        </div>
    );
}

export default Clock;
```

```App.jsx```
```jsx
import Clock from "./components/Clock";

function App() {
    return (
        <div className="App">
            <Clock />
        </div>
    );
}

export default App;
```

콘솔창을 열어보면 수많은 로그가 출력되는 것을 확인할 수 있습니다. 이는 setInterval 함수가 컴포넌트 함수 내부에서 직접 호출되어, 컴포넌트가 렌더링될 때마다 새로운 setInterval이 실행되기 때문입니다. 이러한 방식에는 문제가 있습니다. setInterval 함수를 정지시키는 코드가 없어 새로운 setInterval 함수가 계속 생성되어 메모리 낭비가 발생합니다. 또한 setTime 함수가 1초마다 실행되어 컴포넌트가 계속 리렌더링되는데, 계속 생성되는 타이머로 인해 불필요한 렌더링이 발생합니다. 이 문제를 해결하기 위해 useEffect 훅을 사용할 수 있습니다.

```jsx
import { useState, useEffect } from "react";

function Clock() {
    const [time, setTime] = useState(new Date());
    const hour = time.getHours();
    const minute = time.getMinutes();
    const second = time.getSeconds();
    
    console.log("렌더링 확인");

    useEffect(() => {
        const timer = setInterval(() => {
            setTime(new Date());
        }, 1000);
        // 정리 함수
        return() => {
		        console.log("정리");
            clearInterval(timer);
        }
    }, [time]);

    return (
        <div>
            <h1>
                시간 : {hour}시 {minute}분 {second}초
            </h1>
        </div>
    );
}

export default Clock;
```

첫 렌더링 시에 useEffect 함수가 실행되면서 setInterval 함수가 호출됩니다. 타이머가 실행되면서 1초마다 setTime 함수가 호출되어 새로운 Date 객체로 time 상태를 업데이트합니다. 상태가 변경되면 컴포넌트가 다시 렌더링되는데 컴포넌트가 지워지기 전에 useEffect의 반환 함수(정리 함수)가 실행되어 clearInterval 함수로 이전 타이머를 정지시키고 새로운 타이머를 설정합니다. 이렇게 useEffect를 사용하면 메모리 누수를 방지하고 불필요한 렌더링을 줄일 수 있습니다. 콘솔창을 보면 1초마다 ‘렌더링 확인’과 ‘정리’라는 로그가 출력되어, 무수한 렌더링이 일어나지 않는 것을 확인할 수 있습니다.

:::div{.callout}
위 코드를 개선할 수 있습니다.

```jsx
import { useState, useEffect } from "react";

function Clock() {
    const [time, setTime] = useState(new Date());
    const hour = time.getHours();
    const minute = time.getMinutes();
    const second = time.getSeconds();
    console.log("렌더링 확인");

    useEffect(() => {
        const timer = setInterval(() => {
            setTime(new Date());
        }, 1000);
        // 정리 함수
        return() => {
            console.log('정리');
            clearInterval(timer);
        }
    }, []);

    return (
        <div>
            <h1>
                시간 : {hour}시 {minute}분 {second}초
            </h1>
        </div>
    );
}

export default Clock;
```

이전 코드와의 차이점은 useEffect 훅의 의존성 배열입니다. 빈 의존성 배열을 사용하여useEffect는 컴포넌트가 처음 마운트될 때 한 번만 실행됩니다. 타이머는 컴포넌트 마운트 시 한 번만 설정되고 컴포넌트가 언마운트될 때까지 계속 실행됩니다. 정리 함수는 컴포넌트가 언마운트될 때만 실행되기 때문에 계속 하나의 타이머를 유지하게 됩니다. 따라서 1초마다 새로운 타이머를 생성하고 이전 타이머를 정지했던 이전 코드와는 달리 매 초마다 새로운 타이머를 생성하고 이전 타이머를 정지하는 불필요한 작업을 하지 않아 성능이 개선됩니다. (콘솔창을 확인해보면 '렌더링 확인'이라는 문구만 1초마다 출력되는 것을 확인할 수 있어요!)

:::