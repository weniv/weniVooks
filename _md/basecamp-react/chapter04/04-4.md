---
chapter: Hook
title: useState - Lazy initialization
date: 2024-07-31
---

`Lazy initialization`는 useState를 사용하여 state를 초기화하는 과정을 lazy(게으르게) 실행하는 것입니다. state의 초기값으로 단순한 값 대신 함수의 반환값을 사용할 때, 이 함수의 연산이 복잡하거나 시간이 오래 걸린다면 성능에 영향을 줄 수 있습니다. 이런 경우 lazy initialization을 사용하면 효율적으로 state를 초기화할 수 있습니다.

예시를 통해 lazy initialization의 필요성과 구현 방법을 살펴보겠습니다

`App.css`

```css
.app-container {
  padding: 20px;
}

button {
  background-color: limegreen;
  color: white;
  font-size: 16px;
  text-align: center;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
}
```

`App.jsx`

```jsx
import React, { useState } from 'react';
import './App.css';

function getNum(){
    console.log('getNum 함수 실행중...');
    let sum = 0;
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum;
}

function App() {
    const [num, setNum] = useState(getNum());
    const [count, setCount] = useState(0);

    function handleCountUp() {
        setCount((prevCount) => prevCount + 1)
    }

    return(
        <div className="app-container">
            <div>초기값은 {num}입니다.</div>
            <button onClick={handleCountUp}>카운트 증가 : {count}</button>
        </div>
    )
}

export default App;
```

getNum 함수는 10억 번의 덧셈 연산을 수행하는 매우 부하가 큰 함수입니다. 함수의 결과는 useState의 인자로 전달됩니다. 따라서 num state는 getNum 함수의 반환값을 초기값으로 설정합니다. 페이지에 접속하면 초기값으로 아주 큰 숫자가 표시됩니다.

::img{width="400" alt="페이지 접속 화면" src="/images/basecamp-react/chapter04-4/chapter04-4-1.png"}

getNum 함수는 매우 부하가 큰 연산을 수행합니다. 현재 구현에서는 이 함수가 컴포넌트가 리렌더링될 때마다 실행됩니다. 카운트 증가 버튼을 클릭하면 카운트 값이 1씩 증가해야 하지만, 값의 변화가 화면에 즉시 반영되지 않고 상당한 지연이 발생하고 화면에 반영됩니다. 이는 렌더링이 발생할 때마다 getNum 함수가 실행되기 때문입니다. 카운트 증가 버튼을 클릭할 때마다 콘솔창에서 'getNum 함수 실행중...'이라는 로그를 확인할 수 있습니다.

:::div{.beforeAfter}
| 페이지 화면 | 콘솔창 |
| ------------------------------------------ | ------------------------------------------ |
| ![페이지 접속 화면](/images/basecamp-react/chapter04-4/chapter04-4-2.png) | ![콘솔창 로그 확인 화면](/images/basecamp-react/chapter04-4/chapter04-4-3.png) |
:::

useState의 state 초기화는 원래 컴포넌트의 첫 렌더링 시에만 일어나야 합니다. 하지만 현재 코드에서는 getNum 함수가 매 렌더링마다 실행되고 있습니다. 이를 최적화하여 getNum 함수를 최초 초기화 시에만 실행되도록 수정해보겠습니다.

`App.jsx`

```jsx
import React, { useState } from 'react';
import './App.css';

function getNum(){
    console.log('getNum 함수 실행중...');
    let sum = 0;
    for (let i = 0; i < 1000000000; i++) {
        sum += i
    }
    return sum;
}

function App() {
    const [num, setNum] = useState(getNum);
    const [count, setCount] = useState(0);

    function handleCountUp() {
        setCount((prevNum) => prevNum + 1)
    }

    return(
        <div className="app-container">
            <div>초기값은 {num}입니다.</div>
            <button onClick={handleCountUp}>카운트 증가 : {count}</button>
        </div>
    )
}

export default App;
```

`useState(getNum())` 대신 `useState(() => getNum())`을 사용하였습니다. 이렇게 함수를 전달하면, React는 이를 초기화 함수로 인식하고 컴포넌트의 첫 렌더링 시에만 실행합니다. 즉, getNum 함수는 컴포넌트의 첫 렌더링 시에만 실행됩니다. 카운트 증가 버튼을 클릭해도 getNum 함수가 다시 실행되지 않아, 증가한 count 값의 화면 반영이 즉각적으로 이루어집니다. 콘솔에서 'getNum 함수 실행중...' 로그가 최초 렌더링 시 한 번만 출력되는 것을 확인할 수 있습니다.

:::div{.beforeAfter}
| 페이지 화면 | 콘솔창 |
| ------------------------------------------ | ------------------------------------------ |
| ![페이지 접속 화면](/images/basecamp-react/chapter04-4/chapter04-4-4.png) | ![콘솔창 로그 확인 화면](/images/basecamp-react/chapter04-4/chapter04-4-5.png) |
:::

이 최적화로 인해 초기 로딩 시간은 여전히 길 수 있지만, 이후의 모든 상호작용(예: 버튼 클릭)은 즉각적으로 반응하게 됩니다.

`Lazy initialization`은 복잡한 계산, 대용량 데이터 처리, 또는 비동기 작업의 결과를 초기 상태로 설정할 때 특히 유용합니다. 예를 들어, 로컬 스토리지에서 데이터를 읽어오거나, 큰 배열을 처리하는 경우에 효과적으로 사용할 수 있습니다.

초기화 함수가 매번 다른 값을 반환하도록 설계되어 있다면 예상치 못한 결과가 발생할 수 있으므로 주의해야 합니다. 초기화 함수는 순수 함수여야 하며, 항상 동일한 입력에 대해 동일한 출력을 반환해야 합니다.