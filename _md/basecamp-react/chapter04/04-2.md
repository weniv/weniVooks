---
chapter: Hook
title: useRef
date: 2024-07-12
---

# 1. useRef

useRef 훅은 current라는 하나의 속성을 가지는 자바스크립트 객체를 생성합니다. current 속성을 통해 값에 접근하고 변경할 수 있습니다. 이 값은 컴포넌트의 생명주기 동안 지속되는 가변값으로, 컴포넌트가 마운트되고 언마운트되기 전까지 유지됩니다.

useRef의 기본 구조를 살펴보겠습니다.

```jsx
const ref = useRef(initialValue);
```

여기서 initialValue는 ref.current의 초기값이 됩니다. 예를 들어, `const ref = useRef(0);`라고 하면 ref.current의 초기값은 0이 됩니다. 

useRef의 주요 특징을 알아보겠습니다. 

1. useRef의 값은 자유롭게 변경이 가능한 가변성을 가집니다. 불변성을 유지하기 위해 직접 수정하지 않고 새로운 값을 생성해 setState함수로 값을 변경하는 useState와 차이점을 가집니다. 
2. useRef의 값을 변경해도 컴포넌트 렌더링이 발생하지 않습니다. 이는 생성된 ref가 자바스크립트 객체이기 때문에 React가 ref 값의 변화를 감지하지 못하기 때문입니다. 따라서 ref의 값이 변해도 즉시 화면에 반영되지 않습니다. 컴포넌트가 다시 렌더링 되어도 초기화 되지 않아야 하는 값을 저장해야할 때 주로 사용합니다.
3. useRef를 통해 생성한 값은 컴포넌트가 다시 렌더링되어도 변하지 않습니다. 즉, 컴포넌트가 다시 렌더링되어도 값이 초기화되지 않고 기존 값을 유지합니다. 
4. 주로 DOM 요소에 직접 접근하고자 할 때 사용합니다. 이를 통해 컴포넌트의 특정 요소를 조작할 수 있습니다.

:::div{.callout}

useRef와 useState 비교

|  | ref (useRef) | state (useState) |
| --- | --- | --- |
| 값 업데이트 | ref.current를 직접 수정 | setState 함수 사용 |
| 렌더링 발생 | 값 변경 시 리렌더링 발생하지 않음 | 값 변경 시 리렌더링 발생 |
| 값 초기화 | 컴포넌트 생명주기 동안 한 번만 초기화 | 매 렌더링마다 재선언 (값은 유지) |
| 불변성 | 가변적으로 사용 가능 | 불변성 유지 필요 |
| 값 접근 | 항상 최신 값에 접근 가능 | 렌더링 사이클 내에서 최신 값 보장 |
| 비동기 처리 | 동기적으로 즉시 업데이트 | 비동기적으로 업데이트 |

:::

# 2. useRef와 다른 변수들 비교

useRef와 다른 변수들의 차이점을 알기 위해 예시를 살펴보겠습니다.

`App.css`

```css
body {
  font-family: sans-serif;
}

.counter-container {
  padding: 20px;
}

.value {
  font-size: 20px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 20px;
  border: none;
  border-radius: 4px;
  padding: 10px 15px;
  margin: 5px 0 20px 0;
  cursor: pointer;
}
```

`App.jsx`

```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function Counter() {
    const [count, setCount] = useState(0)
    const [countTwo, setCountTwo] = useState(0)
    const countThree = useRef(0)
    let countFour = 0
    console.log(`화면 렌더링 발생`)

    // 렌더링 발생
    const handleCountUp = (e) => {
        setCount(count + 1)
        // 업데이트 전의 count 값을 보여줍니다.
        console.log(`count: ${count}`)
    }
    
    // 렌더링 발생
    const handleCountUpTwo = (e) => {
        setCountTwo(countTwo + 1)
        // 업데이트 전의 countTwo 값을 보여줍니다.
        console.log(`countTwo: ${countTwo}`)
    }
    
    // 클릭하면 변수의 값 증가, 렌더링 발생 X
    const handleCountUpThree = (e) => {
        countThree.current = countThree.current + 1
        console.log(`countThree.current: ${countThree.current}`)
    }
    
    // 렌더링 발생 X, 다른 state가 변해서 재렌더링 되면 0으로 초기화
    const handleCountUpFour = (e) => {
        countFour = countFour + 1
        console.log(`countFour: ${countFour}`)
    }

    useEffect(() => {
        console.log('count가 감시되고 있습니다.')
        console.log(`감시된 count 변수 : ${count}`)
    }, [count]) // count가 변경되는 것을 감시

    return(
        <div className="counter-container">
            <CounterBox
                label="useState로 생성한 count 변수입니다."
                value={count}
                onClick={handleCountUp}
                buttonText="Up!"
            />
            <CounterBox
                label="useState로 생성한 countTwo 변수입니다."
                value={countTwo}
                onClick={handleCountUpTwo}
                buttonText="Up!"
            />
            <CounterBox
                label="useRef로 생성한 객체의 current 속성 값인 countThree.current입니다."
                value={countThree.current}
                onClick={handleCountUpThree}
                buttonText="Up!"
            />
            <CounterBox
                label="일반 변수인 countFour입니다"
                value={countFour}
                onClick={handleCountUpFour}
                buttonText="Up!"
            />
        </div>
    );
}

function CounterBox({ label, value, onClick, buttonText }) {
    return (
        <div>
            <div className="text">{label}</div>
            <div className="value">{value}</div>
            <button onClick={onClick}>{buttonText}</button>
        </div>
    );
}

function App() {
    return (
        <div className="App">
            <Counter />
        </div>
    );
}

export default App;
```


:::div{.beforeAfter}
| 화면 | 콘솔창 |
| ------------------------------------------ | ------------------------------------------ |
| ![useState, useRef, 일반 변수의 값을 증가시키는 4개의 버튼이 보이는 화면](/images/basecamp-react/chpater04-2/chapter04-2-1.png) | ![버튼을 눌렀을 때 콘솔창에 출력되는 메세지](/images/basecamp-react/chpater04-2/chapter04-2-2.png) |
:::

화면과 콘솔창을 열어 버튼을 누를 때마다 어떤 일이 일어나는지 확인해보세요.

코드를 자세하게 살펴보겠습니다. count와 countTwo는 useState로 생성한 변수입니다. 값이 변경되면 컴포넌트가 리렌더링되고, 변경된 값은 화면에 바로 반영됩니다. count 변수는 useEffect가 값이 변하는지 계속 감시하고 있어, count의 값이 변하면 useEffect 함수가 실행됩니다.

`count` 값을 증가시키는 첫 번째 버튼을 눌렀을 때 콘솔창을 확인하여 자세한 동작 순서를 알아보겠습니다. handleCountUp 함수가 실행되면서 업데이트되기 전의 count 값이 출력됩니다. 렌더링이 발생하고 값이 업데이트되고 useEffect 함수가 실행된 것을 확인할 수 있습니다.

`countTwo` 변수의 값을 증가시키는 버튼을 클릭하면 첫 번째 버튼 클릭 때와 동일하게 변수의 값과 화면 렌더링 문구가 콘솔창에 출력됩니다. 하지만 useEffect가 감시하는 변수가 아니기 때문에 useEffect의 함수가 실행되지는 않습니다.

useRef가 관리하는 `countThree`객체의 countThree.current 속성 값을 증가시키는 세 번째 버튼을 클릭해보세요. 버튼을 클릭하면 콘솔창에 1씩 증가하는 countThree.current 값을 확인할 수 있지만, 화면 속 countThree.current의 값은 변하지 않습니다. 이는 useRef의 ref 값이 변해도 컴포넌트 렌더링이 발생하지 않기 때문에 바뀐 countThree.current의 값이 화면에 반영되지 않는 것입니다. 첫 번째나 두 번째 버튼을 누르면 useState로 관리하는 변수의 값이 바뀌어 렌더링이 발생하게 되는데, 이때 바뀐 countThree.current의 값이 화면에 반영됩니다. 리렌더링이 발생해도 countThree.current의 값이 초기값으로 바뀌지 않습니다.

일반 변수인 `countFour`의 값을 증가시키는 네 번째 버튼을 클릭하면 콘솔창에 1씩 증가하는 countFour의 값을 확인할 수 있지만, 바뀐 값이 화면에 반영되지 않습니다. 일반 변수이기 때문에 값이 변해도 렌더링이 발생하지 않기 때문입니다. 리렌더링이 발생하도록 하는 첫 번째나 두 번째 버튼을 누르면 렌더링이 발생하지만, countFour의 값은 여전히 0입니다. 이는 렌더링이 발생할 때마다 countFour 변수를 0으로 초기화하는 함수가 실행되기 때문입니다. 따라서 countFour는 항상 0으로 표시됩니다.

:::div{.callout}
**count와 countTwo의 값이 왜 증가한 값이 아닌 이전 값이 출력될까요?**
setCountTwo((prevCountTwo) => prevCountTwo + 1) 함수 이후에 console.log(\`countTwo: ${countTwo}\`) 함수가 실행되는데 콘솔창에는 바뀌기 전의 countTwo 값이 출력됩니다. 이는 상태 업데이트가 비동기적으로 발생하기 때문입니다. useRef의 ref.current는 렌더링 주기와 상관없이 항상 최신 값에 접근하기 때문에 이러한 문제가 발생하지 않습니다. 업데이트된 값을 출력하고 싶다면 `useEffect`를 사용하거나 useState의 상태 업데이트 함수를 `함수형 업데이트`로 사용할 수 있습니다.
함수형 업데이트는 setCount(prevCount => prevCount + 1)과 같은 방식으로 상태 업데이트 함수를 사용하는 것입니다. setCountTwo 함수를 함수형 업데이트 방식으로 바꾸어 봅시다.

```jsx
const handleCountUpTwo = (e) => {
  setCountTwo(prevCountTwo => {
    console.log(`countTwo: ${prevCountTwo + 1}`);
    return prevCountTwo + 1;
  })
}
```

두 번째 버튼을 눌러 콘솔창을 확인해보세요. 함수형 업데이트를 사용하면 항상 가장 최신의 상태 값에 접근하기 때문에 최신 값인 prevCountTwo에 1을 더하여 업데이트된 countTwo 값으로 출력됩니다.

useEffect를 사용해서 업데이트된 countTwo 값을 출력하는 코드를 살펴보겠습니다

```jsx
useEffect(() => {
  console.log('countTwo가 감시되고 있습니다.')
  console.log(`감시된 변수 : ${countTwo}`)
}, [countTwo]) // countTwo가 변경되는 것을 감시
```

setCountTwo 함수로 인해 상태 업데이트와 리렌더링이 발생한 후에 countTwo 변수를 감시하고 있던 useEffect의 함수가 실행되기 때문에 업데이트된 countTwo의 값을 출력하게 됩니다.

:::

# 3. useRef 사용 예시

useRef는 주로 DOM 요소에 직접 접근해야 할 때, 렌더링과 무관한 값을 저장해야 할 때, 또는 이전 렌더링 값을 기억해야 하는 등의 상황에서 사용됩니다.

## 3.1 useRef로 **컴포넌트의 특정 요소에 직접 접근하고 싶을 때**

먼저 DOM 요소에 직접 접근하는 예시를 살펴보겠습니다. 

### 3.1.1 컴포넌트의 특정 요소에 포커스 지정

useRef를 사용해 컴포넌트의 특정 요소에 직접 접근하여 포커스를 주는 코드입니다. 페이지에 접속하면 자동으로 이메일 입력창에 포커스를 줍니다.

`App.css`

```css
body {
  font-family: sans-serif;
}

.sign-up-container {
  padding: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
}

input {
  padding: 8px;
  margin-bottom: 10px;
}

button {
  background-color: dodgerblue;
  color: white;
  text-align: center;
  font-size: 15px;
  border: none;
  border-radius: 4px;
  padding: 10px 20px;
  margin: 10px 0 20px 0;
  cursor: pointer;
}

button:hover {
  background-color: #0056b3;
}
```

`App.jsx`

```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function SignUp() {
    const formRef = useRef(null)
    const emailRef = useRef(null)
    const passwordRef = useRef(null)

    function signUp(e) {
        e.preventDefault()
        console.log('회원가입 완료')
        formRef.current.reset();
    }

    useEffect(() => {
        emailRef.current.focus()
    }, [])

    return (
        <div className="sign-up-container">
            <form ref={formRef} onSubmit={signUp}>
                <h1>회원가입</h1>
                <div>
                    <label htmlFor="email">이메일</label>
                    <input
                        type="email"
                        id="email"
                        ref={emailRef}
                        required
                    />
                </div>
                <div>
                    <label htmlFor="password">비밀번호</label>
                    <input
                        type="password"
                        id="password"
                        ref={passwordRef}
                        autoComplete="off"
                        required
                    />
                </div>
                <button type="submit">회원가입</button>
            </form>
        </div>
    )
}

function App() {
    return (
        <div className="App">
            <SignUp />
        </div>
    );
}

export default App;
```

이 코드에서는 이메일을 입력하는 input 요소와 비밀번호를 입력하는 input 요소에 각각 접근하는 emailRef와 passwordRef를 선언하였습니다.

useEffect 함수를 보면 이메일을 입력받는 입력창 DOM 요소와 연결된 emailRef를 사용하여 컴포넌트가 처음 렌더링되면 자동으로 이메일 입력 컴포넌트에 포커스를 줍니다.

### 3.1.2 컴포넌트의 특정 요소의 값 가져오기

useRef를 사용하여 input 요소에 입력된 값을 가져와 화면에 보여주는 예시를 살펴보겠습니다.

`App.jsx`
```jsx
import { useEffect, useRef, useState } from 'react'
import './App.css'

function SignUp() {
    const [welcomeMessage, setWelcomeMessage] = useState('')
    const formRef = useRef(null)
    const emailRef = useRef(null)
    const passwordRef = useRef(null)

    function signUp(e) {
        e.preventDefault()
        setWelcomeMessage(`${emailRef.current.value}님 환영합니다!`)
        formRef.current.reset();
    }

    useEffect(() => {
        emailRef.current.focus()
    }, [])

    return (
        <div className="sign-up-container">
            <form ref={formRef} onSubmit={signUp}>
                <h1>회원가입</h1>
                <div>
                    <label htmlFor="email">이메일</label>
                    <input
                        type="email"
                        id="email"
                        ref={emailRef}
                        required
                    />
                </div>
                <div>
                    <label htmlFor="password">비밀번호</label>
                    <input
                        type="password"
                        id="password"
                        ref={passwordRef}
                        autoComplete="off"
                        required
                    />
                </div>
                <button type="submit">회원가입</button>
            </form>
            {welcomeMessage && <p className="welcome-message">{welcomeMessage}</p>}
        </div>
    )
}

function App() {
    return (
        <div className="App">
            <SignUp />
        </div>
    );
}

export default App;
```

이 예시에서는 회원가입 환영 메시지를 담는 welcomeMessage 상태를 useState로 선언하였습니다. 이메일과 비밀번호를 입력하고 회원가입 버튼을 누르면 signUp 함수가 실행됩니다. signUp 함수 내에서 이메일 입력창 컴포넌트와 연결된 emailRef의 current.value를 통해 입력된 이메일 값을 가져와 환영 메시지를 설정합니다.
