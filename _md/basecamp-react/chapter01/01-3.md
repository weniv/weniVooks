---
chapter: 준비
title: Node
date: 2024-07-18
---

::img{width="300" alt="Node Logo" src="/images/basecamp-react/chapter01-3/chapter01-3-1.png"}

`Node.js`는 Chrome V8 JavaScript 엔진에다 살을 붙여(file, path, os..) 빌드된 `JavaScript 런타임(실행 환경)`입니다. 간단히 말해, `JavaScript 실행기`로써, 시스템에서 JavaScript를 실행할 수 있게 해 줍니다. 

# 1.1 Node 설치

Node를 설치하여 사용해 보도록 하겠습니다. Node.js의 공식 웹사이트로 이동하는 아래 링크로 접속하셔서 설치를 진행해 주시길 바랍니다.

::a[Node.js — Run JavaScript Everywhere]{class='btn-link' href="https://nodejs.org/en" target="_blank"}

::img{width="600" alt="Download Node.js" src="/images/basecamp-react/chapter01-3/chapter01-3-2.png"}

:::div{.callout}
**잠깐!** 만약 Node 환경이 복잡하다고 느껴지신다면 기존의 익숙한 CDN 방식에서 진행하는 것을 권장 드립니다. 시작부터 어려움에 봉착하여 좌절한다면, 극복하기 쉽지 않습니다. 가장 편하게 테스트할 수 있는 환경으로 먼저 시작하세요.

:::

# 1.2 Node 특징

노드는 웹 개발자가 자바스크립트로 (백엔드까지) 다 개발하고 싶을 때 활용될 수 있습니다. 이러한 Node로 서버를 만들 수 있지만, 서버만 만들 수 있는 것은 아니므로 서버 자체라고 생각하시면 안 됩니다! `(Node ≠ 서버)`

다음은 Node의 주요한 특징 2가지를 소개하겠습니다.

:::div{.box}
노드의 주요한 `특징`으로 `Non-Blocking I/O`이 있는데, 하나의 작업이 완료될 때까지 기다리지 않고 바로 다음 작업을 진행하는 방식입니다. 예를 들어, 점원이 한 번의 주문을 받은 커피가 나올 때까지 기다리는 것이 아닌, 손님1,2,3 주문을 일단 모두 받는 것과 같습니다.

또 다른 특징으로 `Single Thread` 모델이 있습니다. 프로그램이 한 번에 하나의 작업만 순차적으로 실행하는 방식입니다. 이때, 프로그램 중단을 방지하기 위해 Error 처리는 필수적으로 이뤄져야 합니다. 이를 테면, 카페에 주문을 받는 점원이 한명일 때, 주문을 받지 않는 상황의 error 처리를 해야 하는 상황과 같습니다. 이러한 단일 스레드 환경에서는 에러 발생을 철저히 대비해야 하는 것 의미합니다.

:::figure
::img{width="600" alt="Weniv Cafe" src="/images/basecamp-react/chapter01-3/chapter01-3-3.png"}
::figcaption[카페에서 주문을 받는 점원을 주목하세요]
:::

:::div{.callout}
혹시 Node를 처음 접하신다면? 아래 공식 문서들을 열어, 외워야 한다는 부담을 내려두고 가볍게 읽어 가면서 공부 하시는 것을 권장 드립니다.

::a[Node.js — Introduction to Node.js]{class='btn-link' href="https://nodejs.org/en/learn/getting-started/introduction-to-nodejs" target="_blank"}

::a[Index | Node.js v22.3.0 Documentation]{class='btn-link' href="https://nodejs.org/docs/latest/api/" target="_blank"}

:::

# 1.3 AXIOS

::img{width="300" alt="Axios Logo" src="/images/basecamp-react/chapter01-3/chapter01-3-4.png"}

Axios는 웹 애플리케이션에서 `서버와 쉽고 편리하게 데이터를 주고받을 수 있게 해`주는 도구입니다. 웹 브라우저뿐만 아니라 서버 측 JavaScript(Node.js) 등 다양한 환경에서 활용이 가능합니다. React 애플리케이션에서는 API 요청을 보낼 때 자주 사용됩니다.

공식 문서와 참고할 수 있는 링크는 아래에서 확인하실 수 있습니다.

::a[Axios - 시작하기]{class='btn-link' href="https://axios-http.com/kr/docs/intro" target="\_blank"}

::a[📚 AXIOS 설치 & 특징 & 문법 💯 정리]{class='btn-link' href="https://inpa.tistory.com/entry/AXIOS-%F0%9F%93%9A-%EC%84%A4%EC%B9%98-%EC%82%AC%EC%9A%A9" target="\_blank"}

## 1. Axios 설치

우선, Axios를 설치해 보겠습니다. 터미널에서 다음과 같은 명령어를 입력하고 실행해 주세요.

```shell
npm install axios
```

## 2. 컴포넌트 세팅

파일 및 폴더는 아래 사진처럼 정리해 주시고, 그 안에 있는 코드들 또한 아래와 같이 수정해 주세요.

`index.html`

```html
<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>React App</title>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```

`App.js`

```javascript
function App() {
  return (
    <div className="App">
      <h1>test2</h1>
    </div>
  );
}

export default App;
```

`index.js`

```javascript
import React from 'react';
// import ReactDOM from 'react-dom'; //구버전
import { createRoot } from 'react-dom/client';
import App from './App';

const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App tab="home" />);
```

그런 다음, src 폴더 내에 새로운 components 라는 폴더를 만들어 Product.jsx 파일을 만들어 연결이 되는지 확인해 보겠습니다.

`Product.jsx`

```jsx
import React from 'react'

export default function Product() {
    return (
        <div>Product</div>
    )
}
```
`App.js`

```javascript
import Product from './components/Product'

function App() {
  return (
    <div className="App">
      <h1>test2</h1>
      <Product/>
    </div>
  );
}

export default App;
```

## 3. Axios vs Fetch

Axios는 Promise 기반의 HTTP 클라이언트 라이브러리이고, Fetch는 웹 브라우저에 내장된 현대적인 API를 뜻합니다. 이러한 Axios와 Fetch를 비교 분석해보는 시간을 가져보겠습니다.

1. 기본 사용법

`Axios`

```javascript
axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));
```

`Fetch`

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

2. 주요 차이점

|  | Axios | Fetch |
| --- | --- | --- |
| `브라우저 지원` | 구형 브라우저를 포함한 대부분의 브라우저에서 지원 | 최신 브라우저에서만 지원 (IE에서는 지원되지 않음) |
| `자동 JSON 변환` | 응답 데이터를 자동으로 JSON으로 변환 | .json() 메서드를 호출하여 수동으로 JSON을 파싱해야 함 |
| `에러 핸들링` | HTTP 에러 상태를 자동으로 catch하고 reject함 | HTTP 에러 상태를 catch 블록에서 잡아내지 않음 (네트워크 에러만 catch) |
| `요청 취소` | 내장된 취소 토큰을 사용하여 쉽게 구현 가능 | AbortController를 사용하여 구현 가능(약간 복잡) |
| `다운로드 진행 상황` | 간단한 설정으로 구현 가능 | 복잡한 구현 필요 |
| `타임아웃 설정` | 옵션으로 쉽게 설정 가능 | 직접 구현 필요 |
| `인터셉터` | 내장 기능으로 제공 | 직접 구현 필요 |
| `동시 요청 처리` | axios.all 메서드 제공 (내부적으로 Promise.all 사용) | Promise.all 사용 |

4. 마무리

Axios와 Fetch의 장단점을 요약하자면, Axios는 광범위한 브라우저를 지원하고 풍부한 기능(인터셉터, 취소, 자동 변환 등)을 제공하며 쉬운 사용법과 에러 핸들링이 간편하다는 장점을 가집니다. 하지만, 추가 라이브러리 설치가 필요하고 번들 크기가 증가하며 약간의 오버헤드가 발생할 가능성이 있다는 단점을 가집니다.

반면, Fetch는 브라우저 내장 API로 추가 설치가 불필요하고 가볍고 단순한 인터페이스를 가질 뿐만 아니라 최신 웹 표준을 따르는 장점이 있지만, 구형 브라우저의 지원이 부족하고 기능히 제한적(추가 기능은 직접 구현 필요)이며 에러 핸들링이 비교적 직관적이지 못한 단점을 가집니다.

결론적으로, 간단한 요청만 필요한 소규모 프로젝트에서는 Fetch가 충분할 수 있지만, 복잡한 요청 처리나 광범위한 브라우저 지원이 필요한 대규모 프로젝트에서는 Axios가 더 적합할 수 있으므로 프로젝트의 요구사항과 개발 환경을 고려하여 선택하는 것이 중요한 과제가 되겠습니다.
