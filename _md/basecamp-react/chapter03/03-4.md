---
chapter: React
title: Component 기본
date: 2024-08-07
---

React 컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각입니다. 컴포넌트를 사용하면 복잡한 UI를 작은 단위로 나누어 관리할 수 있어, 코드의 재사용성과 유지보수성이 높아집니다.

# 1. 컴포넌트의 종류

React에서는 두 가지 주요 유형의 컴포넌트가 있습니다.

## 1.1. 함수형 컴포넌트

```jsx
function Welcome(props) {
  return <h1>안녕하세요, {props.name}님!</h1>;
}
```

## 1.2. 클래스형 컴포넌트

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>안녕하세요, {this.props.name}님!</h1>;
  }
}
```

# 2. 컴포넌트의 주요 특징

:::div{.callout}
컴포넌트 이름은 항상 `대문자`로 시작해야 합니다. 예: `Button`, `Header`, `UserProfile`
:::

## 2.1. 재사용성

::img{width="500" alt="Reuse" src="/images/basecamp-react/chapter02-4/chapter02-4-1.png"}

컴포넌트는 여러 곳에서 재사용할 수 있습니다. 이는 DRY(Don't Repeat Yourself) 원칙을 따르는데 도움이 됩니다.

```jsx
function Button({ text, onClick, color = 'blue' }) {
  return (
    <button
      onClick={onClick}
      style={{
        backgroundColor: color,
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
      }}
    >
      {text}
    </button>
  );
}

function App() {
  return (
    <div>
      <Button text="로그인" onClick={() => console.log('로그인 클릭')} />
      <Button
        text="회원가입"
        onClick={() => console.log('회원가입 클릭')}
        color="green"
      />
    </div>
  );
}
```

## 2.2. 캡슐화

컴포넌트는 자체적으로 상태를 관리하고 동작할 수 있습니다.

```jsx
function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <div>
      <h2>카운트: {count}</h2>
      <button onClick={increment}>증가</button>
      <button onClick={decrement}>감소</button>
    </div>
  );
}
```

`Counter` 컴포넌트는 카운트 상태와 증가/감소 로직을 내부에 캡슐화하고 있습니다. 이 컴포넌트를 사용하는 쪽에서는 내부 구현을 알 필요 없이 단순히 `<Counter />`로 사용할 수 있습니다.

## 2.3. 계층 구조

컴포넌트들을 조합하여 복잡한 UI를 구성할 수 있습니다.

```jsx
function Header() {
  return (
    <header>
      <h1>My Website</h1>
    </header>
  );
}

function Navigation() {
  return (
    <nav>
      <ul>
        <li>
          <a href="/">Home</a>
        </li>
        <li>
          <a href="/about">About</a>
        </li>
        <li>
          <a href="/contact">Contact</a>
        </li>
      </ul>
    </nav>
  );
}

function Content() {
  return (
    <main>
      <p>Welcome to my website!</p>
    </main>
  );
}

function Footer() {
  return (
    <footer>
      <p>© 2024 My Website</p>
    </footer>
  );
}

function App() {
  return (
    <div>
      <Header />
      <Navigation />
      <Content />
      <Footer />
    </div>
  );
}
```

이 예제는 웹사이트의 전체 구조를 여러 컴포넌트로 나누어 구성하는 방법을 보여줍니다. 각 컴포넌트는 특정 부분을 담당하며, `App` 컴포넌트에서 이들을 조합하여 전체 페이지를 만듭니다.

## 2.4. Props

Props(Properties의 줄임말)는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 방법입니다.

```jsx
function UserInfo({ name, age, occupation }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>나이: {age}</p>
      <p>직업: {occupation}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <UserInfo name="김철수" age={30} occupation="개발자" />
      <UserInfo name="이영희" age={28} occupation="디자이너" />
    </div>
  );
}
```

`UserGreeting` 컴포넌트는 `name`과 `age`를 props로 받아 개인화된 인사말을 생성합니다. 이를 통해 하나의 컴포넌트로 다양한 사용자에 대한 인사말을 만들 수 있습니다.

## 2.5. State

State는 컴포넌트 내부에서 관리되는 데이터입니다. State가 변경되면 컴포넌트가 다시 렌더링됩니다.

```jsx
function ToggleButton() {
  const [isOn, setIsOn] = React.useState(false);

  const toggle = () => setIsOn(!isOn);

  return (
    <button
      onClick={toggle}
      style={{ backgroundColor: isOn ? 'green' : 'red' }}
    >
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}
```

`ToggleButton` 컴포넌트는 `isOn`이라는 내부 상태를 가지고 있습니다. 버튼을 클릭할 때마다 이 상태가 변경되며, 상태에 따라 버튼의 텍스트와 색상이 바뀝니다. 이는 컴포넌트가 동적으로 자신의 모습을 변경할 수 있음을 보여줍니다.

# 3. 컴포넌트 설계 원칙

## 3.1. `단일 책임 원칙`

```jsx
// 잘못된 예
function UserProfile({ user, posts }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}

// 개선된 예
function UserInfo({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

function UserPosts({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

function UserProfile({ user, posts }) {
  return (
    <div>
      <UserInfo user={user} />
      <UserPosts posts={posts} />
    </div>
  );
}
```

각 컴포넌트는 한 가지 일만 담당해야 합니다. 각 컴포넌트가 하나의 책임만 갖도록 분리하면, 코드의 재사용성과 유지보수성이 향상됩니다.

## 3.2. `컴포지션`

```jsx
function Button({ children, onClick }) {
  return <button onClick={onClick}>{children}</button>;
}

function Icon({ name }) {
  return <i className={`icon-${name}`}></i>;
}

function IconButton({ icon, children, onClick }) {
  return (
    <Button onClick={onClick}>
      <Icon name={icon} />
      {children}
    </Button>
  );
}

function App() {
  return (
    <div>
      <IconButton icon="save" onClick={() => console.log('저장')}>
        저장
      </IconButton>
    </div>
  );
}
```

여러 개의 작은 컴포넌트를 조합하여 복잡한 UI를 만듭니다. 작은 컴포넌트들을 조합하여 더 복잡한 UI를 만들 수 있습니다. 이는 코드의 재사용성을 높이고 유지보수를 쉽게 만듭니다.

## 3.3. `재사용성`

```jsx
function Input({ label, type = 'text', value, onChange }) {
  return (
    <div>
      <label>{label}</label>
      <input type={type} value={value} onChange={onChange} />
    </div>
  );
}

function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  return (
    <form>
      <Input
        label="이름"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <Input
        label="이메일"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
    </form>
  );
}
```

가능한 한 재사용 가능하도록 설계합니다. `Input` 컴포넌트를 재사용 가능하게 설계함으로써, 다양한 형태의 입력 필드를 쉽게 만들 수 있습니다.

## 3.4. `불변성`

```jsx
function TodoList() {
  const [todos, setTodos] = useState([
    { id: 1, text: '리액트 공부하기', completed: false },
  ]);

  const toggleTodo = (id) => {
    // 잘못된 방법
    // todos[id].completed = !todos[id].completed;
    // setTodos(todos);

    // 올바른 방법
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      ),
    );
  };

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => toggleTodo(todo.id)}>
          {todo.text} - {todo.completed ? '완료' : '미완료'}
        </li>
      ))}
    </ul>
  );
}
```

State나 Props를 직접 수정하지 않고, 새로운 객체를 생성하여 업데이트합니다. React에서는 상태를 직접 변경하지 않고, 새로운 객체를 생성하여 상태를 업데이트해야 합니다. 이는 React의 렌더링 최적화와 관련이 있으며, 예측 가능한 상태 관리를 가능하게 합니다.

# 4. 컴포넌트 최적화 팁

## 4.1. `React.memo`

```jsx
import React from 'react';

const ExpensiveComponent = React.memo(({ name }) => {
  console.log(`Rendering ExpensiveComponent for ${name}`);
  return <div>{name}</div>;
});

function ParentComponent() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment ({count})</button>
      <ExpensiveComponent name="John" />
    </div>
  );
}
```

React.memo는 고차 컴포넌트(HOC)로, 컴포넌트의 props가 변경되지 않았다면 리렌더링을 방지합니다. 위 예시에서 ExpensiveComponent는 name prop이 변경되지 않는 한 리렌더링되지 않습니다. 따라서 ParentComponent의 count 상태가 변경되어도 ExpensiveComponent는 다시 렌더링되지 않습니다.

## 4.2. `useCallback`

```jsx
import React, { useState, useCallback } from 'react';

const ChildComponent = React.memo(({ onClick }) => {
  console.log('ChildComponent rendered');
  return <button onClick={onClick}>Click me</button>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []); // 의존성 배열이 비어있으므로 컴포넌트가 처음 마운트될 때만 함수가 생성됩니다.

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ChildComponent onClick={handleClick} />
    </div>
  );
}
```

useCallback은 메모이제이션된 콜백을 반환합니다. 이는 불필요한 렌더링을 방지하는 데 유용합니다. 위 예시에서 handleClick 함수는 컴포넌트가 리렌더링되어도 새로 생성되지 않습니다. 따라서 ChildComponent는 React.memo와 함께 사용되어 불필요한 리렌더링을 방지합니다.

## 4.3. `useMemo`

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ list }) {
  const sortedList = useMemo(() => {
    console.log('Sorting list...');
    return [...list].sort((a, b) => a - b);
  }, [list]); // list가 변경될 때만 다시 계산합니다.

  return <div>{sortedList.join(', ')}</div>;
}

function ParentComponent() {
  const [numbers, setNumbers] = useState([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]);
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment ({count})</button>
      <ExpensiveCalculation list={numbers} />
    </div>
  );
}
```

useMemo는 계산 비용이 큰 연산의 결과를 메모이제이션합니다. 위 예시에서 sortedList는 list prop이 변경될 때만 다시 계산됩니다. ParentComponent의 count 상태가 변경되어도 정렬 연산은 다시 실행되지 않습니다. 이는 특히 큰 데이터셋을 다룰 때 성능 향상에 도움이 됩니다.
