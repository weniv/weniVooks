---
chapter: Context
title: ContextAPI
date: 2024-08-09
---

# 1. props와 context

보통 React 컴포넌트에서 다른 컴포넌트로 데이터를 전달할 때 **props**를 사용합니다. 부모 컴포넌트가 자식 컴포넌트에게 props를 통해 데이터를 전달하면, 자식 컴포넌트는 이 props를 통해 받은 데이터를 사용할 수 있습니다.

그러나 데이터를 필요로 하는 컴포넌트가 데이터를 생성한 컴포넌트의 직접적인 자식이 아니라, 여러 단계의 자식 컴포넌트를 거쳐야 하는 경우가 있습니다. 이런 상황에서 props를 통해 데이터를 전달하면, 해당 데이터를 실제로 필요로 하지 않는 중간 컴포넌트들도 props를 전달해야 하는 문제가 발생합니다. 이렇게 props가 여러 자식 컴포넌트를 거쳐 전달되는 현상을 `props drilling`이라고 합니다. 아래 그림의 왼쪽 부분이 이러한 props를 통한 데이터 전달 방식을 보여줍니다.

props drilling은 여러 가지 문제점을 야기합니다. 데이터를 사용하지 않는 중간 컴포넌트들이 불필요한 props를 다루게 되어 코드가 복잡해집니다. 코드가 복잡해지면서 데이터의 흐름을 파악하기 어려워져 유지보수성이 낮아집니다. 또한 props에 의존적인 컴포넌트는 다른 상황에서 재사용하기 어려워집니다. 이러한 props를 통한 데이터 전달 방식의 문제점을 개선하기 위해 도입된 것이 context입니다.

![Untitled.png](/images/basecamp-react/chapter05-1/chapter05-1-1.png)

위 그림의 오른쪽 부분은 Context를 사용한 데이터 전달 방식을 보여줍니다. Context를 사용하면 props를 여러 단계에 걸쳐 전달하지 않고도 필요한 컴포넌트에 직접 데이터를 전달할 수 있습니다. Context를 props에 대한 전역 데이터 저장소라고 생각하면 됩니다. 

Context는 데이터를 필요로 하는 자손 컴포넌트에게 직접 데이터를 전달할 수 있도록 합니다. 이를 통해 중간 컴포넌트들은 데이터 전달에 관여하지 않아도 되며, 결과적으로 코드의 복잡성을 줄이고 유지보수성을 향상시킬 수 있습니다. 

## 1.1 props로 전달 예시

props를 통한 데이터 전달 방식의 예시를 살펴보겠습니다. 먼저 Create React App(CRA)를 사용하여 프로젝트를 생성합니다.

```bash
npx create-react-app my-app

cd my-app # my-app 프로젝트로 이동
```

`App.css`

```css
.app-container {
  width: 600px;
  border: 2px solid #ddd;
  border-radius: 4px;
}

.header {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  background: cornflowerblue;
  color: white;
  padding: 10px;
  font-weight: bold;
}

.content {
  padding: 20px;
}

.container {
  border: 1px solid lightgray;
  border-radius: 4px;
  padding: 15px;
}
```

`App.jsx`

```jsx
import React from 'react';
import './App.css';

function App() {
    const user = {
        name: "위니북스",
        email: "wenivooks@weniv.com"
    }

    return (
        <div className="app-container">
            <header className="header">
                <p>{user.name}님 환영합니다.</p>
            </header>
            <main className="content">
                <ChildOne user={user}/>
            </main>
        </div>
    );
}

// user prop을 받아 ChildTwo로 전달
const ChildOne = ({ user }) => {
    return (
        <div className="container">
            <h1>홈페이지</h1>
            <ChildTwo user={user}/>
        </div>
    )
}

// user prop을 받아 name과 email을 ChildThree로 전달
const ChildTwo = ({ user }) => {
    return (
        <div className="container">
            <h2>설정페이지</h2>
            <ChildThree name={user.name} email={user.email}/>
        </div>
    )
}

// name과 email prop을 직접 사용
const ChildThree = ({ name, email }) => {
    return (
        <div className="container">
            <h3>마이페이지</h3>
            <p>이름: {name}님</p>
            <p>이메일: {email}</p>
        </div>
    )
}

export default App;
```

이 예시에서는 App, ChildOne, ChildTwo, ChildThree 총 4개의 컴포넌트가 있습니다. user prop은 App 컴포넌트에서 정의되어 ChildOne, ChildTwo 컴포넌트를 거쳐 ChildThree까지 전달됩니다. App 컴포넌트는 user 객체를 정의하고 ChildOne에 전달합니다. ChildOne 컴포넌트는 user prop을 받아 ChildTwo로 전달합니다. ChildTwo 컴포넌트는 user prop을 받아 name과 email을ChildThree로 전달합니다. ChildThree 컴포넌트는 name과 email prop을 직접 사용합니다.

![스크린샷 2024-08-09 16.20.50.png](/images/basecamp-react/chapter05-1/chapter05-1-2.png)

컴포넌트 계층 구조가 보이시나요? ChildOne과 ChildTwo 컴포넌트는 user prop을 직접 사용하지 않고 단순히 하위 컴포넌트로 전달하는 역할만 합니다. 이는 코드의 복잡성을 증가시키고 유지보수를 어렵게 만듭니다.

# 2. contextAPI

## 2.1 context 생성

Context API를 사용하면 props drilling 문제를 해결할 수 있습니다. Context를 이해하기 쉽게 설명하자면, props를 저장하는 전역 저장소라고 생각해볼 수 있습니다. 이 저장소는 애플리케이션 전체에서 접근 가능한 공간으로, 여러 컴포넌트에서 공유해야 하는 데이터를 보관합니다. 이러한 Context를 생성하기 위해 React에서 제공하는 createContext 함수를 사용합니다. 이 함수를 통해 우리는 props를 저장하고 관리할 수 있는 저장소를 만들게 됩니다.

```jsx
import { createContext } from 'react';

const UserContext = createContext();
```

createContext의 인자로는 기본값이 들어갑니다. 기본값은 Provider 컴포넌트를 사용하지 않은 경우와 상위 컴포넌트 트리에 일치하는 Provider가 없을 때 사용됩니다. 보통 Provider를 사용해 값을 제공하므로 기본값을 사용하는 경우는 드뭅니다.