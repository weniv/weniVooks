---
chapter: React
title: Event
date: 2024-07-23
---

`Event란?` React에서의 이벤트는 웹 애플리케이션에서 사용자나 브라우저가 수행하는 `특정 동작`을 말합니다. 예를 들어, 버튼 클릭, 키보드 입력, 마우스 이동 등이 있습니다. DOM 엘리먼트에서 문자열로 이벤트 핸들러를 처리하는 방법과는 달리, 리액트에서는 JSX를 통해 자체적인 이벤트 시스템(Synthetic Event)를 사용합니다.

# 1. 기본 문법

React에서는 이벤트 이름을 `camelCase`로 작성합니다. 단어와 단어 사이를 `대문자`로 구분합니다. 예를 들어, `onClick`, `onSubmit` 등 으로 작성합니다.

```jsx
function Button() {
  const handleClick = () => {
    alert('버튼이 클릭되었습니다!');
  };

  return <button onClick={handleClick}>클릭하세요</button>;
}
```

또한, 버튼을 클릭하는 함수를 생성하는 위와 같은 코드를 살펴볼 때, JSX에서는 문자열 대신 함수를 이벤트 핸들러로 전달한다는 것을 알 수 있습니다. onClick 속성에 함수를 직접 전달하는 것에 주목해 주세요. 리액트에서 지원하는 이벤트의 종류를 더 알고 싶으시다면 아래 링크를 참고해 주세요.

::a[합성 이벤트(SyntheticEvent) - React]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/events.html#other-events" target="\_blank"}

# 2. Lifting State up(상태 끌어올리기)

Lifting State Up은 React에서 중요한 개념 중 하나로, 여러 컴포넌트가 동일한 변경 가능한 데이터를 공유해야 할 때 사용됩니다. 이를 통해 하위 컴포넌트들간의 상태를 동기화할 수 있습니다.

간단한 카운터 앱을 예시로 살펴보겠습니다.

```jsx
import React, { useState } from 'react';

// 버튼 컴포넌트
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// 카운트 표시 컴포넌트
function Count({ value }) {
  return <div>현재 카운트: {value}</div>;
}

// 부모 컴포넌트
function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <div>
      <Count value={count} />
      <Button onClick={increment}>증가</Button>
      <Button onClick={decrement}>감소</Button>
    </div>
  );
}

export default Counter;
```

이 앱은 부모 컴포넌트(`Counter`)에서 카운트 상태를 관리하고, 두 개의 자식 컴포넌트(증가 버튼과 감소 버튼)를 통해 카운트를 조작합니다. 이 예시에서 상태 끌어올리기의 핵심의 포인트를 짚자면, 첫번째, 공통 상태인 `count`가 부모 컴포넌트 `Counter`에서 관리됩니다. 두번째, 상태를 변경하는 로직(`increment`, `decrement`)도 Counter에 위치합니다. 세번째, 자식 컴포넌트들(`Button`, `Count`)은 props를 통해 필요한 데이터와 함수를 전달받습니다. 이렇게 함으로써 여러 컴포넌트가 동일한 상태를 공유하고 일관되게 업데이트할 수 있습니다.

# 3. Hook 미리보기

본격적인 Hook(4장)을 알아보기 전에, 프리뷰 버전으로 React의 주요 Hook 네 가지에 대해 간략히 알아보겠습니다. 이 Hook들은 React 애플리케이션 개발에서 핵심적인 역할을 합니다. 함수형 컴포넌트에서 상태를 관리하는 가장 기본적인 Hook인 `usetState`, 복잡한 상태 로직을 다루는 데 사용되며, 여러 하위 값을 포함하는 상태 객체를 관리하는 데 유용한 `useReducer`, 컴포넌트의 부수 효과를 다루는 데 사용되고 데이터 패칭, 구독 설정, 수동적인 DOM 조작 등을 수행하는 `useEffect`, 마지막으로 살펴볼 useEffect와 유사하지만 모든 DOM 변경 후 동기적으로 발생하며, 레이아웃을 읽고 동기적으로 다시 그리는 작업에 사용되는 `useLayoutEffect`를 간단히 살펴보겠습니다.

:::div{.callout}
Hook에 대해 미리 접해보기 전에, 아래 링크를 접속해 구조 분해 할당에 대해 가볍게 학습하고 오시는 것을 권장 드립니다.

::a[구조 분해 할당]{class='btn-link' href="https://ko.javascript.info/destructuring-assignment" target="\_blank"}

:::

## 3.1. useState

useState는 가장 기본적인 Hook으로, 함수형 컴포넌트에서 상태를 관리할 수 있게 해줍니다.

```javascript
const [state, setState] = useState[initialState];
```

기본적인 구조는 위 코드와 같습니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>현재 카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

useState는 현재 상태값과 이 값을 업데이트하는 함수를 반환하고 있습니다. 초기 상태는 useState의 인자로 전달되며, 상태 업데이트 함수를 호출하면 컴포넌트가 리렌더링됩니다.

## 3.2. useReducer

useReducer는 더 복잡한 상태 로직을 다룰 때 사용되며, 여러 하위 값을 포함하는 복잡한 상태 객체를 관리하는 데 유용합니다.

:::div{.callout}
보통, 상태를 `만들기` 위해 'useState'를 사용하고, 상태를 `업데이트`하기 위해 'setState'를 사용합니다. 그런 다음, 'useReducer'를 사용하여 `복잡한 상태 업데이트 로직을 잘 관리`할 수 있게 됩니다.

:::

```javascript
const [state, dispatch] = useReducer(reducer, initialState);
```

기본적인 구조는 위 코드와 같습니다.

```jsx
import React, { useReducer } from 'react';

// 리듀서 함수 정의
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>현재 카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>증가</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>감소</button>
    </div>
  );
}
```

useState에서 보았던 코드와는 사뭇 다르죠? 복잡하고 긴 코드를 해석하는데 불편한 상태에 대한 관리를 위해 로직을 분리한 것을 잘 보여주고 있습니다.
useReducer는 현재 상태와 dispatch 함수를 반환하고 있는데, 리듀서 함수가 현재 상태와 액션을 인자로 받아 새로운 상태를 반환하고, dispatch 함수를 통해 액션을 발생시키고, 이에 따라 상태가 업데이트되는 형식입니다.

여기에 파일을 분리하여 로직 관리를 하면, 코드의 구조화와 유지보수성을 크게 향상시킬 수 있습니다. 코드 구조 개선뿐만 아니라, 유지보수 용이성, 테스트 용이성을 높일 수 있는 것이라고 할 수 있스니다. 이 내용을 아래 예시를 통해 알아보겠습니다.

```javascript
export const initialState = { count: 0 };

export function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}
```

```jsx
import React, { useReducer } from 'react';
import { counterReducer, initialState } from '../reducers/counterReducer';

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, initialState);

  return (
    <div>
      <p>현재 카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>증가</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>감소</button>
    </div>
  );
}

export default Counter;
```

위 두 파일을 통해, useReducer를 사용한 카운터 로직 분리에 대한 내용을 살펴보겠습니다. 우선, counterReducer.js에 상태 관리 로직이 분리되어 있어 코드가 깔끔해졌다는 것을 확인할 수 있습니다. 다른 컴포넌트에서도 counterReducer를 쉽게 import하여 사용할 수 있을 뿐만 아니라, 카운터 로직의 수정이 필요할 때 counterReducer.js만 수정하면 되는 이점을 가집니다. 또한, counterReducer 함수에 대한 독립적인 단위 테스트를 쉽게 작성할 수 있어 더 체계적이고 효율적인 테스팅이 가능해집니다.

지금까지 두 가지의 Hook의 주요한 특징을 비교한 내용을 아래 표를 통해 정리해 보겠습니다.

|             |          useState           |               useReducer                |
| :---------: | :-------------------------: | :-------------------------------------: |
|   복잡성    |   단순한 상태 관리에 적합   |    복잡한 상태 로직을 다루는 데 유용    |
| 예측 가능성 |   직접적인 상태 업데이트    |    액션을 통한 명확한 상태 변화 흐름    |
|   디버깅    |    간단한 상태 변화 추적    |  복잡한 상태 변화를 더 쉽게 추적 가능   |
|   테스트    | 컴포넌트 단위 테스트에 용이 | 순수 함수인 리듀서를 별도로 테스트 가능 |

:::div{.callout}
useLayoutEffect와 useEffect는 React 컴포넌트에서 부수 효과를 다루는 데 사용되는 Hook입니다. 두 Hook은 비슷해 보이지만 실행 시점과 사용 목적에 차이가 있습니다.

:::

## 3.3. useEffect

useEffect는 컴포넌트가 렌더링된 후에 비동기적으로 실행되니다. 주로 데이터 패칭, 구독 설정, DOM 조작 등 렌더링 후에 수행해도 문제없는 작업에 사용됩니다.

기본 구조는 다음과 같습니다.

```javascript
useEffect(() => {
  // 수행할 부수 효과
  return () => {
    // 정리(cleanup) 함수
  };
}, [의존성 배열]);
```

```jsx
import React, { useState, useEffect } from 'react';

function ExampleComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // 데이터 페칭
    fetch('https://api.example.com/data')
      .then((response) => response.json())
      .then((result) => setData(result));

    // 정리 함수
    return () => {
      // 필요한 경우 정리 작업 수행
    };
  }, []); // 빈 의존성 배열: 컴포넌트 마운트 시에만 실행

  return <div>{data ? <p>{data}</p> : <p>로딩 중...</p>}</div>;
}
```

이 예시에서 useEffect는 컴포넌트가 마운트될 때, 한 번만 실행되어 데이터를 가져오는 것을 알 수 있습니다.

## 3.4. useLayoutEffect

useLayoutEffect는 모든 DOM 변경 후에 동기적으로 실행됩니다. 이는 브라우저가 화면을 그리기 전에 실행되므로, DOM을 조작하고 즉시 화면에 반영해야 하는 경우에 사용됩니다.

구조는 useEffect와 동일하지만, 실행 시점이 다른 걸 아래에서 볼 수 있습니다.

```javascript
useLayoutEffect(() => {
  // 동기적으로 수행할 부수 효과
  return () => {
    // 정리 함수
  };
}, [의존성 배열]);
```

```jsx
import React, { useState, useLayoutEffect, useRef } from 'react';

function Tooltip() {
  const [tooltipHeight, setTooltipHeight] = useState(0);
  const tooltipRef = useRef();

  useLayoutEffect(() => {
    const height = tooltipRef.current.offsetHeight;
    setTooltipHeight(height);
    // 툴팁 위치 조정
    tooltipRef.current.style.top = `-${height}px`;
  }, []); // 컴포넌트 마운트 시에만 실행

  return (
    <div style={{ position: 'relative' }}>
      <div ref={tooltipRef} style={{ position: 'absolute' }}>
        툴팁 내용
      </div>
      <p>본문 내용</p>
    </div>
  );
}
```

이 코드에서 살펴볼 수 있듯이, useLayoutEffect는 툴팁의 높이를 측정하고 위치를 조정합니다. 이 작업은 화면에 렌더링되기 전에 동기적으로 수행되어, 사용자가 위치 조정 과정을 보지 않을 수 있게 합니다.

이 두 Hook을 적절히 활용하면 React 애플리케이션의 동작을 더욱 세밀하제 제어할 수 있지만, 대부분의 경우 uesLayoutEffect까지 사용하지 않아도 useEffect로 충분하며, `화면 깜빡임`이나 레이아웃 이동이 발생하는 경우에만 useLayoutEffect 사용을 고려하는 것이 좋습니다.
