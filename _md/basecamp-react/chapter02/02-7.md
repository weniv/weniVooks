---
chapter: React
title: Event 처리와 Hook 기초
date: 2024-08-01
---

# 1. React에서의 이벤트 처리

React에서 이벤트는 사용자 상호작용이나 시스템 이벤트에 대응하는 중요한 메커니즘입니다.

## 1.1. 이벤트의 개념

이벤트란 웹 애플리케이션에서 사용자나 브라우저가 수행하는 특정 동작을 말합니다. 예를 들어, 버튼 클릭, 키보드 입력, 마우스 이동 등이 있습니다.

## 1.2. 이벤트 시스템

React는 자체적인 이벤트 시스템(Synthetic Event)를 사용합니다. 이는 브라우저의 네이티브 이벤트를 감싸고 있어, 크로스 브라우저 호환성을 보장합니다.

## 1.3. 이벤트 처리 기본 문법

React에서는 이벤트 이름을 camelCase로 작성합니다. 예: `onClick`, `onSubmit`

```jsx
function Button() {
  const handleClick = () => {
    alert('버튼이 클릭되었습니다!');
  };

  return <button onClick={handleClick}>클릭하세요</button>;
}
```

:::div{.callout}
JSX에서는 문자열 대신 함수를 이벤트 핸들러로 전달합니다.

:::

# 2. Lifting State Up (상태 끌어올리기)

여러 컴포넌트가 동일한 상태를 공유해야 할 때 사용하는 패턴입니다.

```jsx
import React, { useState } from 'react';

function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function Count({ value }) {
  return <div>현재 카운트: {value}</div>;
}

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <div>
      <Count value={count} />
      <Button onClick={increment}>증가</Button>
      <Button onClick={decrement}>감소</Button>
    </div>
  );
}
```

여기서 주목해야 할 패턴의 핵심은 다음과 같습니다.

1. 공통 상태를 부모 컴포넌트에서 관리합니다.
2. 상태 변경 로직도 부모 컴포넌트에 위치합니다.
3. 자식 컴포넌트는 props를 통해 데이터와 함수를 전달받습니다.

# 3. React Hook 기초

Hook은 함수형 컴포넌트에서 React의 특징들을 사용할 수 있게 해주는 함수입니다.

## 3.1. useState

상태를 관리하는 가장 기본적인 Hook입니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>현재 카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

`useState`는 현재 상태값과 이를 업데이트하는 함수를 반환합니다.

## 3.2. useReducer

useReducer는 복잡한 상태 로직을 다룰 때 사용됩니다.

```jsx
import React, { useReducer } from 'react';

function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>현재 카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>증가</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>감소</button>
    </div>
  );
}
```

useReducer는 현재 상태와 dispatch 함수를 반환합니다. 리듀서 함수를 통해 상태 업데이트 로직을 분리할 수 있습니다.

## 3.3. useEffect

useEffect는 부수 효과를 처리하는 Hook입니다.

```jsx
import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then((response) => response.json())
      .then((result) => setData(result));
  }, []); // 빈 의존성 배열: 컴포넌트 마운트 시에만 실행

  return <div>{data ? <p>{data}</p> : <p>로딩 중...</p>}</div>;
}
```

useEffect는 컴포넌트가 렌더링된 후에 비동기적으로 실행됩니다.

## 3.4. useLayoutEffect

useLayoutEffect는 DOM 변경 후 동기적으로 실행되는 Hook입니다.

```jsx
import React, { useLayoutEffect, useRef } from 'react';

function Tooltip() {
  const tooltipRef = useRef();

  useLayoutEffect(() => {
    const height = tooltipRef.current.offsetHeight;
    tooltipRef.current.style.top = `-${height}px`;
  }, []);

  return (
    <div style={{ position: 'relative' }}>
      <div ref={tooltipRef} style={{ position: 'absolute' }}>
        툴팁 내용
      </div>
      <p>본문 내용</p>
    </div>
  );
}
```

useLayoutEffect는 화면에 렌더링되기 전에 동기적으로 실행되어, 레이아웃 계산이 필요한 경우에 유용합니다.

# 4. Hook 사용 시 주의사항

개발자들이 흔히 저지르는 실수를 방지하려면 아래 규칙들을 따라야 합니다. 이는 컴포넌트가 렌더링될 때마다 동일한 순서로 Hook이 호출되는 것을 보장할 수 있습니다.

1. Hook은 항상 컴포넌트의 최상위 레벨에서 호출해야 합니다.
2. Hook은 일반 JavaScript 함수에서 호출할 수 없습니다.
3. 조건문, 루프, 중첩 함수 내에서 Hook을 호출하지 마세요.
