---
chapter: React
title: Component (1)
date: 2024-07-17
---

React의 핵심 개념인 `Component`는 `웹 페이지의 구성 요소를 사용자 정의 요소로 표현하는 방식`을 의미합니다. 반환 값에 JSX를 실어 전달하는 함수를 React 컴포넌트라고 합니다.React 라이브러리의 주요 목적은 이를 통해 웹 애플리케이션을 작고 독립적인 부분들로 나누어 개발하고 관리하는 것입니다. 이러한 접근 방식은 복잡한 UI(사용자 인터페이스)를 보다 효율적으로 구축하고 유지보수할 수 있게 하며 효과적인 컴포넌트 설계는 React 애플리케이션의 성공을 좌우한다고 해도 과언이 아닌 매우 중요한 과정입니다.

이렇게 효율적인 UI 개발을 가능하게 하는 Component의 주요한 특징들을 몇가지 소개해 드리겠습니다. 주의하실 점은 **컴포넌트명**은 첫 글자를 `대문자`로 작성해야 합니다!

# 1. 재사용성

재사용성은 React의 핵심 장점 중 하나입니다. 컴포넌트를 잘 설계하면 여러 곳에서 동일한 코드를 반복하지 않고 재사용할 수 있어, 개발 효율성과 유지보수성이 크게 향상됩니다.

```jsx
// 재사용 가능한 버튼 컴포넌트
function Button({ text, color, onClick }) {
  return (
    <button
      style={{
        backgroundColor: color,
        color: 'white',
        padding: '10px',
        border: 'none',
        borderRadius: '5px',
      }}
      onClick={onClick}
    >
      {text}
    </button>
  );
}

// 부모 컴포넌트에서 버튼 재사용
function App() {
  const handleSave = () => console.log('저장됨');
  const handleDelete = () => console.log('삭제됨');

  return (
    <div>
      <h1>재사용 가능한 버튼 예시</h1>
      <Button text="저장" color="green" onClick={handleSave} />
      <Button text="삭제" color="red" onClick={handleDelete} />
      <Button text="취소" color="gray" onClick={() => console.log('취소됨')} />
    </div>
  );
}
```

위 예시 코드에서, `Button 컴포넌트`는 텍슽, 색상, 클릭 이벤트를 props로 받아 다양한 상황에서 재사용될 수 있습니다. `App 컴포넌트`에서 이 버튼을 세 번 재활용 함으로써, 코드 중복을 피하고 일관된 디자인을 유지하면서 다양한 용도로 버튼을 사용할 수 있는 것입니다.

# 2. 캡슐화

캡슐화는 객체 지향 프로그래밍의 핵심 개념 중 하나로, 관련된 데이터와 기능을 하나의 단위로 묶고, 외부에서의 직접적인 접근을 제한하는 것을 의미합니다. 컴포넌트 내부의 상태와 로직을 해당 컴포넌트 안에 숨기고, 필요한 인터페이스만을 외부에 노출하는 방식으로 구현됩니다. 이를 통해 코드의 복잡성을 줄이고 유지보수성을 높일 수 있습니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  // count 상태와 이를 조작하는 로직을 컴포넌트 내부에 캡슐화
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount((prevCount) => prevCount + 1);
  };

  const decrement = () => {
    setCount((prevCount) => prevCount - 1);
  };

  return (
    <div>
      <h2>카운터: {count}</h2>
      <button onClick={increment}>증가</button>
      <button onClick={decrement}>감소</button>
    </div>
  );
}

// 부모 컴포넌트
function App() {
  return (
    <div>
      <h1>캡슐화 예시</h1>
      <Counter />
      <Counter />
    </div>
  );
}
```

위 예시 코드를 통해, `Counter` 컴포넌트는 자체적으로 `count`를 관리하고, 상태를 변경하는 로직(increment, decrement)가 컴포넌트 내부에 캡슐화되어 있으며, 부모 컴포넌트에서는 Counter 내부 구현에 대해 알 필요 없이 그저 사용만 하면 되는 것을 알 수 있습니다. 각 Counter 인스턴스는 독립적으로 동작하며, 서로의 상태에 영향을 주지 않습니다. 이는 컴포넌트의 내부 로직을 변경하더라도 외부 인터페이스가 그대로라면 다른 부분에 영향을 주지 않아 안전한 코드 수정이 가능하다는 것을 뜻합니다.

# 3. 계층 구조

계층 구조는 React 애플리케이션의 컴포넌트 조직 방식을 나타냅니다. 구체적으로 컴포넌트들이 부모-자식 관계를 형성하며 중첩되는 방식을 말합니다. 이는 UI를 구성하는 요소들을 논리적이고 재사용 가능한 단위로 나누고, 이들을 트리 형태로 구성하는 것을 의미합니다.

```jsx
import React from 'react';

// 최상위 컴포넌트
function App() {
  return (
    <div>
      <Header />
      <MainContent />
      <Footer />
    </div>
  );
}

// Header 컴포넌트
function Header() {
  return (
    <header>
      <h1>나의 웹사이트</h1>
      <Nav />
    </header>
  );
}

// Nav 컴포넌트 (Header의 자식)
function Nav() {
  return (
    <nav>
      <ul>
        <li>
          <a href="/">홈</a>
        </li>
        <li>
          <a href="/about">소개</a>
        </li>
        <li>
          <a href="/contact">연락처</a>
        </li>
      </ul>
    </nav>
  );
}

// MainContent 컴포넌트
function MainContent() {
  return (
    <main>
      <h2>환영합니다!</h2>
      <p>이 웹사이트는 React로 만들어졌습니다.</p>
      <ArticleList />
    </main>
  );
}

// ArticleList 컴포넌트 (MainContent의 자식)
function ArticleList() {
  return (
    <section>
      <h3>최근 글</h3>
      <Article title="React 시작하기" />
      <Article title="컴포넌트 구조 이해하기" />
    </section>
  );
}

// Article 컴포넌트 (ArticleList의 자식)
function Article({ title }) {
  return (
    <article>
      <h4>{title}</h4>
    </article>
  );
}

// Footer 컴포넌트
function Footer() {
  return (
    <footer>
      <p>© 2024 나의 웹사이트. All rights reserved.</p>
    </footer>
  );
}

export default App;
```

`App`은 최상위 컴포넌트로, 전체 애플리케이션의 구조를 정의합니다. Header, MainContent, Footer는 App의 자식 컴포넌트입니다. Nav는 `Header`의 자식, ArticleList는 `MainContent`의 자식이며, Article은 `ArticleList`의 자식 컴포넌트인 것을 알 수 있습니다.

이러한 계층 구조는 코드의 구조화 및 관리 용이, 각 컴포넌트들의 책임이 명확, 컴포넌트 재사용성 향상, 데이터 흐름 예측 용이 등의 이점을 가집니다.

즉, 이러한 구조를 통해 복잡한 UI를 더 작고 관리하기 쉬운 부분으로 나누어 개발할 수 있으며, 각 컴포넌트의 역할과 책임을 명확히 할 수 있습니다.

# 4. Props

props는 React 컴포넌트 간 데이터 전달의 핵심 메커니즘입니다. 이는 주로 부모 컴포넌트에서 자식 컴포넌트로 정보를 전달하는 데 사용됩니다. Props의 유연성으로 인해 개발자는 각 자식 컴포넌트에 서로 다른 데이터를 전달할 수 있어, 동일한 컴포넌트를 다양한 상황에 맞게 재사용할 수 있습니다. 이러한 단방향 데이터 흐름은 React 애플리케이션의 예측 가능성과 유지보수성을 높이는 데 기여합니다.

:::div{.callout}
`구조분해 할당`이란 JavaScript의 표현식으로, 배열이나 객체의 속성을 해체하여 필요한 값을 개별 변수에 담을 수 있게 하는 편리한 방법입니다.

1. 객체 구조분해

```jsx
// 객체 구조분해
const person = { name: 'Alice', age: 30, job: 'developer' };

// 구조분해 할당
const { name, age } = person;

console.log(name); // "Alice"
console.log(age); // 30

// 새로운 변수명으로 할당
const { name: fullName, job: occupation } = person;
console.log(fullName); // "Alice"
console.log(occupation); // "developer"
```

2. 배열 구조분해

```jsx
// 배열 구조분해
const numbers = [1, 2, 3, 4, 5];

// 구조분해 할당
const [first, second, ...rest] = numbers;

console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]
```

3. 함수 매개변수에서의 활용

```jsx
// 함수 매개변수에서 구조분해 사용
function printPersonInfo({ name, age }) {
  console.log(`${name}은(는) ${age}살입니다.`);
}

const person = { name: 'Bob', age: 25, job: 'designer' };
printPersonInfo(person); // "Bob은(는) 25살입니다."
```

4. React에서의 활용

```jsx
// props 구조분해
function Welcome({ name, age }) {
  return (
    <h1>
      안녕하세요, {name}님! 당신은 {age}살입니다.
    </h1>
  );
}

// 사용
<Welcome name="Charlie" age={35} />;

// useState 구조분해
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

이러한 구조분해 할당을 사용하면 코드가 더 간결해지고, 필요한 값만 추출하여 사용할 수 있어 가독성과 유지보수성이 향상됩니다.
:::

```jsx
// 부모 컴포넌트
function ParentComponent() {
  return (
    <div>
      <h1>환영합니다!</h1>
      <ChildComponent name="Alice" age={25} />
      <ChildComponent name="Bob" age={30} />
    </div>
  );
}

// 자식 컴포넌트
function ChildComponent(props) {
  return (
    <div>
      <p>이름: {props.name}</p>
      <p>나이: {props.age}</p>
    </div>
  );
}
```

위 예시 코드에서, 부모 컴포넌트는 두 개의 자식 컴포넌트를 렌더링하여 각각에 다른 namerhk age props를 전달합니다. 이를 통해 자식 컴포넌트는 전달받은 props를 사용하여 개인화된 정보를 표시합니다. 결과적으로 화면에는 다음과 같은 정보가 표시될 것입니다.

```shell
환영합니다!
이름: Alice
나이: 25
이름: Bob
나이: 30
```

# 5. State

state는 React 컴포넌트의 내부 데이터를 관리하는 중요한 개념입니다. 컴포넌트 내에서 관리되는 객체로써, State가 변경되면 React는 자동으로 컴포넌트를 다시 렌더링하여 UI를 업데이트합니다. 이는 동적이고 인터랙티브한 사용자 인터페이스를 만드는 데 핵심적인 역할을 합니다.

```jsx
import React, { useState } from 'react';

function Counter() {
  // count라는 state를 생성하고 초기값을 0으로 설정
  const [count, setCount] = useState(0);

  // count를 증가시키는 함수
  const increment = () => {
    setCount((prevCount) => prevCount + 1);
  };

  // count를 감소시키는 함수
  const decrement = () => {
    setCount((prevCount) => prevCount - 1);
  };

  return (
    <div>
      <h2>카운터: {count}</h2>
      <button onClick={increment}>증가</button>
      <button onClick={decrement}>감소</button>
    </div>
  );
}

function App() {
  return (
    <div>
      <h1>State 예시</h1>
      <Counter />
    </div>
  );
}

export default App;
```

useState 훅을 사용하여 count라는 state를 생성합니다. 그런 다음, setCount 함수를 사용하여 count state를 업데이트합니다. 버튼 클릭 시, increment와 decrement 함수가 호출되어 state를 변경합니다. 이렇게 state가 변경될 때마다 컴포넌트가 자동으로 다시 렌더링되어 화면에 새로운 값이 표시됩니다.

이러한 방식으로 state를 사용하여 동적인 UI를 만들고, 사용자 상호작용에 반응하는 컴포넌트를 구현할 수 있음을 알 수 있습니다.

-
