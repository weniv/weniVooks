---
chapter: React
title: Component (2)
date: 2024-07-22
---

Component의 특징을 알아보았으니 이제 직접 컴포넌트를 만들어 보도록 하겠습니다.

:::div{.callout}
h1태그는 문서 내에 한 번만 사용됩니다. 컴포넌트를 만들고 분리할 때에 이러한 시맨틱 구조를 고려해야 합니다.

:::

:::div{.callout}
**컴포넌트명**은 첫 글자를 `대문자`로 작성해야 합니다!

:::

# 1.1 컴포넌트 리스트 만들기

React에서 리스트를 렌더링할 때 주로 `배열 데이터`를 사용합니다. JS의 배열 메서드를 활용하여 데이터를 처리하고 JSX로 변환하는 방법을 알아봅시다.

아래는 간단한 문자열 배열을 렌더링하는 예제입니다.

```jsx
function FruitList() {
  const fruits = ['사과', '바나나', '오렌지', '망고'];

  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```

우선, `map 함수`를 사용하여 배열의 각 항목을 JSX로 변환합니다. 각 리스트 항목에는 고유한 `key prop`을 제공해야 합니다. 예제에서는 간단히 인덱스를 사용했지만, 실제 애플리케이션에는 고유한 ID를 사용하는 것이 좋습니다.

아래는 실제 애플리케이션에서 주로 다루는 객체 배열을 보여줍니다.

```jsx
function UserList() {
  const users = [
    { id: 1, name: '김철수', age: 25 },
    { id: 2, name: '이영희', age: 30 },
    { id: 3, name: '박민수', age: 28 },
  ];

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name} (나이: {user.age})
        </li>
      ))}
    </ul>
  );
}
```

객체의 속성을 사용하여 더 복잡한 리스트 항목을 만들 수 있습니다. `key`로 각 객체의 고유 ID를 사용하는 것이 좋습니다.

때로는 특정 조건에 맞는 항목만 렌더링해야 할 수도 있는데, 그 내용을 설명하는 예제 코드를 보여 드리겠습니다.

```jsx
function AdultList() {
  const users = [
    { id: 1, name: '김철수', age: 25 },
    { id: 2, name: '이영희', age: 17 },
    { id: 3, name: '박민수', age: 28 },
  ];

  const adults = users.filter((user) => user.age >= 18);

  return (
    <ul>
      {adults.map((user) => (
        <li key={user.id}>
          {user.name} (나이: {user.age})
        </li>
      ))}
    </ul>
  );
}
```

filter 함수를 사용하여 조건에 맞는 항목만 선택할 수 있으며, 필터링된 배열을 map으로 렌더링하는 것을 알 수 있습니다.

주의할 점은, 항상 리스트 항목에 고유한 key를 제공해야 하고, 가능하면 배열의 인덱스를 key로 사용하는 것을 피하여 데이터의 고유 ID를 사용하는 것이 좋습니다. 또한, 대량의 데이터를 다룰 때는 성능 최적화(예: 가상화)를를 고려해야 합니다.

# 1.2 합성 컴포넌트

## 1. 컴포넌트 조합

여러 개의 작은 컴포넌트를 조합하여 더 복잡한 UI를 만들어 보겠습니다.

```jsx
function Welcome(props) {
  return <h1>안녕하세요, {props.name}님!</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
      <Welcome name="Charlie" />
    </div>
  );
}
```

Welcome 컴포넌트를 재사용하여 여러 인사말을 표시합니다. 이렇게 작은 컴포넌트를 조합하여 복잡한 UI를 더 관리하기 쉽게 만들 수 있습니다.

## 2. 특수화된 컴포넌트

이번에는 일반적인 컴포넌트를 기반으로 특정 용도에 맞게 만든 특수화된 컴포넌트를 구현해 보겠습니다.

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick} className="button">
      {children}
    </button>
  );
}

function DeleteButton({ onClick }) {
  return (
    <Button onClick={onClick} className="button delete-button">
      삭제
    </Button>
  );
}

function App() {
  return (
    <div>
      <Button onClick={() => console.log('클릭됨')}>클릭하세요</Button>
      <DeleteButton onClick={() => console.log('삭제됨')} />
    </div>
  );
}
```

Button은 일반적인 버튼이고, DeleteButton은 Button을 기반으로 만든 특수한 용도의 버튼입니다. 이러한 특수화된 버튼을 만들면 코드 재사용성을 높이고 일관된 UI를 유지할 수 있습니다.

## 3. 컴포넌트 분할

컴포넌트 분할은 큰 컴포넌트를 작은 단위로 나누어 관리하기 쉽게 만드는 과정입니다.

```jsx
function UserInfo({ user }) {
  return (
    <div className="user-info">
      <img className="avatar" src={user.avatarUrl} alt={user.name} />
      <div className="user-info-name">{user.name}</div>
    </div>
  );
}

function Comment({ author, text, date }) {
  return (
    <div className="comment">
      <UserInfo user={author} />
      <div className="comment-text">{text}</div>
      <div className="comment-date">{date.toLocaleDateString()}</div>
    </div>
  );
}
```

`UserInfo` 컴포넌트를 분리하여 `Comment` 컴포넌트의 복잡성을 줄여 각 컴포넌트의 역할을 명확히 하고 재사용성을 높였습니다.

## 4. 고차 컴포넌트(HOC)

고차 컴포넌트는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수입니다.

```jsx
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>로딩 중...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

function UserList({ users }) {
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

const UserListWithLoading = withLoading(UserList);

function App() {
  const [isLoading, setIsLoading] = useState(true);
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // 사용자 데이터를 가져오는 비동기 작업 시뮬레이션
    setTimeout(() => {
      setUsers([
        { id: 1, name: '김철수' },
        { id: 2, name: '이영희' },
      ]);
      setIsLoading(false);
    }, 2000);
  }, []);

  return <UserListWithLoading isLoading={isLoading} users={users} />;
}
```

`withLoading`가 고차 컴포넌트로, 로딩 상태를 처리하는 로직을 추가하는 역할을 합니다. `UserList` 컴포넌트는 순수하게 사용자 목록을 표시합니다. `withLoading(UserList)` 를 통해 로딩 상태 처리 기능이 추가된 새로운 컴포넌트가 생성 됩니다. 이러한 방식을 사용하면 로딩 로직을 여러 컴포넌트에 재사용할 수 있습니다.

# 1.3 클래스 컴포넌트

## 1. 기본 구조

클래스 컴포넌트는 React.Component를 상속받아 만들 수 있습니다.

```jsx
import React from 'react';

class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    return (
      <div>
        <h1>안녕하세요, {this.props.name}님!</h1>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
```

`constructor`는 컴포넌트의 초기 state를 설정합니다. `render`는 컴포넌트의 UI를 반환합니다. `this.props`로 props에 접근합니다. `this.state`로 state에 접근하고, `this.setState()`로 state를 업데이트할 수 있습니다.

## 2. 생명주기 메서드

클래스 컴포넌트는 여러 생명주기 메서드를 가집니다.

```jsx
class LifecycleExample extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.state.date !== prevState.date) {
      console.log('시간이 업데이트되었습니다.');
    }
  }

  tick() {
    this.setState({
      date: new Date(),
    });
  }

  render() {
    return (
      <div>
        <h1>현재 시간</h1>
        <h2>{this.state.date.toLocaleTimeString()}</h2>
      </div>
    );
  }
}
```

`componentDidMount`는 컴포넌트가 DOM에 삽입된 직후 호출됩니다. 타이머 설정 등의 작업을 수행합니다. `componentWillUnmount`는 컴포넌트가 DOM에서 제거되기 직전에 호출되어 정리 작업을 수행합니다. `componentDidUpdate`는 컴포넌트 업데이트 작업이 끝난 후 호출되어, 이전 props와 state를 비교할 수 있게 합니다.

## 3. 마이그레이션

함수형 컴포넌트와 hooks를 사용하여 클래스 컴포넌트를 리팩토링할 수 있습니다.

`클래스 컴포넌트`

````jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidMount() {
    document.title = `클릭 횟수: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `클릭 횟수: ${this.state.count}`;
  }

  handleClick = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  }

  render() {
    return (
      <div>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
``

`함수형 컴포넌트로 마이그레이션`

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `클릭 횟수: ${count}`;
  }, [count]);

  const handleClick = () => {
    setCount(prevCount => prevCount + 1);
  }

  return (
    <div>
      <p>클릭 횟수: {count}</p>
      <button onClick={handleClick}>클릭</button>
    </div>
  );
}
````

useState로 state를 관리하고, useEffect로 생명주기 메서드의 기능을 대체합니다. 이렇게 하면, 코드가 더 간결해지고 이해하기 쉬워질뿐만 아니라, this 키워드 사용이 불필요해지는 장점을 가집니다.

:::div{.callout}
**마이그레이션 과정**

1. state를 useState 훅으로 변환합니다.
2. 생명주기 메서드를 useEffect 훅으로 대체합니다.
3. 메서드를 일반 함수로 변경합니다.
4. render 메서드의 내용을 컴포넌트의 변환값으로 사용합니다.

:::

즉, 클래스 컴포넌트에서 함수형 컴포넌트로의 전환은 코드를 더 간결하고 재사용 가능하게 만들며, React의 최신 패턴을 따르는데 도움이 됩니다.
