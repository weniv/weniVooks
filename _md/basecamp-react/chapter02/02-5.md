---
chapter: React
title: Component (2)
date: 2024-07-22
---

Component의 특징을 알아보았으니 이제 직접 컴포넌트를 만들어 보도록 하겠습니다. 학습의 복잡도를 줄이기 위해 챕터마다 새로운 프로젝트를 생성하여 실습을 진행하도록 하겠습니다.

# 1. 컴포넌트 리스트 만들기

React에서 데이터 배열을 기반으로 컴포넌트 리스트를 생성하기 위해 주로 JavaScript의 `map` 함수를 사용합니다. map 함수는 배열의 각 요소를 변환하여 새로운 배열을 생성하는 방식을 가집니다. 이 특성을 활용하여 데이터 배열의 각 항목을 JSX 요소로 변환하는 연습을 해보겠습니다.

```jsx
function FruitList() {
  const fruits = ['사과', '바나나', '오렌지', '포도'];

  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```

`fruits` 배열은 렌더링할 데이터를 포함합니다. 그런 다음, map 함수로 배열의 각 항목에 대해 콜백 함수를 실행합니다. `(fruit, index) => (...)`형태의 콜백 함수는 각 과일 이름과 인덱스를 매개변수로 받습니다. 그러면, JSX가 각 과일에 대한 `<li>` 요소를 생성하며, React가 리스트 항목을 식별하는 데 `key` 속성을 사용합니다. 이렇듯, map 함수를 활용하여 컴포넌트 리스트를 생성하는 방법은 React의 선언적 특성을 잘 보여주는 패턴이라고 할 수 있습니다. 이를 통해 데이터 기반의 동적인 UI를 효과적으로 구현할 수 있습니다.

이 컴포넌트를 사용하면 다음과 같은 HTML이 생성됩니다.

```html
<ul>
  <li>사과</li>
  <li>바나나</li>
  <li>오렌지</li>
  <li>포도</li>
</ul>
```

이 컴포넌트를 실제 React 애플리케이션에서 사용하려면, 다른 컴포넌트에서 다음과 같이 import하고 렌더링할 수 있습니다. 아래 코드는 map 함수를 사용하여 배열의 각 항목을 React 요소로 변환하는 간단하며넛도 효과적인 방법을 보여줍니다.

```jsx
import React from 'react';
import FruitList from './FruitList';

function App() {
  return (
    <div>
      <h1>과일 목록</h1>
      <FruitList />
    </div>
  );
}

export default App;
```

:::div{.callout}
성능 최적화를 위해 가능한 한 (동일한 컴포넌트 리스트 내에서) 고유한 `key` 값을 사용해야 합니다. 리액트에서의 고유한 key값에 대해 더 알고 싶으시다면 아래 링크들을 참고해 주세요.

::a[리스트와 Key - React]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/lists-and-keys.html#keys" target="\_blank"}

::a[재조정 (Reconciliation)]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/reconciliation.html#recursing-on-children" target="\_blank"}

:::

# 2. 합성 컴포넌트

컴포넌트를 합성한다는 것은 여러 개의 작은 컴포넌트들을 조합하여 더 큰 컴포넌트를 만드는 것을 의미합니다. 이는 코드 재사용성 증가뿐만 아니라, 유지보수 및 테스트를 용이하게 하는 장점을 가집니다.

## 2.1. 컴포넌트 조합

여러 개의 작은 컴포넌트를 조합하여 더 복잡한 UI를 만들어 보겠습니다.

```jsx
function Welcome(props) {
  return <h1>안녕하세요, {props.name}님!</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
      <Welcome name="Charlie" />
    </div>
  );
}
```

Welcome 컴포넌트를 재사용하여 여러 인사말을 표시합니다. 이렇게 작은 컴포넌트를 조합하여 복잡한 UI를 더 관리하기 쉽게 만들 수 있습니다.

:::div{.callout}
**컴포넌트를 만들 때, 시맨틱 구조를 고려해야 하나요?**

h1태그는 문서 내에 한 번만 사용됩니다. 컴포넌트를 만들고 분리할 때에 이러한 시맨틱 구조를 고려해야 합니다.

:::

## 2.2. 특수화된 컴포넌트

이번에는 일반적인 컴포넌트를 기반으로 특정 용도에 맞게 만든 특수화된 컴포넌트를 구현해 보겠습니다.

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick} className="button">
      {children}
    </button>
  );
}

function DeleteButton({ onClick }) {
  return (
    <Button onClick={onClick} className="button delete-button">
      삭제
    </Button>
  );
}

function App() {
  return (
    <div>
      <Button onClick={() => console.log('클릭됨')}>클릭하세요</Button>
      <DeleteButton onClick={() => console.log('삭제됨')} />
    </div>
  );
}
```

Button은 일반적인 버튼이고, DeleteButton은 Button을 기반으로 만든 특수한 용도의 버튼입니다. 이러한 특수화된 버튼을 만들면 코드 재사용성을 높이고 일관된 UI를 유지할 수 있습니다.

## 2.3. 컴포넌트 분리 및 분할

1. 컴포넌트 파일 분리는 코드의 맨 아랫줄에 `export` 구문을 입력하여, 밖으로 빼낼 모듈을 설정하는 방식입니다. 아래에 간단한 사용자 프로필 카드를 예로 들어보겠습니다.

`분리 전`

```jsx
function UserProfile() {
  return (
    <div className="user-profile">
      <img src="user-avatar.jpg" alt="User Avatar" />
      <h2>홍길동</h2>
      <p>이메일: hong@example.com</p>
      <p>가입일: 2023년 1월 1일</p>
    </div>
  );
}
```

`분리 후`

```jsx
function Avatar({ src, alt }) {
  return <img src={src} alt={alt} />;
}

function UserInfo({ name, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>이메일: {email}</p>
    </div>
  );
}

function UserProfile() {
  return (
    <div className="user-profile">
      <Avatar src="user-avatar.jpg" alt="User Avatar" />
      <UserInfo name="홍길동" email="hong@example.com" />
      <p>가입일: 2023년 1월 1일</p>
    </div>
  );
}
```

`Avatar` 컴포넌트로 이미지를 분리하고, `UserInfo` 컴포넌트로 이름과 이메일 정보를 분리하였으며, 메인 `UserProfile` 컴포넌트에서 이들을 조합하여 각 부분을 독립적으로 수정하고 재사용하였습니다.

2. 컴포넌트 분할은 큰 컴포넌트를 작은 단위로 나누어 관리하기 쉽게 만드는 과정입니다.

```jsx
function UserInfo({ user }) {
  return (
    <div className="user-info">
      <img className="avatar" src={user.avatarUrl} alt={user.name} />
      <div className="user-info-name">{user.name}</div>
    </div>
  );
}

function Comment({ author, text, date }) {
  return (
    <div className="comment">
      <UserInfo user={author} />
      <div className="comment-text">{text}</div>
      <div className="comment-date">{date.toLocaleDateString()}</div>
    </div>
  );
}
```

`UserInfo` 컴포넌트를 분리하여 `Comment` 컴포넌트의 복잡성을 줄여 각 컴포넌트의 역할을 명확히 하고 재사용성을 높였습니다.

## 2.4. 고차 컴포넌트(HOC)

고차 컴포넌트는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수입니다.

```jsx
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>로딩 중...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

function UserList({ users }) {
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

const UserListWithLoading = withLoading(UserList);

function App() {
  const [isLoading, setIsLoading] = useState(true);
  const [users, setUsers] = useState([]);

  useEffect(() => {
    // 사용자 데이터를 가져오는 비동기 작업 시뮬레이션
    setTimeout(() => {
      setUsers([
        { id: 1, name: '김철수' },
        { id: 2, name: '이영희' },
      ]);
      setIsLoading(false);
    }, 2000);
  }, []);

  return <UserListWithLoading isLoading={isLoading} users={users} />;
}
```

`withLoading`가 고차 컴포넌트로, 로딩 상태를 처리하는 로직을 추가하는 역할을 합니다. `UserList` 컴포넌트는 순수하게 사용자 목록을 표시합니다. `withLoading(UserList)` 를 통해 로딩 상태 처리 기능이 추가된 새로운 컴포넌트가 생성 됩니다. 이러한 방식을 사용하면 로딩 로직을 여러 컴포넌트에 재사용할 수 있습니다.

# 3. 클래스 컴포넌트

## 3.1. 기본 구조

클래스 컴포넌트는 React.Component를 상속받아 만들 수 있습니다.

```jsx
import React from 'react';

class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    return (
      <div>
        <h1>안녕하세요, {this.props.name}님!</h1>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
```

`constructor`는 컴포넌트의 초기 state를 설정합니다. `render`는 컴포넌트의 UI를 반환합니다. `this.props`로 props에 접근합니다. `this.state`로 state에 접근하고, `this.setState()`로 state를 업데이트할 수 있습니다.

## 3.2. 생명주기 메서드

클래스 컴포넌트는 여러 생명주기 메서드를 가집니다.

```jsx
class LifecycleExample extends React.Component {
  constructor(props) {
    super(props);
    this.state = { date: new Date() };
  }

  componentDidMount() {
    this.timerID = setInterval(() => this.tick(), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  componentDidUpdate(prevProps, prevState) {
    if (this.state.date !== prevState.date) {
      console.log('시간이 업데이트되었습니다.');
    }
  }

  tick() {
    this.setState({
      date: new Date(),
    });
  }

  render() {
    return (
      <div>
        <h1>현재 시간</h1>
        <h2>{this.state.date.toLocaleTimeString()}</h2>
      </div>
    );
  }
}
```

`componentDidMount`는 컴포넌트가 DOM에 삽입된 직후 호출됩니다. 타이머 설정 등의 작업을 수행합니다. `componentWillUnmount`는 컴포넌트가 DOM에서 제거되기 직전에 호출되어 정리 작업을 수행합니다. `componentDidUpdate`는 컴포넌트 업데이트 작업이 끝난 후 호출되어, 이전 props와 state를 비교할 수 있게 합니다.

## 3.3. 마이그레이션

함수형 컴포넌트와 hooks를 사용하여 클래스 컴포넌트를 리팩토링할 수 있습니다.

`클래스 컴포넌트`

````jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidMount() {
    document.title = `클릭 횟수: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `클릭 횟수: ${this.state.count}`;
  }

  handleClick = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  }

  render() {
    return (
      <div>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
``

`함수형 컴포넌트로 마이그레이션`

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `클릭 횟수: ${count}`;
  }, [count]);

  const handleClick = () => {
    setCount(prevCount => prevCount + 1);
  }

  return (
    <div>
      <p>클릭 횟수: {count}</p>
      <button onClick={handleClick}>클릭</button>
    </div>
  );
}
````

useState로 state를 관리하고, useEffect로 생명주기 메서드의 기능을 대체합니다. 이렇게 하면, 코드가 더 간결해지고 이해하기 쉬워질뿐만 아니라, this 키워드 사용이 불필요해지는 장점을 가집니다.

:::div{.callout}
**마이그레이션 과정**

1. state를 useState 훅으로 변환합니다.
2. 생명주기 메서드를 useEffect 훅으로 대체합니다.
3. 메서드를 일반 함수로 변경합니다.
4. render 메서드의 내용을 컴포넌트의 변환값으로 사용합니다.

:::

즉, 클래스 컴포넌트에서 함수형 컴포넌트로의 전환은 코드를 더 간결하고 재사용 가능하게 만들며, React의 최신 패턴을 따르는데 도움이 됩니다.
