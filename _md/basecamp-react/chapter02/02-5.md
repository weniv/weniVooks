---
chapter: React
title: Component 심화
date: 2024-08-01
---

# 1. 동적 컴포넌트 리스트 생성하기

React에서는 배열 데이터를 기반으로 동적으로 컴포넌트 리스트를 만들 수 있습니다. 주로 `map` 함수를 사용합니다.

```jsx
function FruitList() {
  const fruits = ['사과', '바나나', '오렌지', '포도'];

  return (
    <ul>
      {fruits.map((fruit, index) => (
        <li key={index}>{fruit}</li>
      ))}
    </ul>
  );
}
```

:::div{.callout}
성능 최적화를 위해 가능한 한 고유한 `key` 값을 사용해야 합니다.
:::

이 코드는 과일 목록을 동적으로 생성하는 방법을 보여줍니다. 먼저 fruits라는 배열에 과일 이름들을 저장합니다. 그 다음, JSX 안에서 map 함수를 사용하여 이 배열의 각 항목을 리스트 아이템(<li>)으로 변환합니다. 각 리스트 아이템에는 key 속성이 필요한데, 여기서는 간단히 배열의 인덱스를 사용했습니다. 이 방식을 통해 데이터 배열을 기반으로 동적인 UI 요소를 쉽게 생성할 수 있습니다.

# 2. 컴포넌트 합성 기법

## 2.1. 기본 합성

여러 작은 컴포넌트를 조합하여 더 큰 컴포넌트를 만듭니다.

```jsx
function Welcome(props) {
  return <h1>안녕하세요, {props.name}님!</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Alice" />
      <Welcome name="Bob" />
      <Welcome name="Charlie" />
    </div>
  );
}
```

이 예제는 컴포넌트 합성의 기본을 보여줍니다. Welcome이라는 간단한 컴포넌트를 정의하고, 이를 App 컴포넌트 내에서 여러 번 사용합니다. Welcome 컴포넌트는 props를 통해 name을 전달받아 개인화된 인사말을 생성합니다. App 컴포넌트에서는 이 Welcome 컴포넌트를 세 번 사용하여 서로 다른 이름으로 인사말을 표시합니다. 이러한 방식으로 작은 컴포넌트를 여러 번 재사용하여 더 복잡한 UI를 구성할 수 있습니다.

## 2.2. 특수화된 컴포넌트

일반 컴포넌트를 기반으로 특정 용도의 컴포넌트를 만듭니다.

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick} className="button">
      {children}
    </button>
  );
}

function DeleteButton({ onClick }) {
  return (
    <Button onClick={onClick} className="button delete-button">
      삭제
    </Button>
  );
}
```

이 코드는 일반적인 컴포넌트를 기반으로 특수한 용도의 컴포넌트를 만드는 방법을 보여줍니다. 먼저 Button이라는 범용 버튼 컴포넌트를 정의합니다. 이 컴포넌트는 클릭 이벤트 핸들러(onClick)와 버튼 내용(children)을 props로 받습니다. 그 다음, 이 Button 컴포넌트를 기반으로 DeleteButton이라는 특수한 버튼을 만듭니다. DeleteButton은 항상 "삭제"라는 텍스트를 표시하며, 추가적인 클래스를 가집니다. 이런 방식으로 기본 컴포넌트를 재사용하면서 특정 목적에 맞는 새로운 컴포넌트를 쉽게 만들 수 있습니다.

## 2.3. 컴포넌트 분리 및 분할

큰 컴포넌트를 작은 단위로 나누어 관리합니다.

```jsx
function Avatar({ src, alt }) {
  return <img src={src} alt={alt} />;
}

function UserInfo({ name, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>이메일: {email}</p>
    </div>
  );
}

function UserProfile() {
  return (
    <div className="user-profile">
      <Avatar src="user-avatar.jpg" alt="User Avatar" />
      <UserInfo name="홍길동" email="hong@example.com" />
      <p>가입일: 2023년 1월 1일</p>
    </div>
  );
}
```

이 예제는 큰 컴포넌트를 작은 단위로 분리하는 방법을 보여줍니다. 먼저 Avatar 컴포넌트는 사용자의 프로필 이미지를 표시합니다. UserInfo 컴포넌트는 사용자의 이름과 이메일 정보를 보여줍니다. 마지막으로 UserProfile 컴포넌트는 이 작은 컴포넌트들을 조합하여 전체 사용자 프로필을 구성합니다. 이렇게 컴포넌트를 작은 단위로 나누면 각 부분을 독립적으로 수정하고 재사용하기 쉬워집니다. 또한 코드의 가독성과 유지보수성이 향상됩니다.

## 2.4. 고차 컴포넌트 (HOC)

컴포넌트를 인자로 받아 새 컴포넌트를 반환하는 함수입니다.

```jsx
function withLoading(WrappedComponent) {
  return function ({ isLoading, ...props }) {
    if (isLoading) return <div>로딩 중...</div>;
    return <WrappedComponent {...props} />;
  };
}

const UserListWithLoading = withLoading(UserList);
```

이 코드는 고차 컴포넌트(HOC)의 예시를 보여줍니다. withLoading이라는 함수는 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환합니다. 이 새 컴포넌트는 isLoading prop을 확인하여, 로딩 중일 때는 "로딩 중..." 메시지를 표시하고, 그렇지 않을 때는 원래의 컴포넌트를 렌더링합니다. 이런 방식으로 로딩 상태 처리 같은 공통 기능을 여러 컴포넌트에 쉽게 추가할 수 있습니다. UserListWithLoading은 이 HOC를 사용하여 만든 새로운 컴포넌트로, 기존 UserList에 로딩 기능이 추가된 형태입니다.

# 3. 클래스 컴포넌트

## 3.1. 기본 구조

```jsx
class Welcome extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    return (
      <div>
        <h1>안녕하세요, {this.props.name}님!</h1>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
```

이 코드는 클래스 컴포넌트의 기본 구조를 보여줍니다. Welcome 클래스는 React.Component를 상속받아 만들어집니다. constructor에서는 초기 state를 설정합니다. handleClick 메서드는 버튼 클릭 시 호출되어 state의 count를 증가시킵니다. render 메서드는 컴포넌트의 UI를 정의합니다. 여기서는 props로 받은 name을 표시하고, state의 count를 보여주며, 클릭할 수 있는 버튼을 제공합니다. 이러한 구조를 통해 상태를 가지고 사용자 상호작용에 반응하는 컴포넌트를 만들 수 있습니다.

## 3.2. 생명주기 메서드

클래스 컴포넌트는 여러 생명주기 메서드를 가집니다. 이 메서드들은 컴포넌트가 생성되고, 업데이트되고, 제거되는 과정에서 특정 시점에 자동으로 호출됩니다.

```jsx
class LifecycleExample extends React.Component {
  componentDidMount() {
    // 컴포넌트가 마운트된 후 실행
  }

  componentDidUpdate(prevProps, prevState) {
    // 컴포넌트가 업데이트된 후 실행
  }

  componentWillUnmount() {
    // 컴포넌트가 언마운트되기 전 실행
  }

  render() {
    return <div>생명주기 예시</div>;
  }
}
```

이 메서드들을 활용하면 컴포넌트의 생명주기 동안 필요한 작업을 적절한 시점에 수행할 수 있습니다.

## 3.3. 함수형 컴포넌트로 마이그레이션

최근 React는 함수형 컴포넌트와 Hooks를 사용하는 방향으로 발전하고 있습니다. 클래스 컴포넌트를 함수형 컴포넌트로 변환하는 과정을 살펴보겠습니다.

`클래스 컴포넌트`

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidUpdate() {
    document.title = `클릭 횟수: ${this.state.count}`;
  }

  handleClick = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    return (
      <div>
        <p>클릭 횟수: {this.state.count}</p>
        <button onClick={this.handleClick}>클릭</button>
      </div>
    );
  }
}
```

`함수형 컴포넌트`로 변환

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `클릭 횟수: ${count}`;
  }, [count]);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  return (
    <div>
      <p>클릭 횟수: {count}</p>
      <button onClick={handleClick}>클릭</button>
    </div>
  );
}
```

:::div{.callout}
*클래스 컴포넌트를 함수형 컴포넌트로 변환*하는 과정은 다음과 같습니다.

1. state를 useState 훅으로 관리합니다.
2. 생명주기 메서드(componentDidUpdate)를 useEffect 훅으로 대체합니다.
3. 메서드를 일반 함수로 변경합니다.
4. render 메서드의 내용을 컴포넌트의 반환값으로 사용합니다.

:::

이렇게 함수형 컴포넌트로 변환하면 코드가 더 간결해지고, React의 최신 패턴을 따르게 됩니다. 또한 Hooks를 사용함으로써 상태 관리와 부수 효과 처리가 더 명확해지고, 로직의 재사용성도 향상됩니다.

함수형 컴포넌트와 Hooks를 사용하는 것이 현재 React 개발의 권장 방식이지만, 여전히 많은 프로젝트에서 클래스 컴포넌트를 사용하고 있습니다. 따라서 두 방식 모두 이해하고 있는 것이 중요합니다. 새로운 프로젝트를 시작할 때는 함수형 컴포넌트와 Hooks를 사용하는 것이 좋지만, 기존 프로젝트를 유지보수할 때는 점진적으로 마이그레이션을 진행할 수 있습니다.
