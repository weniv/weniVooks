---
chapter: React
title: Fragments
date: 2024-07-23
---

# 1. Fragments 개념

Fragments란 `여러 요소를 그룹화하는 React의 특별한 기능`을 의미합니다. 최상위 부모 요소를 가져야 하는 JSX 문법에 따라, 의미없는 div 태그들이 시멘틱한 마크업 작성을 방해하기 때문에 부모 요소 없이 여러 자식 요소를 반환해야 할 때 Fragments가 유용하게 쓰입니다.

아래 코드는 기본 문법으로, div 태그와 같은 별도의 노드를 추가하지 않고도 여러 개의 자식을 감싸줄 수 있는 것을 설명합니다.

```jsx
render() {
    return (
        <React.Fragment>
            <ChildA />
            <ChildB />
            <ChildC />
        </React.Fragment>
    );
}
```

Fragment에 대해 보다 자세하게 알고 싶으시다면 아래 링크를 참고해 주세요.

::a[React - Fragments]{class='btn-link' href="https://ko.legacy.reactjs.org/docs/fragments.html" target="\_blank"}

# 2. Fragments 사용법

Fragment라는 키워드 대신 단축 문법으로 `<> 및 </>`를 사용하기도 합니다. 아래 코드를 참고해 주세요. 이때는 fragment를 사용하기 위해 React 모듈을 따로 설치할 필요가 없습니다.

```jsx
function App() {
    return (
        <>
            <h1>Hello, World!</h1>
            <h2>Hello, World!</h2>
            <h2>Hello, World!</h3>
        </>
    );
}
```

# 3. props(속성)

Fragment는 React 엘리먼트이기 때문에, React와 마찬가지로 props를 전달할 수 있습니다. 하지만, Fragment 요소는 화면에 렌더링 되지 않기 때문에, 스타일과 관련된 속성을 사용하는 것은 무의미하여 보통 리스트 아이템의 `key 값`을 설정할 때 많이 사용됩니다. 또한, 단축 문법으로 사용할 때는 props를 사용이 불가합니다.

```jsx
function ItemList({ items }) {
  return (
    <ul>
      {items.map((item) => (
        <React.Fragment key={item.id}>
          <li>이름: {item.name}</li>
          <li>가격: {item.price}원</li>
        </React.Fragment>
      ))}
    </ul>
  );
}
```

위 예시 코드는 Fragment에 key를 사용하여 각 아이템을 구분하는 것을 설명합니다.

# 4. Fragments 사용 비교

Fragment를 사용했을 때와 사용하지 않았을 때의 차이를 설명하고 예시를 보여드리겠습니다. React 컴포넌트는 단일 루트 요소를 반환해야 합니다. 만약 Fragment 없이 여러 요소를 반환하려면, 추가적인 div나 다른 컨테이너 요소로 감싸야 합니다.

1. `Fragment를 사용하지 않은 경우`

```jsx
function WithoutFragment() {
  return (
    <div>
      {' '}
      {/* 추가적인 div가 필요합니다 */}
      <h1>제목</h1>
      <p>첫 번째 문단</p>
      <p>두 번째 문단</p>
    </div>
  );
}
```

```jsx
// 렌더링 결과
<div>
  <h1>제목</h1>
  <p>첫 번째 문단</p>
  <p>두 번째 문단</p>
</div>
```

이런 경우, 불필요한 div가 DOM에 추가되어 추가적인 DOM 노드로 인한 **메모리 사용 증가**, CSS 스타일링의 **복잡성 증가**, 특정 레이아웃(예: flexbox, grid)에서 **원하지 않는 결과** 초래 가능 등의 문제를 일으킬 수 있습니다.

2. `Fragment를 사용한 경우`

```jsx
function WithFragment() {
  return (
    <React.Fragment>
      <h1>제목</h1>
      <p>첫 번째 문단</p>
      <p>두 번째 문단</p>
    </React.Fragment>
  );
}

// 또는 단축 문법 사용
function WithShortFragment() {
  return (
    <>
      <h1>제목</h1>
      <p>첫 번째 문단</p>
      <p>두 번째 문단</p>
    </>
  );
}
```

```jsx
// 렌더링 결과
<h1>제목</h1>
<p>첫 번째 문단</p>
<p>두 번째 문단</p>
```

결과적으로, Fragment를 사용하면 불필요한 래퍼 요소 없이 깔끔한 HTML 구조를 유지할 수 있을 뿐만 아니라, 복잡한 CSS 스타일링 및 레이아웃 관리가 용이하여 컴포넌트 구조 및 리스트 렌더링에 보다 효율적인 결과를 도출할 수 있습니다.

# 5. 조건부 렌더링

조건부 렌더링이란 특정 조건에 따라 다른 결과를 화면에 렌더링하는 것을 말합니다. 리액트에서는 JavaScript의 if문이나 삼항 연산자를 사용하여 이를 구현할 수 있습니다.

```jsx
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>환영합니다!</h1>;
  }
  return <h1>로그인해 주세요.</h1>;
}

function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  return (
    <div>
      <Greeting isLoggedIn={isLoggedIn} />
      <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
        {isLoggedIn ? '로그아웃' : '로그인'}
      </button>
    </div>
  );
}
```

위 코드를 살펴보면, Greeting 컴포넌트를 통해 isLoggedIn prop에 따라 다른 메시지를 렌더링하고, App 컴포넌트는 useState 훅을 사용하여 로그인 상태를 관리하는 것을 볼 수 있습니다. 즉, 버튼의 텍스트와 동작은 현재 로그인 상태에 따라 조건부로 렌더링됩니다. 이렇게 조건부 렌더링을 사용하면 상태나 권한에 따라 다른 UI를 보여줄 수 있어, 동적이고 반응적인 웹 애플리케이션을 만들 수 있습니다.

# 6. 스타일 적용

React에서는 여러 가지 방식으로 스타일을 지정할 수 있습니다. 다양한 스타일링 방식을 이해하고 상황에 맞게 적절히 사용하면 효과적으로 리액트 애플리케이션의 디자인을 구현할 수 있습니다. 아래에서 React에서 웹페이지 스타일을 적용하는 주요한 방법들을 살펴보겠습니다.

## 6.1. in-line styles

인라인 스타일이란 JSX 요소에 직접 스타일을 적용하는 방법입니다. 간단하지만 재사용성이 떨어진다는 특징을 가집니다.

```jsx
function InlineStyleExample() {
  return (
    <div
      style={{
        color: 'blue',
        fontSize: '20px',
        backgroundColor: 'lightgray',
        padding: '10px',
      }}
    >
      이것은 인라인 스타일 예시입니다.
    </div>
  );
}
```

주의하실 점은, 스타일 속성명은 `카멜 케이스(camelCase):여러 단어들을 연결할 때, 첫 번째 단어는 소문자, 두 번째 단어부터는 대문자로 시작`로 작성해야 합니다. 또한, 값은 문자열로 입력해야 하며 숫자의 경우 단위를 생략하면 px로 자동 간주하게 됩니다.

## 6.2. CSS 클래스 사용

별도의 CSS 파일을 만들어 이를 컴포넌트에 import하여 사용하는 방법입니다. 익숙하고 사용하기 쉽지만 전역 스코프 문제가 있을 수 있습니다.

`styles.css`

```css
.container {
  background-color: #f0f0f0;
  padding: 20px;
  border-radius: 5px;
}

.title {
  color: #333;
  font-size: 24px;
}
```

```jsx
import './styles.css';

function CssClassExample() {
  return (
    <div className="container">
      <h1 className="title">CSS 클래스 예시</h1>
      <p>이것은 외부 CSS 파일을 사용한 스타일링 예시입니다.</p>
    </div>
  );
}
```

## 6.3. CSS 모듈

스코프 문제를 해결하지만 별도의 추가 설정이 필요할 수 있어 번거로움을 가집니다.

`Button.module.css`

```css
.button {
  background-color: #4caf50;
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
}
```

```jsx
import styles from './Button.module.css';

function Button() {
  return <button className={styles.button}>CSS 모듈 버튼</button>;
}
```

이렇게 CSS 모듈을 사용하면 스타일을 컴포넌트 범위로 제한할 수 있어, 스타일 충돌을 방지할 수 있습니다. 실무에서 많이 사용하는 방식입니다.

## 6.4. Styled-components

CSS-in-JS 라이브러리인 Styled-components는 JavaScript 파일 내에서 CSS를 작성할 수 있게 해줍니다. 컴포넌트와 스타일을 함께 관리할 수 있지만 새로운 문법을 배워야 한다는 단점이 있습니다.

```jsx
import styled from 'styled-components';

const StyledButton = styled.button`
  background-color: #4caf50;
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;

  &:hover {
    background-color: #45a049;
  }
`;

function StyledComponentExample() {
  return <StyledButton>Styled Component 버튼</StyledButton>;
}
```
