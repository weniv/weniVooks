---
chapter: NumPy :세 번째 걸음
title: NumPy 심화
date: 2024-07-09
---
# 1.복잡한 인덱싱 기법

## 1.1 불리언 인덱싱 활용

- 불리언 인덱싱은 True/False 값을 가진 배열을 사용하여 원본 배열에서 특정 조건을 만족하는 요소들만 선택하는 방법입니다.

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
mask = (arr % 2 == 0)  # 짝수인 요소만 True
even_numbers = arr[mask]
print(even_numbers)  # 결과: [2 4 6 8 10]

# 복합 조건도 사용 가능
complex_mask = (arr > 3) & (arr < 8)
result = arr[complex_mask]
print(result)  # 결과: [4 5 6 7]

```

> *"불리언 인덱싱은 마치 체에 거르듯이 원하는 조건에 맞는 요소만 골라내는 거예요. 여기서는 먼저 짝수만 골라냈고, 그 다음에는 3보다 크고 8보다 작은 숫자들을 골라냈어요. 이런 방식은 데이터에서 특정 조건을 만족하는 값들만 빠르게 추출하고 싶을 때 매우 유용해요."*
> 

실제 활용 사례: 데이터 분석에서 특정 임계값을 넘는 데이터만 선택하거나, 이상치를 제거할 때 자주 사용됩니다.

## 1.2 정수 배열을 이용한 팬시 인덱싱

- 팬시 인덱싱은 정수 배열을 사용하여 원하는 위치의 요소들을 선택하는 방법입니다. 원본 배열의 특정 인덱스에 해당하는 요소들만 추출할 수 있습니다.

```python
arr = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90])
indices = [0, 2, -1]  # 첫 번째, 세 번째, 마지막 요소 선택
selected = arr[indices]
print(selected)  # 결과: [10 30 90]

# 2D 배열에서의 팬시 인덱싱
arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
row_indices = [0, 2]
col_indices = [1, 2]
selected_2d = arr_2d[row_indices][:, col_indices]
print(selected_2d)
# 결과:
# [[2 3]
#  [8 9]]

```

> *"팬시 인덊싱은 마치 보물 지도에서 특정 위치만 표시해 놓고 그 위치의 보물만 찾아가는 것과 비슷해요. 여기서는 첫 번째, 세 번째, 그리고 마지막 위치의 숫자들을 골라냈어요. 2차원 배열에서는 특정 행과 열의 교차점에 있는 값들을 한 번에 선택할 수 있어요. 이는 복잡한 데이터에서 원하는 부분만 빠르게 추출할 때 매우 유용합니다."*
> 

실제 활용 사례: 

1. `시계열 데이터`에서 특정 시점의 데이터만 추출할 때 사용됩니다.
2. `다차원 데이터`에서 특정 특성(feature)만 선택할 때 사용됩니다.

# 2. 배열 재구조화 심화

## 2.1 np.newaxis를 이용한 차원 확장

- `np.newaxis`는 NumPy 배열에 새로운 차원을 추가하는 특별한 객체입니다. 이는 `None`과 동일하며, 배열의 `shape`를 변경하여 차원을 확장할 수 있게 해줍니다.

`np.newaxis`의 주요 특징:

- 기존 배열에 `새로운 축(axis)`을 추가합니다.
- 배열의 `인덱싱`에 사용되어 차원을 확장합니다.
- 데이터의 복사 없이 `뷰(view)`를 생성하므로 `메모리 효율적`입니다.

```python
import numpy as np

# 1차원 배열 생성
arr_1d = np.array([1, 2, 3, 4])

# 1차원 배열을 2차원 열 벡터로 변환
arr_2d_column = arr_1d[:, np.newaxis]
print("2D 열 벡터:\\n", arr_2d_column)
print("Shape:", arr_2d_column.shape)

# 결과:
# 2D 열 벡터:
# [[1]
#  [2]
#  [3]
#  [4]]
# Shape: (4, 1)

# 1차원 배열을 2차원 행 벡터로 변환
arr_2d_row = arr_1d[np.newaxis, :]
print("\\n2D 행 벡터:\\n", arr_2d_row)
print("Shape:", arr_2d_row.shape)

# 결과:
# 2D 행 벡터:
# [[1 2 3 4]]
# Shape: (1, 4)
```

> *"`np.newaxis`를 사용하는 것은 마치 평면 위의 점들을 공중으로 들어올려 새로운 차원을 만드는 것과 같아요. 1차원 배열을 세로로 세우면 열 벡터가 되고, 가로로 늘리면 행 벡터가 됩니다. 이는 마치 종이 위의 선을 들어올려 벽에 세우거나, 바닥에 눕히는 것과 비슷합니다. 이렇게 차원을 추가하면 데이터를 다른 관점에서 볼 수 있게 되죠."*
> 

실제 활용 사례:

1. 머신러닝 모델에 입력할 때 `배치 차원`을 추가할 때 사용됩니다.
2. 이미지 처리에서 `채널 차원`을 추가할 때 활용됩니다.
3. 시계열 데이터 분석에서 `시간 차원`을 추가할 때 사용됩니다.

## 2.2 배열 전치(transpose)의 다양한 방법

- 배열 전치는 NumPy 배열의 `축(axis)`을 서로 교환하는 연산입니다. 이를 통해 배열의 형태를 변경하거나 다른 관점에서 데이터를 볼 수 있습니다.

배열 전치의 주요 방법:

1. `T` 속성 사용: 가장 간단한 방법으로, 2차원 배열의 행과 열을 교환합니다.
2. `transpose()` 함수 사용: 축의 순서를 지정하여 다차원 배열의 축을 재배열합니다.
3. `swapaxes()` 함수 사용: 두 개의 지정된 축을 서로 교환합니다.

```python
# 기본 전치 (T 속성 사용)
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
arr_transposed = arr_2d.T
print("전치된 2D 배열:\\n", arr_transposed)

# 결과:
# 전치된 2D 배열:
# [[1 4]
#  [2 5]
#  [3 6]]

# 3차원 배열 전치 (transpose 함수 사용)
arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
arr_3d_transposed = np.transpose(arr_3d, (1, 0, 2))
print("\\n전치된 3D 배열:\\n", arr_3d_transposed)

# 결과:
# 전치된 3D 배열:
# [[[1 2]
#   [5 6]]
#  [[3 4]
#   [7 8]]]
```

> *"배열 전치는 마치 루빅 큐브를 회전시키는 것과 비슷해요. 2차원에서는 행과 열을 바꾸는 간단한 작업이지만, 3차원 이상에서는 축을 원하는 대로 재배열할 수 있어 데이터를 다양한 각도에서 볼 수 있게 해줍니다. 이는 마치 3D 물체를 다른 방향에서 관찰하는 것과 같아요. 같은 데이터지만 다른 시각으로 볼 수 있게 되는 거죠."*
> 

실제 활용 사례:

1. `행렬 곱셈 최적화`: 특정 연산에 더 효율적인 형태로 데이터를 재구성합니다.
2. `이미지 처리`: RGB 채널 순서를 변경하거나, 이미지 배치의 구조를 조정합니다.
3. `시계열 데이터 분석`: 시간축과 특성축을 교환하여 다른 관점에서 데이터를 분석합니다.
4. `텐서 연산`: 딥러닝에서 텐서의 형태를 모델의 요구사항에 맞게 조정합니다.

# 3. 효율적인 연산 기법

## 3.1 브로드캐스팅 심화

- 브로드캐스팅(Broadcasting)은 NumPy에서 `shape가 다른 배열 간의 산술 연산을 수행할 수 있게 해주는 기능`입니다. 이 기능은 작은 배열을 자동으로 더 큰 배열의 `shape에 맞게 확장`하여, `요소별 연산`을 가능하게 합니다.
- **주요 특징:**
    1. `메모리 사용을 최적화`하며, 실제로 큰 배열을 생성하지 않습니다.
    2. `낮은 차원의 배열`을 `높은 차원의 배열`과 연산할 수 있게 해줍니다.
    3. 배열 간 `shape 호환성 검사`를 통해 유효한 연산만을 허용합니다.
    4. 복잡한 반복문 없이도 배열 간 연산을 `간결하게 표현`할 수 있습니다.

```python
#**예시: 온도 데이터 변환**

import numpy as np

# 5개 도시의 7일간 섭씨 온도 데이터
temp_c = np.array([
    [20, 19, 21, 22, 23, 21, 20],  # 도시 1
    [18, 17, 19, 20, 21, 20, 19],  # 도시 2
    [25, 26, 27, 28, 27, 26, 25],  # 도시 3
    [15, 14, 16, 17, 18, 17, 16],  # 도시 4
    [22, 23, 24, 25, 24, 23, 22]   # 도시 5
])

# 섭씨를 화씨로 변환 (브로드캐스팅 사용)
temp_f = (temp_c * 9/5) + 32

# 각 도시의 평균 기온 계산 (axis=1은 행 방향, 즉 각 도시별로 평균 계산)
city_mean_f = np.mean(temp_f, axis=1, keepdims=True)

# 일별 기온과 도시 평균의 차이 계산 (브로드캐스팅 사용)
temp_diff = temp_f - city_mean_f

print("화씨 온도:")
print(temp_f)
# 결과:
# [[68.  66.2 69.8 71.6 73.4 69.8 68. ]
#  [64.4 62.6 66.2 68.  69.8 68.  66.2]
#  [77.  78.8 80.6 82.4 80.6 78.8 77. ]
#  [59.  57.2 60.8 62.6 64.4 62.6 60.8]
#  [71.6 73.4 75.2 77.  75.2 73.4 71.6]]

print("\\n도시별 평균 온도 (화씨):")
print(city_mean_f)
# 결과:
# [[69.54285714]
#  [66.45714286]
#  [79.31428571]
#  [61.05714286]
#  [73.91428571]]

print("\\n평균 대비 일별 기온 차이 (화씨):")
print(temp_diff)
# 결과:
# [[-1.54285714 -3.34285714  0.25714286  2.05714286  3.85714286  0.25714286 -1.54285714]
#  [-2.05714286 -3.85714286 -0.25714286  1.54285714  3.34285714  1.54285714 -0.25714286]
#  [-2.31428571 -0.51428571  1.28571429  3.08571429  1.28571429 -0.51428571 -2.31428571]
#  [-2.05714286 -3.85714286 -0.25714286  1.54285714  3.34285714  1.54285714 -0.25714286]
#  [-2.31428571 -0.51428571  1.28571429  3.08571429  1.28571429 -0.51428571 -2.31428571]]

```

> "브로드캐스팅은 마치 요리 레시피를 여러 명의 손님에게 맞춰 확장하는 것과 비슷해요. 예를 들어, 1인분 레시피를 4인분으로 늘릴 때 모든 재료의 양을 4배로 늘리는 것처럼, NumPy는 작은 배열을 자동으로 확장하여 큰 배열과의 연산을 가능하게 합니다."
> 
- **실제 활용:**
브로드캐스팅은 `이미지 처리`, `데이터 정규화`, `행렬 연산` 등 다양한 분야에서 활용됩니다. 예를 들어, 이미지의 모든 픽셀에 동일한 값을 더하거나 곱하는 연산을 간단히 수행할 수 있습니다.

## 3.2 유니버설 함수(ufunc) 활용

- 유니버설 함수(Universal Functions, ufuncs)는 `NumPy 배열의 요소별로 연산을 수행하는 벡터화된 함수`입니다. 이 함수들은 `C로 구현`되어 있어 매우 빠르며, 큰 배열에 대해 `효율적인 연산`을 제공합니다.
- **주요 특징:**
    1. 배열의 모든 요소에 대해 `동일한 연산을 병렬적으로 수행`합니다.
    2. `브로드캐스팅`을 지원하여 다양한 shape의 배열에 적용 가능합니다.
    3. 입력과 출력 모두 `NumPy 배열`을 사용합니다.
    4. `reduce`, `accumulate` 등의 메서드를 통해 집계 연산을 수행할 수 있습니다.

```python
# **예시: 학생 성적 분석**
import numpy as np

# 10명 학생의 5개 과목 점수 (100점 만점)
scores = np.random.randint(60, 101, size=(10, 5))

# 1. 각 과목의 평균 점수
subject_means = np.mean(scores, axis=0)

# 2. 각 학생의 평균 점수
student_means = np.mean(scores, axis=1)

# 3. 각 과목의 최고 점수
subject_max = np.max(scores, axis=0)

# 4. 전체 평균 대비 각 점수의 차이
overall_mean = np.mean(scores)
score_diff = scores - overall_mean

# 5. 점수 분포 (60점대, 70점대, 80점대, 90점대의 수)
score_distribution = np.sum(np.array([
    (scores >= 60) & (scores < 70),
    (scores >= 70) & (scores < 80),
    (scores >= 80) & (scores < 90),
    (scores >= 90)
]), axis=0)

print("점수 데이터:")
print(scores)
# 결과:
# [[72 88 69 76 91]
#  [68 74 84 92 63]
#  [87 61 85 70 79]
#  [65 90 62 81 86]
#  [93 77 66 89 70]
#  [80 64 73 95 88]
#  [71 82 97 68 75]
#  [86 69 78 87 94]
#  [76 93 72 80 67]
#  [89 85 91 73 82]]

print("\\n과목별 평균:", subject_means)
# 결과: [78.7 78.3 77.7 81.1 79.5]

print("학생별 평균:", student_means)
# 결과: [79.2 76.2 76.4 76.8 79.  80.  78.6 82.8 77.6 84. ]

print("과목별 최고 점수:", subject_max)
# 결과: [93 93 97 95 94]

print("\\n전체 평균 대비 점수 차이:")
print(score_diff)
# 결과:
# [[-7.06 8.94 -10.06 -3.06 11.94]
#  [-11.06 -5.06 4.94 12.94 -16.06]
#  [7.94 -18.06 5.94 -9.06 -0.06]
#  [-14.06 10.94 -17.06 1.94 6.94]
#  [13.94 -2.06 -13.06 9.94 -9.06]
#  [0.94 -15.06 -6.06 15.94 8.94]
#  [-8.06 2.94 17.94 -11.06 -4.06]
#  [6.94 -10.06 -1.06 7.94 14.94]
#  [-3.06 13.94 -7.06 0.94 -12.06]
#  [9.94 5.94 11.94 -6.06 2.94]]

print("\\n점수 분포 (60대, 70대, 80대, 90대):")
print(score_distribution)
# 결과: [3 2 2 3]

```

> "유니버설 함수는 마치 공장의 조립 라인과 같아요. 각 작업자(함수)가 컨베이어 벨트 위의 모든 부품(배열 요소)에 대해 동일한 작업을 수행하는 거죠. reduce는 이 부품들을 모두 조립해 하나의 결과물로 만드는 것이고, accumulate는 조립 과정의 각 단계를 기록하는 것과 비슷합니다."
> 

**실제 활용:**
유니버설 함수는 `과학 계산`, `데이터 분석`, `신호 처리` 등 다양한 분야에서 사용됩니다. 예를 들어, 대규모 데이터셋의 `통계 계산`, 복잡한 `수학 함수의 적용`, `시계열 데이터의 변환` 등에 효과적으로 활용됩니다.