---
chapter: NumPy :두 번째 걸음
title: NumPy 다양한 함수
date: 2024-07-09
---
# 1. 통계함수

## 1.1 평균, 분산, 표준편차

- NumPy는 평균`np.mean()`, 분산`np.var()`, 표준편차`np.std()` 등 다양한 통계 함수를 제공합니다. 이러한 함수들은 대량의 수치 데이터를 빠르고 효율적으로 분석할 수 있게 해줍니다.

```python
arr = np.array([1, 2, 3, 4, 5])
print("합계:", np.sum(arr))# 합계
print("평균:", np.mean(arr))# 평균
print("분산:", np.var(arr))# 분산
print("표준편차:", np.std(arr))# 표준편차# 결과:# 합계: 15# 평균: 3.0# 분산: 2.0# 표준편차: 1.4142135623730951

```

> *"통계 함수는 숫자들의 특징을 알려주는 도구예요. np.sum()은 합계, np.mean()은 평균, np.var()은 분산, np.std()는 표준편차를 계산해요. 합계는 모든 숫자를 더한 값이고, 평균은 숫자들의 대표값이에요. 표준편차는 숫자들이 평균으로부터 얼마나 퍼져있는지, 분산은 그 퍼짐 정도를 제곱한 값이에요. 이 도구들을 사용하면 데이터의 전체적인 모습을 쉽게 파악할 수 있어요."*
> 

## 1.2 중앙값, 최빈값

- NumPy는 중앙값`np.median()`, 최빈값`stats.mode()` 등 함수를 이용해 대량의 수치 데이터를 빠르고 효율적으로 분석할 수 있게 해줍니다.

```python
from scipy import stats# NumPy에는 mode 함수가 없어서 SciPy를 사용합니다 (추가)

arr = np.array([1, 2, 2, 3, 3, 3, 4, 5])
print("중앙값:", np.median(arr))# 중앙값
print("최빈값:", stats.mode(arr))# 최빈값# 결과:# 중앙값: 3.0# 최빈값: ModeResult(mode=array([3]), count=array([3]))

```

> *"np.median()은 중앙값을, stats.mode()는 최빈값을 계산해요. 중앙값은 숫자들을 순서대로 나열했을 때 가운데 있는 값이에요. 최빈값은 가장 자주 나타나는 값을 말해요. 이 도구들을 사용하면 데이터의 전체적인 모습을 쉽게 파악할 수 있어요."*
> 

# 2. 수학 함수

## 2.1 삼각함수

- NumPy는 사인`np.sin()`, 코사인`np.cos()`, 탄젠트`np.tan()` 등의 삼각함수를 제공합니다.

```python
angles = np.array([0, 30, 45, 60, 90])
radians = np.deg2rad(angles)
print("사인:", np.sin(radians))
print("코사인:", np.cos(radians))
print("탄젠트:", np.tan(radians))

# 결과:# 사인: [0.         0.5        0.70710678 0.8660254  1.        ]# 코사인: [1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01 6.12323400e-17]# 탄젠트: [0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00 1.63312394e+16]

```

> *"삼각함수는 각도와 관련된 값을 계산해요. np.sin(), np.cos(), np.tan()은 각각 사인, 코사인, 탄젠트 값을 계산해요. 여기서는 0도부터 90도까지의 사인값, 코사인값, 탄젠트값을 계산했어요. 이런 함수들은 물리학, 공학, 그리고 컴퓨터 그래픽스 등 다양한 분야에서 사용돼요."*
> 

## 2.2 지수함수, 로그함수

- NumPy는 지수함수`np.exp()`, 로그함수`np.log()` 등 다양한 수학 함수를 제공합니다. 이러한 함수들은 배열의 각 요소에 대해 효율적으로 연산을 수행합니다.

```python
print("지수함수:", np.exp(np.array([1, 2, 3])))
print("로그함수:", np.log(np.array([1, 10, 100])))

# 결과:# 지수함수: [ 2.71828183  7.3890561  20.08553692]# 로그함수: [0.         2.30258509 4.60517019]

```

> *"수학 함수는 복잡한 계산을 쉽게 해주는 마법 같은 도구예요. np.exp()는 지수함수를, np.log()는 로그함수를 계산해요. 지수함수는 e의 거듭제곱을 계산하고, 로그함수는 그 반대 개념이에요. 이런 함수들은 과학 계산이나 데이터 분석에서 매우 중요하게 사용돼요."*
> 

## 2.3 제곱근, 거듭제곱

- NumPy는 제곱근`np.sqrt()`과 거듭제곱`np.power()`을 계산하는 함수도 제공합니다.

```python
numbers = np.array([1, 4, 9, 16, 25])
print("제곱근:", np.sqrt(numbers))
print("거듭제곱 (2제곱):", np.power(numbers, 2))
print("거듭제곱 (3제곱):", np.power(numbers, 3))

# 결과:
# 제곱근: [1. 2. 3. 4. 5.]
# 거듭제곱 (2제곱): [  1  16  81 256 625]
# 거듭제곱 (3제곱): [   1   64  729 4096 15625]
```

> *"np.sqrt()는 제곱근을, np.power()는 거듭제곱을 계산해요. 제곱근은 어떤 수를 제곱했을 때 나오는 값을 거꾸로 구하는 거예요. 예를 들어, 9의 제곱근은 3이죠. 거듭제곱은 같은 수를 여러 번 곱하는 거예요. 2의 3제곱은 2를 세 번 곱한 8이 되는 것처럼요. 이런 함수들은 과학적 계산이나 데이터 스케일링에서 자주 사용돼요."*
> 

# 3. 유틸리티 함수

## 3.1 np.where

- `np.where()`는 주어진 조건을 만족하는 배열 요소의 인덱스를 찾아 반환하는 함수입니다. 이 함수는 배열에서 특정 조건을 만족하는 요소를 찾거나, 조건부 할당을 수행할 때 매우 유용합니다.

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
indices = np.where(arr > 3)
print("3보다 큰 요소의 인덱스:", indices)

# 결과:
# 3보다 큰 요소의 인덱스: (array([3, 4]),)
```

> *"np.where()는 마치 도서관에서 특정 주제의 책을 찾는 사서와 같아요. 방대한 책(데이터) 중에서 우리가 원하는 조건에 맞는 책(요소)의 위치를 알려주죠. 데이터 분석에서 특정 조건을 만족하는 데이터를 빠르게 찾아내는 데 매우 유용해요."*
> 

## 3.2 np.unique

- `np.unique()`는 배열에서 중복된 값을 제거하고, 유일한 값들만을 정렬된 상태로 반환하는 함수입니다. 이 함수는 데이터의 고유한 특성을 파악하거나, 범주형 데이터를 처리할 때 특히 유용합니다.

```python
arr = np.array([1, 2, 2, 3, 3, 3, 4, 4, 5])
unique_values = np.unique(arr)
print("고유한 값:", unique_values)

# 결과:
# 고유한 값: [1 2 3 4 5]
```

> *"np.unique()는 마치 수집가가 우표 컬렉션에서 중복된 우표를 제거하는 것과 비슷해요. 각기 다른 종류의 우표만 남기고 정리하듯이, 이 함수는 데이터에서 유일한 값들만 깔끔하게 정리해줘요. 이는 데이터의 다양성을 한눈에 파악하거나, 중복 없는 깨끗한 데이터 세트를 만들 때 아주 유용하답니다."*
> 

## 3.3 np.sort

- `np.sort()`는 배열의 요소를 오름차순으로 정렬하는 함수입니다. 이 함수는 데이터를 체계적으로 조직화하여, 분석이나 시각화를 위해 데이터를 준비하는 데 중요한 역할을 합니다.

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])
sorted_arr = np.sort(arr)
print("정렬된 배열:", sorted_arr)

# 결과:
# 정렬된 배열: [1 1 2 3 4 5 6 9]
```

> *"np.sort()는 마치 도서관에서 책을 정리하는 것과 같아요. 무작위로 놓여있던 책들을 번호순으로 차곡차곡 정리하는 거죠. 이렇게 정렬된 데이터는 마치 잘 정리된 도서관처럼, 원하는 정보를 빠르게 찾거나 전체적인 구조를 파악하는 데 도움을 줘요. 데이터 분석에서 중간값을 찾거나, 데이터의 분포를 시각화할 때 매우 유용하게 사용됩니다."*
> 

## 3.4 np.argmax / np.argmin

- `np.argmax()`와 `np.argmin()`은 각각 배열에서 최대값과 최소값의 인덱스를 반환하는 함수입니다. 이 함수들은 데이터에서 극값을 찾고 그 위치를 알아내는 데 매우 유용합니다.

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])
max_index = np.argmax(arr)
min_index = np.argmin(arr)
print("최대값의 인덱스:", max_index)
print("최소값의 인덱스:", min_index)

# 결과:
# 최대값의 인덱스: 5
# 최소값의 인덱스: 1
```

> *"np.argmax()와 np.argmin()은 마치 산에서 가장 높은 봉우리와 가장 낮은 골짜기를 찾는 것과 같아요. 이 함수들은 데이터의 '지형'에서 가장 두드러진 지점을 찾아내죠. 이는 예를 들어 이미지 처리에서 가장 밝은 픽셀이나 가장 어두운 픽셀을 찾는 데 사용될 수 있어요."*
> 

## 3.5 np.reshape

- `np.reshape()`는 배열의 형상(shape)을 변경하는 함수입니다. 이 함수는 데이터의 차원을 재구성하여 다양한 분석이나 처리에 적합한 형태로 만드는 데 사용됩니다.

```python
arr = np.array([1, 2, 3, 4, 5, 6])
reshaped_arr = np.reshape(arr, (2, 3))
print("재구성된 배열:\n", reshaped_arr)

# 결과:# 재구성된 배열:
# [[1 2 3]
#  [4 5 6]]

```

> *"np.reshape()는 마치 레고 블록을 재조립하는 것과 같아요. 같은 블록들로 다양한 모양의 구조물을 만들 수 있듯이, 이 함수는 데이터의 구조를 우리가 원하는 형태로 변형시켜줘요. 이는 예를 들어 1차원 데이터를 2차원 이미지로 변환하거나, 다차원 데이터를 다루기 쉬운 형태로 바꾸는 데 유용하게 사용돼요."*
> 

## 3.6 np.clip

- `np.clip()`은 배열의 값들을 특정 범위 내로 제한하는 함수입니다. 이 함수는 주어진 최소값보다 작은 값은 최소값으로, 최대값보다 큰 값은 최대값으로 변경합니다. 데이터 정규화나 이상치 처리에 매우 유용합니다.

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
clipped = np.clip(arr, 3, 8)
print("원본 배열:", arr)
print("클리핑된 배열:", clipped)

# 결과:
# 원본 배열: [ 1  2  3  4  5  6  7  8  9 10]
# 클리핑된 배열: [3 3 3 4 5 6 7 8 8 8]
```

> *"np.clip()은 마치 온도 조절기와 같아요. 방 온도가 설정한 최저 온도보다 낮아지면 히터가 켜지고, 최고 온도보다 높아지면 에어컨이 작동하는 것처럼, 이 함수는 데이터 값을 우리가 원하는 범위 내로 자동으로 조절해줍니다. 이는 센서 데이터 처리나 이미지 처리에서 픽셀 값을 제한할 때 자주 사용돼요. 또한 머신러닝에서 모델의 출력값을 특정 범위로 제한할 때도 유용하게 쓰입니다."*
> 

## 3.7 np.vectorize

- `np.vectorize()`는 일반 Python 함수를 NumPy 배열에 적용 가능한 벡터화된 함수로 변환합니다. 이는 배열의 각 요소에 대해 함수를 효율적으로 적용할 수 있게 해줍니다.

```python
def add_and_square(x, y):
    return (x + y) ** 2

vectorized_func = np.vectorize(add_and_square)

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = vectorized_func(a, b)
print("벡터화된 함수 결과:", result)

# 결과:# 벡터화된 함수 결과: [25 49 81]

```

> *"np.vectorize()는 마치 공장의 자동화 시스템과 같아요. 수작업으로 하나씩 처리하던 일을 자동화된 기계가 한 번에 처리하듯이, 이 함수는 일반 Python 함수를 NumPy 배열 전체에 효율적으로 적용할 수 있게 해줍니다. 이는 복잡한 연산을 배열의 모든 요소에 빠르게 적용해야 할 때 매우 유용하죠."*
> 

## 3.8 np.random.choice

- `np.random.choice()`는 주어진 1차원 배열에서 무작위로 샘플을 추출하는 함수입니다. 이 함수는 확률적 시뮬레이션, 랜덤 샘플링, 또는 데이터 분석에서 서브셋을 선택할 때 매우 유용합니다.

```python
# 기본 사용
arr = np.array([1, 2, 3, 4, 5])
random_sample = np.random.choice(arr, size=3, replace=False)
print("무작위 샘플:", random_sample)

# 결과(결과는 실행할 때마다 달라질 수 있습니다):
# 무작위 샘플: [3 1 5]
```

> *"np.random.choice()는 마치 추첨 상자와 같아요. 상자 안에 여러 개의 공(데이터)이 들어 있고, 우리는 그 중 몇 개를 무작위로 뽑아내는 거죠. 더 나아가, 각 공에 크기나 무게(확률)를 다르게 줄 수도 있어요. 이는 복권 추첨, 설문조사 대상자 선정, 또는 통계적 샘플링 등 다양한 상황을 시뮬레이션하는 데 매우 유용합니다. 머신러닝에서 학습 데이터를 무작위로 선택하거나, 몬테카를로 시뮬레이션 등에서 광범위하게 사용되는 중요한 함수예요."*
> 

## 3.9 np.random.rand

- `np.random.rand()`는 0과 1 사이의 균일 분포(uniform distribution)에서 무작위 숫자를 생성하는 함수입니다. 이 함수는 주어진 형태(shape)에 맞춰 난수 배열을 생성합니다.

```python
# 1차원 배열 생성
random_1d = np.random.rand(5)
print("1차원 난수 배열:", random_1d)

# 2차원 배열 생성
random_2d = np.random.rand(3, 2)
print("2차원 난수 배열:\n", random_2d)

# 결과 (결과는 실행할 때마다 달라집니다):
# 1차원 난수 배열: [0.12345678 0.23456789 0.34567890 0.45678901 0.56789012]
# 2차원 난수 배열:[[0.67890123 0.78901234]
								#  [0.89012345 0.90123456]
								#  [0.01234567 0.12345678]]
```

> *"np.random.rand()는 마치 무작위로 숫자를 생성하는 주사위와 같아요. 하지만 이 주사위는 0부터 1 사이의 모든 실수를 똑같은 확률로 던질 수 있죠. 이 함수는 시뮬레이션, 통계적 샘플링, 초기 가중치 설정 등 다양한 상황에서 사용됩니다. 특히 머신러닝에서 신경망의 초기 가중치를 설정하거나, 몬테카를로 시뮬레이션을 수행할 때 매우 유용해요."*
> 

## 3.10 np.load / np.save

- `np.save()`와 `np.load()`는 각각 NumPy 배열을 바이너리 형식으로 저장하고 불러오는 함수입니다. 이 함수들은 NumPy의 고유 `.npy` 형식을 사용하여 데이터의 구조와 데이터 타입을 그대로 보존합니다.

```python
# 데이터 저장하기
data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
np.save('data.npy', data)

# 데이터 불러오기
loaded_data = np.load('data.npy')
print("불러온 데이터:\n", loaded_data)

# 결과:# 불러온 데이터:# [[1 2 3]#  [4 5 6]#  [7 8 9]]

```

> *"np.save()와 np.load()는 마치 디지털 타임캡슐과 같아요. 현재의 데이터 상태를 그대로 '냉동 보존'했다가, 나중에 완전히 동일한 상태로 '해동'할 수 있게 해주죠. 이 함수들은 복잡한 NumPy 배열을 손실 없이 저장하고 불러올 수 있어, 대규모 수치 계산이나 머신러닝 모델의 중간 결과를 저장하는 데 매우 유용합니다. 텍스트 형식보다 더 효율적이고 정확하게 데이터를 보존할 수 있어요."*
> 

이상으로 NumPy의 다양한 함수들에 대해 알아보았습니다. 우리는 다음과 같은 주요 개념들을 살펴보았습니다:

1. `통계 함수`: 평균, 분산, 표준편차, 중앙값, 최빈값 등을 계산하여 데이터의 특성을 파악하는 함수들
2. `수학 함수`: 삼각함수, 지수함수, 로그함수, 제곱근, 거듭제곱 등 복잡한 수학적 연산을 수행하는 함수들
3. `유틸리티 함수`: 데이터 조작, 난수 생성, 데이터 입출력하는 함수들